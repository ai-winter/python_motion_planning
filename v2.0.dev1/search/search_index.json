{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p><code>Motion planning</code> plans the state sequence of the robot without conflict between the start and goal. </p> <p><code>Motion planning</code> mainly includes <code>Path planning</code> and <code>Trajectory planning</code>.</p> <ul> <li><code>Path Planning</code>: It's based on path constraints (such as obstacles), planning the optimal path sequence for the robot to travel without conflict between the start and goal.</li> <li><code>Trajectory planning</code>: It plans the motion state to approach the global path based on kinematics, dynamics constraints and path sequence.</li> </ul> <p>The theory analysis can be found at motion-planning.</p> <p>We also provide ROS C++ version and Matlab version.</p> <p>This repository provides the implementations of common <code>Motion planning</code> algorithms. Your stars and forks are welcome. Submitting pull requests or joining our development team are also welcome. For trivial modification, please directly contribute to <code>dev</code> branch. For big modification, please contact us before you contribute.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>The source file structure is shown below</p> Text Only<pre><code>python_motion_planning\n\u251c\u2500common\n|   \u251c\u2500env\n|   |   \u251c\u2500map\n|   |   \u251c\u2500robot\n|   |   \u2514\u2500world\n|   \u251c\u2500utils\n|   \u2514\u2500visualizer\n\u251c\u2500controller\n|   \u2514\u2500path_tracker\n\u251c\u2500path_planner\n|   \u251c\u2500graph_search\n|   \u2514\u2500sample_search\n\u2514\u2500curve_generation\n</code></pre>"},{"location":"index.html#install","title":"Install","text":"<p>(Optional) The code was tested in python=3.10, though other similar versions should also work. We recommend using <code>conda</code> to install the dependencies.</p> Bash<pre><code>conda create -n pmp python=3.10\nconda activate pmp\n</code></pre> <p>To install the repository, please run the following command in shell.</p> Bash<pre><code>pip install python-motion-planning==2.0.dev1\n</code></pre>"},{"location":"index.html#run","title":"Run","text":"<p>Please refer to the Tutorials part of online documentation.</p>"},{"location":"index.html#demos","title":"Demos","text":""},{"location":"index.html#path-planner","title":"Path Planner","text":"Planner 2D Grid 3D Grid GBFS Implemented in V1.1.1, not migrated Not implemented Dijkstra A* JPS Implemented in V1.1.1, not migrated Not implemented D* Implemented in V1.1.1, not migrated Not implemented LPA* Implemented in V1.1.1, not migrated Not implemented D* Lite Implemented in V1.1.1, not migrated Not implemented Theta* Lazy Theta* Implemented in V1.1.1, not migrated Not implemented S-Theta* Implemented in V1.1.1, not migrated Not implemented Anya Not implemented Not implemented Voronoi Implemented in V1.1.1, not migrated Not implemented RRT RRT* Informed RRT Implemented in V1.1.1, not migrated Not implemented RRT-Connect Implemented in V1.1.1, not migrated Not implemented ACO Implemented in V1.1.1, not migrated Not implemented GA Implemented in V1.1.1, not migrated Not implemented PSO Implemented in V1.1.1, not migrated Not implemented"},{"location":"index.html#controller","title":"Controller","text":"<p>We provide a toy simulator with simple physical simulation to test controllers (path-trakcers). The toy simulator supports multi-agents/multi-robots. The available robots include <code>CircularRobot</code> (Omnidirectional) and <code>DiffDriveRobot</code> (Only support moving forward and backward). Currently only 2D simulator is provided. 3D simulator has not been implemented.</p> <p>In the following demos, the blue robot 1 is the <code>CircularRobot</code>, and the orange robot 2 is the <code>DiffDriveRobot</code>.</p> Planner 2D 3D Path Trakcer Not implemented Pure Pursuit Not implemented PID Not implemented APF Not implemented DWA Not implemented RPP Implemented in V1.1.1, not migrated Not implemented LQR Implemented in V1.1.1, not migrated Not implemented MPC Implemented in V1.1.1, not migrated Not implemented MPPI Not implemented Not implemented TEB Not implemented Not implemented Lattice Not implemented Not implemented DQN Not implemented Not implemented DDPG Implemented in V1.0, not migrated Not implemented"},{"location":"index.html#curve-generator","title":"Curve Generator","text":"<p>The visualization of the curve generators has not been implemented in current version. They can be visualized in V1.1.1.</p> Planner 2D 3D Polynomia Not implemented Bezier Not implemented Cubic Spline Not implemented BSpline Not implemented Dubins Not implemented Reeds-Shepp Not implemented Fem-Pos Smoother Not implemented"},{"location":"index.html#contact","title":"Contact","text":"<p>Long-term maintainers:</p> <ul> <li>@omigeft (Wu Maojia)</li> <li>@ai-winter (Yang Haodong)</li> </ul> <p>You can contact us via the information provided on our profile.</p>"},{"location":"api/common/env/map/base_map/BaseMap.html","title":"BaseMap","text":""},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap","title":"<code>src.python_motion_planning.common.env.map.base_map.BaseMap</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for Path Planning Map.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Iterable</code> <p>The size of map in the world (shape: (n, 2) (n&gt;=2)). bounds[i, 0] means the lower bound of the world in the i-th dimension. bounds[i, 1] means the upper bound of the world in the i-th dimension.  </p> required <code>dtype</code> <code>dtype</code> <p>data type of coordinates</p> required Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>class BaseMap(ABC):\n    \"\"\"\n    Base class for Path Planning Map.\n\n    Args:\n        bounds: The size of map in the world (shape: (n, 2) (n&gt;=2)). bounds[i, 0] means the lower bound of the world in the i-th dimension. bounds[i, 1] means the upper bound of the world in the i-th dimension.  \n        dtype: data type of coordinates\n    \"\"\"\n    def __init__(self, bounds: Iterable, dtype: np.dtype) -&gt; None:\n        super().__init__()\n        self._bounds = np.asarray(bounds, dtype=float)\n        self._dtype = dtype\n\n        if len(self._bounds.shape) != 2 or self._bounds.shape[0] &lt;= 1 or self._bounds.shape[1] != 2:\n            raise ValueError(f\"The shape of bounds must be (n, 2) (n&gt;=2) instead of {self._bounds.shape}\")\n\n        for d in range(self._bounds.shape[0]):\n            if self._bounds[d, 0] &gt;= self._bounds[d, 1]:\n                raise ValueError(f\"The lower bound of the world in the {d}-th dimension must be smaller than the upper bound of the world in the {d}-th dimension.\")\n\n    @property\n    def bounds(self) -&gt; np.ndarray:\n        return self._bounds\n\n    @property\n    def dim(self) -&gt; int:\n        return self._bounds.shape[0]\n\n    @property\n    def dtype(self) -&gt; np.dtype:\n        return self._dtype\n\n    @abstractmethod\n    def map_to_world(self, point: tuple) -&gt; tuple:\n        \"\"\"\n        Convert map coordinates to world coordinates.\n\n        Args:\n            point: Point in map coordinates.\n\n        Returns:\n            point: Point in world coordinates.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def world_to_map(self, point: tuple) -&gt; tuple:\n        \"\"\"\n        Convert world coordinates to map coordinates.\n\n        Args:\n            point: Point in world coordinates.\n\n        Returns:\n            point: Point in map coordinates.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_distance(self, p1: tuple, p2: tuple) -&gt; float:\n        \"\"\"\n        Get the distance between two points.\n\n        Args:\n            p1: First point.\n            p2: Second point.\n\n        Returns:\n            dist: Distance between two points.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_neighbors(self, node: Node) -&gt; list:\n        \"\"\"\n        Get neighbor nodes of a given node.\n\n        Args:\n            node: Node to get neighbor nodes.\n\n        Returns:\n            nodes: List of neighbor nodes.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_expandable(self, point: tuple) -&gt; bool:\n        \"\"\"\n        Check if a point is expandable.\n\n        Args:\n            point: Point to check.\n\n        Returns:\n            expandable: True if the point is expandable, False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def in_collision(self, p1: tuple, p2: tuple) -&gt; bool:\n        \"\"\"\n        Check if the line of sight between two points is in collision.\n\n        Args:\n            p1: Start point of the line.\n            p2: End point of the line.\n\n        Returns:\n            in_collision: True if the line of sight is in collision, False otherwise.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap.get_distance","title":"<code>get_distance(p1, p2)</code>  <code>abstractmethod</code>","text":"<p>Get the distance between two points.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>tuple</code> <p>First point.</p> required <code>p2</code> <code>tuple</code> <p>Second point.</p> required <p>Returns:</p> Name Type Description <code>dist</code> <code>float</code> <p>Distance between two points.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>@abstractmethod\ndef get_distance(self, p1: tuple, p2: tuple) -&gt; float:\n    \"\"\"\n    Get the distance between two points.\n\n    Args:\n        p1: First point.\n        p2: Second point.\n\n    Returns:\n        dist: Distance between two points.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap.get_neighbors","title":"<code>get_neighbors(node)</code>  <code>abstractmethod</code>","text":"<p>Get neighbor nodes of a given node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to get neighbor nodes.</p> required <p>Returns:</p> Name Type Description <code>nodes</code> <code>list</code> <p>List of neighbor nodes.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>@abstractmethod\ndef get_neighbors(self, node: Node) -&gt; list:\n    \"\"\"\n    Get neighbor nodes of a given node.\n\n    Args:\n        node: Node to get neighbor nodes.\n\n    Returns:\n        nodes: List of neighbor nodes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap.in_collision","title":"<code>in_collision(p1, p2)</code>  <code>abstractmethod</code>","text":"<p>Check if the line of sight between two points is in collision.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>tuple</code> <p>Start point of the line.</p> required <code>p2</code> <code>tuple</code> <p>End point of the line.</p> required <p>Returns:</p> Name Type Description <code>in_collision</code> <code>bool</code> <p>True if the line of sight is in collision, False otherwise.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>@abstractmethod\ndef in_collision(self, p1: tuple, p2: tuple) -&gt; bool:\n    \"\"\"\n    Check if the line of sight between two points is in collision.\n\n    Args:\n        p1: Start point of the line.\n        p2: End point of the line.\n\n    Returns:\n        in_collision: True if the line of sight is in collision, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap.is_expandable","title":"<code>is_expandable(point)</code>  <code>abstractmethod</code>","text":"<p>Check if a point is expandable.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple</code> <p>Point to check.</p> required <p>Returns:</p> Name Type Description <code>expandable</code> <code>bool</code> <p>True if the point is expandable, False otherwise.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>@abstractmethod\ndef is_expandable(self, point: tuple) -&gt; bool:\n    \"\"\"\n    Check if a point is expandable.\n\n    Args:\n        point: Point to check.\n\n    Returns:\n        expandable: True if the point is expandable, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap.map_to_world","title":"<code>map_to_world(point)</code>  <code>abstractmethod</code>","text":"<p>Convert map coordinates to world coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple</code> <p>Point in map coordinates.</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>tuple</code> <p>Point in world coordinates.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>@abstractmethod\ndef map_to_world(self, point: tuple) -&gt; tuple:\n    \"\"\"\n    Convert map coordinates to world coordinates.\n\n    Args:\n        point: Point in map coordinates.\n\n    Returns:\n        point: Point in world coordinates.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/common/env/map/base_map/BaseMap.html#src.python_motion_planning.common.env.map.base_map.BaseMap.world_to_map","title":"<code>world_to_map(point)</code>  <code>abstractmethod</code>","text":"<p>Convert world coordinates to map coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple</code> <p>Point in world coordinates.</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>tuple</code> <p>Point in map coordinates.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\base_map.py</code> Python<pre><code>@abstractmethod\ndef world_to_map(self, point: tuple) -&gt; tuple:\n    \"\"\"\n    Convert world coordinates to map coordinates.\n\n    Args:\n        point: Point in world coordinates.\n\n    Returns:\n        point: Point in map coordinates.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html","title":"Grid","text":""},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid","title":"<code>src.python_motion_planning.common.env.map.grid.Grid</code>","text":"<p>               Bases: <code>BaseMap</code></p> <p>Class for Grid Map. The shape of each dimension of the grid map is determined by the base world and resolution. For each dimension, the conversion equation is: shape_grid = shape_world * resolution + 1 For example, if the base world is (30, 40) and the resolution is 0.5, the grid map will be (30 * 0.5 + 1, 40 * 0.5 + 1) = (61, 81).</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Iterable</code> <p>The size of map in the world (shape: (n, 2) (n&gt;=2)). bounds[i, 0] means the lower bound of the world in the i-th dimension. bounds[i, 1] means the upper bound of the world in the i-th dimension.</p> <code>[[0, 30], [0, 40]]</code> <code>resolution</code> <code>float</code> <p>resolution of the grid map</p> <code>1.0</code> <code>type_map</code> <code>Union[GridTypeMap, ndarray]</code> <p>initial type map of the grid map (its shape must be the same as the converted grid map shape, and its dtype must be int)</p> <code>None</code> <code>dtype</code> <code>dtype</code> <p>data type of coordinates (must be int)</p> <code>int32</code> <code>inflation_radius</code> <code>float</code> <p>radius of the inflation</p> <code>0.0</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; grid_map = Grid(bounds=[[0, 51], [0, 31]], resolution=0.5)\n&gt;&gt;&gt; grid_map\nGrid(bounds=[[ 0. 51.]\n [ 0. 31.]], resolution=0.5)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.bounds    # bounds of the base world\narray([[ 0., 51.],\n       [ 0., 31.]])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.dim\n2\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.resolution\n0.5\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.shape   # shape of the grid map\n(102, 62)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.dtype\n&lt;class 'numpy.int32'&gt;\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.type_map\nGridTypeMap(array(\n[[0 0 0 ... 0 0 0]\n [0 0 0 ... 0 0 0]\n [0 0 0 ... 0 0 0]\n ...\n [0 0 0 ... 0 0 0]\n [0 0 0 ... 0 0 0]\n [0 0 0 ... 0 0 0]]\n), shape=(102, 62), dtype=int8)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.map_to_world((1, 2))\n(0.75, 1.25)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.world_to_map((0.5, 1.0))\n(0, 2)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.get_neighbors(Node((1, 2)))\n[Node((0, 1), (1, 2), 0, 0), Node((0, 2), (1, 2), 0, 0), Node((0, 3), (1, 2), 0, 0), Node((1, 1), (1, 2), 0, 0), Node((1, 3), (1, 2), 0, 0), Node((2, 1), (1, 2), 0, 0), Node((2, 2), (1, 2), 0, 0), Node((2, 3), (1, 2), 0, 0)]\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.get_neighbors(Node((1, 2)), diagonal=False)\n[Node((2, 2), (1, 2), 0, 0), Node((0, 2), (1, 2), 0, 0), Node((1, 3), (1, 2), 0, 0), Node((1, 1), (1, 2), 0, 0)]\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.type_map[1, 0] = TYPES.OBSTACLE     # place an obstacle\n&gt;&gt;&gt; grid_map.get_neighbors(Node((0, 0)))    # limited within the bounds\n[Node((0, 1), (0, 0), 0, 0), Node((1, 0), (0, 0), 0, 0), Node((1, 1), (0, 0), 0, 0)]\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.get_neighbors(Node((grid_map.shape[0] - 1, grid_map.shape[1] - 1)), diagonal=False)  # limited within the boundss\n[Node((100, 61), (101, 61), 0, 0), Node((101, 60), (101, 61), 0, 0)]\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.line_of_sight((1, 2), (3, 6))\n[(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.line_of_sight((1, 2), (1, 2))\n[(1, 2)]\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.in_collision((1, 2), (3, 6))\nFalse\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_map.type_map[1, 3] = TYPES.OBSTACLE\n&gt;&gt;&gt; grid_map.update_esdf()\n&gt;&gt;&gt; grid_map.in_collision((1, 2), (3, 6))\nTrue\n</code></pre> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>class Grid(BaseMap):\n    \"\"\"\n    Class for Grid Map.\n    The shape of each dimension of the grid map is determined by the base world and resolution.\n    For each dimension, the conversion equation is: shape_grid = shape_world * resolution + 1\n    For example, if the base world is (30, 40) and the resolution is 0.5, the grid map will be (30 * 0.5 + 1, 40 * 0.5 + 1) = (61, 81).\n\n    Args:\n        bounds: The size of map in the world (shape: (n, 2) (n&gt;=2)). bounds[i, 0] means the lower bound of the world in the i-th dimension. bounds[i, 1] means the upper bound of the world in the i-th dimension.\n        resolution: resolution of the grid map\n        type_map: initial type map of the grid map (its shape must be the same as the converted grid map shape, and its dtype must be int)\n        dtype: data type of coordinates (must be int)\n        inflation_radius: radius of the inflation\n\n    Examples:\n        &gt;&gt;&gt; grid_map = Grid(bounds=[[0, 51], [0, 31]], resolution=0.5)\n        &gt;&gt;&gt; grid_map\n        Grid(bounds=[[ 0. 51.]\n         [ 0. 31.]], resolution=0.5)\n\n        &gt;&gt;&gt; grid_map.bounds    # bounds of the base world\n        array([[ 0., 51.],\n               [ 0., 31.]])\n\n        &gt;&gt;&gt; grid_map.dim\n        2\n\n        &gt;&gt;&gt; grid_map.resolution\n        0.5\n\n        &gt;&gt;&gt; grid_map.shape   # shape of the grid map\n        (102, 62)\n\n        &gt;&gt;&gt; grid_map.dtype\n        &lt;class 'numpy.int32'&gt;\n\n        &gt;&gt;&gt; grid_map.type_map\n        GridTypeMap(array(\n        [[0 0 0 ... 0 0 0]\n         [0 0 0 ... 0 0 0]\n         [0 0 0 ... 0 0 0]\n         ...\n         [0 0 0 ... 0 0 0]\n         [0 0 0 ... 0 0 0]\n         [0 0 0 ... 0 0 0]]\n        ), shape=(102, 62), dtype=int8)\n\n        &gt;&gt;&gt; grid_map.map_to_world((1, 2))\n        (0.75, 1.25)\n\n        &gt;&gt;&gt; grid_map.world_to_map((0.5, 1.0))\n        (0, 2)\n\n        &gt;&gt;&gt; grid_map.get_neighbors(Node((1, 2)))\n        [Node((0, 1), (1, 2), 0, 0), Node((0, 2), (1, 2), 0, 0), Node((0, 3), (1, 2), 0, 0), Node((1, 1), (1, 2), 0, 0), Node((1, 3), (1, 2), 0, 0), Node((2, 1), (1, 2), 0, 0), Node((2, 2), (1, 2), 0, 0), Node((2, 3), (1, 2), 0, 0)]\n\n        &gt;&gt;&gt; grid_map.get_neighbors(Node((1, 2)), diagonal=False)\n        [Node((2, 2), (1, 2), 0, 0), Node((0, 2), (1, 2), 0, 0), Node((1, 3), (1, 2), 0, 0), Node((1, 1), (1, 2), 0, 0)]\n\n        &gt;&gt;&gt; grid_map.type_map[1, 0] = TYPES.OBSTACLE     # place an obstacle\n        &gt;&gt;&gt; grid_map.get_neighbors(Node((0, 0)))    # limited within the bounds\n        [Node((0, 1), (0, 0), 0, 0), Node((1, 0), (0, 0), 0, 0), Node((1, 1), (0, 0), 0, 0)]\n\n        &gt;&gt;&gt; grid_map.get_neighbors(Node((grid_map.shape[0] - 1, grid_map.shape[1] - 1)), diagonal=False)  # limited within the boundss\n        [Node((100, 61), (101, 61), 0, 0), Node((101, 60), (101, 61), 0, 0)]\n\n        &gt;&gt;&gt; grid_map.line_of_sight((1, 2), (3, 6))\n        [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]\n\n        &gt;&gt;&gt; grid_map.line_of_sight((1, 2), (1, 2))\n        [(1, 2)]\n\n        &gt;&gt;&gt; grid_map.in_collision((1, 2), (3, 6))\n        False\n\n        &gt;&gt;&gt; grid_map.type_map[1, 3] = TYPES.OBSTACLE\n        &gt;&gt;&gt; grid_map.update_esdf()\n        &gt;&gt;&gt; grid_map.in_collision((1, 2), (3, 6))\n        True\n    \"\"\"\n    def __init__(self, \n                bounds: Iterable = [[0, 30], [0, 40]], \n                resolution: float = 1.0, \n                type_map: Union[GridTypeMap, np.ndarray] = None, \n                dtype: np.dtype = np.int32,\n                inflation_radius: float = 0.0,\n                ) -&gt; None:\n        super().__init__(bounds, dtype)\n\n        self._dtype_options = [np.int8, np.int16, np.int32, np.int64]\n        if self._dtype not in self._dtype_options:\n            raise ValueError(\"Dtype must be one of {} instead of {}\".format(self._dtype_options, self._dtype))\n\n        self._resolution = resolution\n        self._shape = tuple([int((self.bounds[i, 1] - self.bounds[i, 0]) / self.resolution) for i in range(self.dim)])\n\n        if type_map is None:\n            self.type_map = GridTypeMap(np.zeros(self._shape, dtype=np.int8))\n        else:\n            if type_map.shape != self._shape:\n                raise ValueError(\"Shape must be {} instead of {}\".format(self._shape, type_map.shape))\n            if type_map.dtype not in self._dtype_options:\n                raise ValueError(\"Dtype must be one of {} instead of {}\".format(self._dtype_options, type_map.dtype))\n\n            if isinstance(type_map, GridTypeMap):\n                self.type_map = type_map\n            elif isinstance(type_map, np.ndarray):\n                self.type_map = GridTypeMap(type_map)        \n            else:\n                raise ValueError(\"Type map must be GridTypeMap or numpy.ndarray instead of {}\".format(type(type_map)))\n\n        self._precompute_offsets()\n\n        self._esdf = np.zeros(self._shape, dtype=np.float32)\n        # self.update_esdf()    # updated in self.inflate_obstacles()\n\n        self.inflation_radius = inflation_radius\n        if self.inflation_radius &gt;= 1:\n            self.inflate_obstacles(self.inflation_radius)\n\n    def __str__(self) -&gt; str:\n        return \"Grid(bounds={}, resolution={})\".format(self.bounds, self.resolution)\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    @property\n    def resolution(self) -&gt; float:\n        return self._resolution\n\n    @property\n    def shape(self) -&gt; tuple:\n        return self._shape\n\n    @property\n    def esdf(self) -&gt; np.ndarray:\n        return self._esdf\n\n    def map_to_world(self, point: Tuple[int, ...]) -&gt; tuple:\n        \"\"\"\n        Convert map coordinates to world coordinates.\n\n        Args:\n            point: Point in map coordinates.\n\n        Returns:\n            point: Point in world coordinates.\n        \"\"\"\n        if len(point) != self.dim:\n            raise ValueError(\"Point dimension does not match map dimension.\")\n\n        return tuple((x + 0.5) * self.resolution + float(self.bounds[i, 0]) for i, x in enumerate(point))\n\n    def world_to_map(self, point: Tuple[float, ...]) -&gt; tuple:\n        \"\"\"\n        Convert world coordinates to map coordinates.\n\n        Args:\n            point: Point in world coordinates.\n\n        Returns:\n            point: Point in map coordinates.\n        \"\"\"\n        if len(point) != self.dim:\n            raise ValueError(\"Point dimension does not match map dimension.\")\n\n        return tuple(round((x - float(self.bounds[i, 0])) * (1.0 / self.resolution) - 0.5) for i, x in enumerate(point))\n\n    def get_distance(self, p1: Tuple[int, int], p2: Tuple[int, int]) -&gt; float:\n        \"\"\"\n        Get the distance between two points.\n\n        Args:\n            p1: Start point.\n            p2: Goal point.\n\n        Returns:\n            dist: Distance between two points.\n        \"\"\"\n        return Geometry.dist(p1, p2, type='Euclidean')\n\n    def within_bounds(self, point: Tuple[int, ...]) -&gt; bool:\n        \"\"\"\n        Check if a point is within the bounds of the grid map.\n\n        Args:\n            point: Point to check.\n\n        Returns:\n            bool: True if the point is within the bounds of the map, False otherwise.\n        \"\"\"\n        # if point.dim != self.dim:\n        #     raise ValueError(\"Point dimension does not match map dimension.\")\n\n        # return all(0 &lt;= point[i] &lt; self.shape[i] for i in range(self.dim))\n        dim = self.dim\n        shape = self.shape\n\n        for i in range(dim):\n            if not (0 &lt;= point[i] &lt; shape[i]):\n                return False\n        return True\n\n    def is_expandable(self, point: Tuple[int, ...], src_point: Tuple[int, ...] = None) -&gt; bool:\n        \"\"\"\n        Check if a point is expandable.\n\n        Args:\n            point: Point to check.\n            src_point: Source point.\n\n        Returns:\n            expandable: True if the point is expandable, False otherwise.\n        \"\"\"\n        if not self.within_bounds(point):\n            return False\n        if src_point is not None:\n            if self._esdf[point] &gt;= self._esdf[src_point]:\n                return True\n\n        return not self.type_map[point] == TYPES.OBSTACLE and not self.type_map[point] == TYPES.INFLATION\n\n    def get_neighbors(self, \n                    node: Node, \n                    diagonal: bool = True\n                    ) -&gt; list:\n        \"\"\"\n        Get neighbor nodes of a given node.\n\n        Args:\n            node: Node to get neighbor nodes.\n            diagonal: Whether to include diagonal neighbors.\n\n        Returns:\n            nodes: List of neighbor nodes.\n        \"\"\"\n        if node.dim != self.dim:\n            raise ValueError(\"Node dimension does not match map dimension.\")\n\n        # current_point = node.current.astype(self.dtype)\n        # current_pos = current_point.numpy()\n        # neighbors = []\n\n        offsets = self._diagonal_offsets if diagonal else self._orthogonal_offsets\n\n        # Generate all neighbor positions\n        # neighbor_positions = current_pos + offsets\n        neighbors = [node + offset for offset in offsets]\n        filtered_neighbors = []\n\n        # print(neighbors)\n\n        # Filter out positions outside map bounds\n        # for pos in neighbor_positions:\n        #     point = (pos, dtype=self.dtype)\n        #     if self.within_bounds(point):\n        #         if self.type_map[tuple(point)] != TYPES.OBSTACLE:\n        #             neighbor_node = Node(point, parent=current_point)\n        #             neighbors.append(neighbor_node)\n        for neighbor in neighbors:\n            if self.is_expandable(neighbor.current, node.current):\n                filtered_neighbors.append(neighbor)\n\n        # print(filtered_neighbors)\n\n        return filtered_neighbors\n\n    def line_of_sight(self, p1: Tuple[int, ...], p2: Tuple[int, ...]) -&gt; List[Tuple[int, ...]]:\n        \"\"\"\n        N-dimensional line of sight (Bresenham's line algorithm)\n\n        Args:\n            p1: Start point of the line.\n            p2: End point of the line.\n\n        Returns:\n            points: List of point on the line of sight.\n        \"\"\"\n        p1 = np.array(p1)\n        p2 = np.array(p2)\n\n        dim = len(p1)\n        delta = p2 - p1\n        abs_delta = np.abs(delta)\n\n        # Determine the main direction axis (the dimension with the greatest change)\n        primary_axis = np.argmax(abs_delta)\n        primary_step = 1 if delta[primary_axis] &gt; 0 else -1\n\n        # Initialize the error variable\n        error = np.zeros(dim, dtype=self.dtype)\n        delta2 = 2 * abs_delta\n\n        # Calculate the number of steps and initialize the current point\n        steps = abs_delta[primary_axis]\n        current = p1\n\n        # Allocate the result array\n        result = []\n        result.append(tuple(int(x) for x in current))\n\n        for i in range(1, steps + 1):\n            current[primary_axis] += primary_step\n\n            # Update the error for the primary dimension\n            for d in range(dim):\n                if d == primary_axis:\n                    continue\n\n                error[d] += delta2[d]\n                if error[d] &gt; abs_delta[primary_axis]:\n                    current[d] += 1 if delta[d] &gt; 0 else -1\n                    error[d] -= delta2[primary_axis]\n\n            result.append(tuple(int(x) for x in current))\n\n        return result\n\n    def in_collision(self, p1: Tuple[int, ...], p2: Tuple[int, ...]) -&gt; bool:\n        \"\"\"\n        Check if the line of sight between two points is in collision.\n\n        Args:\n            p1: Start point of the line.\n            p2: End point of the line.\n\n        Returns:\n            in_collision: True if the line of sight is in collision, False otherwise.\n        \"\"\"\n        if not self.is_expandable(p1) or not self.is_expandable(p2, p1):\n            return True\n\n        # Corner Case: Start and end points are the same\n        if p1 == p2:\n            return False\n\n        p1 = np.array(p1)\n        p2 = np.array(p2)\n\n        # Calculate delta and absolute delta\n        delta = p2 - p1\n        abs_delta = np.abs(delta)\n\n        # Determine the primary axis (the dimension with the greatest change)\n        primary_axis = np.argmax(abs_delta)\n        primary_step = 1 if delta[primary_axis] &gt; 0 else -1\n\n        # Initialize the error variable\n        error = np.zeros_like(delta, dtype=np.int32)\n        delta2 = 2 * abs_delta\n\n        # calculate the number of steps and initialize the current point\n        steps = abs_delta[primary_axis]\n        current = p1\n\n        for _ in range(steps):\n            last_point = current.copy()\n            current[primary_axis] += primary_step\n\n            # Update the error for the primary dimension\n            for d in range(len(delta)):\n                if d == primary_axis:\n                    continue\n\n                error[d] += delta2[d]\n                if error[d] &gt; abs_delta[primary_axis]:\n                    current[d] += 1 if delta[d] &gt; 0 else -1\n                    error[d] -= delta2[primary_axis]\n\n            # Check the current point\n            if not self.is_expandable(tuple(current), tuple(last_point)):\n                return True\n\n        return False\n\n    def fill_boundary_with_obstacles(self) -&gt; None:\n        \"\"\"\n        Fill the boundary of the map with obstacles.\n        \"\"\"\n        for d in range(self.dim):\n            # Create a tuple of slice objects to select boundary elements in current dimension\n            # First boundary (start index)\n            slices_start = [slice(None)] * self.dim\n            slices_start[d] = 0\n            self.type_map[tuple(slices_start)] = TYPES.OBSTACLE\n\n            # Last boundary (end index)\n            slices_end = [slice(None)] * self.dim\n            slices_end[d] = -1\n            self.type_map[tuple(slices_end)] = TYPES.OBSTACLE\n\n    def inflate_obstacles(self, radius: float = 1.0) -&gt; None:\n        \"\"\"\n        Inflate the obstacles in the map.\n\n        Args:\n            radius: Radius of the inflation.\n        \"\"\"\n        self.update_esdf()\n        mask = (self.esdf &lt;= radius) &amp; (self.type_map.array == TYPES.FREE)\n        self.type_map[mask] = TYPES.INFLATION\n        self.inflation_radius = radius\n\n    def fill_expands(self, expands: Dict[Tuple[int, int], Node]) -&gt; None:\n        \"\"\"\n        Fill the expands in the map.\n\n        Args:\n            expands: List of expands.\n        \"\"\"\n        for expand in expands.keys():\n            if self.type_map[expand] != TYPES.FREE:\n                continue\n            self.type_map[expand] = TYPES.EXPAND\n\n    def update_esdf(self) -&gt; None:\n        \"\"\"\n        Update the ESDF (signed Euclidean Distance Field) based on the obstacles in the map.\n        - Obstacle grid ESDF = 0\n        - Free grid ESDF &gt; 0. The value is the distance to the nearest obstacle\n        \"\"\"\n        obstacle_mask = (self.type_map.array == TYPES.OBSTACLE)\n        free_mask = ~obstacle_mask\n\n        # distance to obstacles\n        dist_outside = ndimage.distance_transform_edt(free_mask, sampling=self.resolution)\n        # distance to free space (internal distance of obstacles)\n        dist_inside = ndimage.distance_transform_edt(obstacle_mask, sampling=self.resolution)\n\n        self._esdf = dist_outside.astype(np.float32)\n        self._esdf[obstacle_mask] = -dist_inside[obstacle_mask]\n\n    def path_map_to_world(self, path: List[Tuple[int, int]]) -&gt; List[Tuple[float, float]]:\n        \"\"\"\n        Convert path from map coordinates to world coordinates\n\n        Args:\n            path: a list of map coordinates\n\n        Returns:\n            path: a list of world coordinates\n        \"\"\"\n        return [self.map_to_world(p) for p in path]\n\n    def path_world_to_map(self, path: List[Tuple[float, float]]) -&gt; List[Tuple[int, int]]:\n        \"\"\"\n        Convert path from world coordinates to map coordinates\n\n        Args:\n            path: a list of world coordinates\n\n        Returns:\n            path: a list of map coordinates\n        \"\"\"\n        return [self.world_to_map(p) for p in path]\n\n    def _precompute_offsets(self):\n        # Generate all possible offsets (-1, 0, +1) in each dimension\n        self._diagonal_offsets = np.array(np.meshgrid(*[[-1, 0, 1]]*self.dim), dtype=self.dtype).T.reshape(-1, self.dim)\n        # Remove the zero offset (current node itself)\n        self._diagonal_offsets = self._diagonal_offsets[np.any(self._diagonal_offsets != 0, axis=1)]\n        # self._diagonal_offsets = [Node((offset.tolist(), dtype=self.dtype)) for offset in self._diagonal_offsets]\n        self._diagonal_offsets = [Node(tuple(offset.tolist())) for offset in self._diagonal_offsets]\n\n        # Generate only orthogonal offsets (one dimension changes by \u00b11)\n        self._orthogonal_offsets = np.zeros((2*self.dim, self.dim), dtype=self.dtype)\n        for d in range(self.dim):\n            self._orthogonal_offsets[2*d, d] = 1\n            self._orthogonal_offsets[2*d+1, d] = -1\n        # self._orthogonal_offsets = [Node((offset.tolist(), dtype=self.dtype)) for offset in self._orthogonal_offsets]\n        self._orthogonal_offsets = [Node(tuple(offset.tolist())) for offset in self._orthogonal_offsets]\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.fill_boundary_with_obstacles","title":"<code>fill_boundary_with_obstacles()</code>","text":"<p>Fill the boundary of the map with obstacles.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def fill_boundary_with_obstacles(self) -&gt; None:\n    \"\"\"\n    Fill the boundary of the map with obstacles.\n    \"\"\"\n    for d in range(self.dim):\n        # Create a tuple of slice objects to select boundary elements in current dimension\n        # First boundary (start index)\n        slices_start = [slice(None)] * self.dim\n        slices_start[d] = 0\n        self.type_map[tuple(slices_start)] = TYPES.OBSTACLE\n\n        # Last boundary (end index)\n        slices_end = [slice(None)] * self.dim\n        slices_end[d] = -1\n        self.type_map[tuple(slices_end)] = TYPES.OBSTACLE\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.fill_expands","title":"<code>fill_expands(expands)</code>","text":"<p>Fill the expands in the map.</p> <p>Parameters:</p> Name Type Description Default <code>expands</code> <code>Dict[Tuple[int, int], Node]</code> <p>List of expands.</p> required Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def fill_expands(self, expands: Dict[Tuple[int, int], Node]) -&gt; None:\n    \"\"\"\n    Fill the expands in the map.\n\n    Args:\n        expands: List of expands.\n    \"\"\"\n    for expand in expands.keys():\n        if self.type_map[expand] != TYPES.FREE:\n            continue\n        self.type_map[expand] = TYPES.EXPAND\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.get_distance","title":"<code>get_distance(p1, p2)</code>","text":"<p>Get the distance between two points.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Tuple[int, int]</code> <p>Start point.</p> required <code>p2</code> <code>Tuple[int, int]</code> <p>Goal point.</p> required <p>Returns:</p> Name Type Description <code>dist</code> <code>float</code> <p>Distance between two points.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def get_distance(self, p1: Tuple[int, int], p2: Tuple[int, int]) -&gt; float:\n    \"\"\"\n    Get the distance between two points.\n\n    Args:\n        p1: Start point.\n        p2: Goal point.\n\n    Returns:\n        dist: Distance between two points.\n    \"\"\"\n    return Geometry.dist(p1, p2, type='Euclidean')\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.get_neighbors","title":"<code>get_neighbors(node, diagonal=True)</code>","text":"<p>Get neighbor nodes of a given node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to get neighbor nodes.</p> required <code>diagonal</code> <code>bool</code> <p>Whether to include diagonal neighbors.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>nodes</code> <code>list</code> <p>List of neighbor nodes.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def get_neighbors(self, \n                node: Node, \n                diagonal: bool = True\n                ) -&gt; list:\n    \"\"\"\n    Get neighbor nodes of a given node.\n\n    Args:\n        node: Node to get neighbor nodes.\n        diagonal: Whether to include diagonal neighbors.\n\n    Returns:\n        nodes: List of neighbor nodes.\n    \"\"\"\n    if node.dim != self.dim:\n        raise ValueError(\"Node dimension does not match map dimension.\")\n\n    # current_point = node.current.astype(self.dtype)\n    # current_pos = current_point.numpy()\n    # neighbors = []\n\n    offsets = self._diagonal_offsets if diagonal else self._orthogonal_offsets\n\n    # Generate all neighbor positions\n    # neighbor_positions = current_pos + offsets\n    neighbors = [node + offset for offset in offsets]\n    filtered_neighbors = []\n\n    # print(neighbors)\n\n    # Filter out positions outside map bounds\n    # for pos in neighbor_positions:\n    #     point = (pos, dtype=self.dtype)\n    #     if self.within_bounds(point):\n    #         if self.type_map[tuple(point)] != TYPES.OBSTACLE:\n    #             neighbor_node = Node(point, parent=current_point)\n    #             neighbors.append(neighbor_node)\n    for neighbor in neighbors:\n        if self.is_expandable(neighbor.current, node.current):\n            filtered_neighbors.append(neighbor)\n\n    # print(filtered_neighbors)\n\n    return filtered_neighbors\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.in_collision","title":"<code>in_collision(p1, p2)</code>","text":"<p>Check if the line of sight between two points is in collision.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Tuple[int, ...]</code> <p>Start point of the line.</p> required <code>p2</code> <code>Tuple[int, ...]</code> <p>End point of the line.</p> required <p>Returns:</p> Name Type Description <code>in_collision</code> <code>bool</code> <p>True if the line of sight is in collision, False otherwise.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def in_collision(self, p1: Tuple[int, ...], p2: Tuple[int, ...]) -&gt; bool:\n    \"\"\"\n    Check if the line of sight between two points is in collision.\n\n    Args:\n        p1: Start point of the line.\n        p2: End point of the line.\n\n    Returns:\n        in_collision: True if the line of sight is in collision, False otherwise.\n    \"\"\"\n    if not self.is_expandable(p1) or not self.is_expandable(p2, p1):\n        return True\n\n    # Corner Case: Start and end points are the same\n    if p1 == p2:\n        return False\n\n    p1 = np.array(p1)\n    p2 = np.array(p2)\n\n    # Calculate delta and absolute delta\n    delta = p2 - p1\n    abs_delta = np.abs(delta)\n\n    # Determine the primary axis (the dimension with the greatest change)\n    primary_axis = np.argmax(abs_delta)\n    primary_step = 1 if delta[primary_axis] &gt; 0 else -1\n\n    # Initialize the error variable\n    error = np.zeros_like(delta, dtype=np.int32)\n    delta2 = 2 * abs_delta\n\n    # calculate the number of steps and initialize the current point\n    steps = abs_delta[primary_axis]\n    current = p1\n\n    for _ in range(steps):\n        last_point = current.copy()\n        current[primary_axis] += primary_step\n\n        # Update the error for the primary dimension\n        for d in range(len(delta)):\n            if d == primary_axis:\n                continue\n\n            error[d] += delta2[d]\n            if error[d] &gt; abs_delta[primary_axis]:\n                current[d] += 1 if delta[d] &gt; 0 else -1\n                error[d] -= delta2[primary_axis]\n\n        # Check the current point\n        if not self.is_expandable(tuple(current), tuple(last_point)):\n            return True\n\n    return False\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.inflate_obstacles","title":"<code>inflate_obstacles(radius=1.0)</code>","text":"<p>Inflate the obstacles in the map.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the inflation.</p> <code>1.0</code> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def inflate_obstacles(self, radius: float = 1.0) -&gt; None:\n    \"\"\"\n    Inflate the obstacles in the map.\n\n    Args:\n        radius: Radius of the inflation.\n    \"\"\"\n    self.update_esdf()\n    mask = (self.esdf &lt;= radius) &amp; (self.type_map.array == TYPES.FREE)\n    self.type_map[mask] = TYPES.INFLATION\n    self.inflation_radius = radius\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.is_expandable","title":"<code>is_expandable(point, src_point=None)</code>","text":"<p>Check if a point is expandable.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[int, ...]</code> <p>Point to check.</p> required <code>src_point</code> <code>Tuple[int, ...]</code> <p>Source point.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>expandable</code> <code>bool</code> <p>True if the point is expandable, False otherwise.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def is_expandable(self, point: Tuple[int, ...], src_point: Tuple[int, ...] = None) -&gt; bool:\n    \"\"\"\n    Check if a point is expandable.\n\n    Args:\n        point: Point to check.\n        src_point: Source point.\n\n    Returns:\n        expandable: True if the point is expandable, False otherwise.\n    \"\"\"\n    if not self.within_bounds(point):\n        return False\n    if src_point is not None:\n        if self._esdf[point] &gt;= self._esdf[src_point]:\n            return True\n\n    return not self.type_map[point] == TYPES.OBSTACLE and not self.type_map[point] == TYPES.INFLATION\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.line_of_sight","title":"<code>line_of_sight(p1, p2)</code>","text":"<p>N-dimensional line of sight (Bresenham's line algorithm)</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Tuple[int, ...]</code> <p>Start point of the line.</p> required <code>p2</code> <code>Tuple[int, ...]</code> <p>End point of the line.</p> required <p>Returns:</p> Name Type Description <code>points</code> <code>List[Tuple[int, ...]]</code> <p>List of point on the line of sight.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def line_of_sight(self, p1: Tuple[int, ...], p2: Tuple[int, ...]) -&gt; List[Tuple[int, ...]]:\n    \"\"\"\n    N-dimensional line of sight (Bresenham's line algorithm)\n\n    Args:\n        p1: Start point of the line.\n        p2: End point of the line.\n\n    Returns:\n        points: List of point on the line of sight.\n    \"\"\"\n    p1 = np.array(p1)\n    p2 = np.array(p2)\n\n    dim = len(p1)\n    delta = p2 - p1\n    abs_delta = np.abs(delta)\n\n    # Determine the main direction axis (the dimension with the greatest change)\n    primary_axis = np.argmax(abs_delta)\n    primary_step = 1 if delta[primary_axis] &gt; 0 else -1\n\n    # Initialize the error variable\n    error = np.zeros(dim, dtype=self.dtype)\n    delta2 = 2 * abs_delta\n\n    # Calculate the number of steps and initialize the current point\n    steps = abs_delta[primary_axis]\n    current = p1\n\n    # Allocate the result array\n    result = []\n    result.append(tuple(int(x) for x in current))\n\n    for i in range(1, steps + 1):\n        current[primary_axis] += primary_step\n\n        # Update the error for the primary dimension\n        for d in range(dim):\n            if d == primary_axis:\n                continue\n\n            error[d] += delta2[d]\n            if error[d] &gt; abs_delta[primary_axis]:\n                current[d] += 1 if delta[d] &gt; 0 else -1\n                error[d] -= delta2[primary_axis]\n\n        result.append(tuple(int(x) for x in current))\n\n    return result\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.map_to_world","title":"<code>map_to_world(point)</code>","text":"<p>Convert map coordinates to world coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[int, ...]</code> <p>Point in map coordinates.</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>tuple</code> <p>Point in world coordinates.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def map_to_world(self, point: Tuple[int, ...]) -&gt; tuple:\n    \"\"\"\n    Convert map coordinates to world coordinates.\n\n    Args:\n        point: Point in map coordinates.\n\n    Returns:\n        point: Point in world coordinates.\n    \"\"\"\n    if len(point) != self.dim:\n        raise ValueError(\"Point dimension does not match map dimension.\")\n\n    return tuple((x + 0.5) * self.resolution + float(self.bounds[i, 0]) for i, x in enumerate(point))\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.path_map_to_world","title":"<code>path_map_to_world(path)</code>","text":"<p>Convert path from map coordinates to world coordinates</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>List[Tuple[int, int]]</code> <p>a list of map coordinates</p> required <p>Returns:</p> Name Type Description <code>path</code> <code>List[Tuple[float, float]]</code> <p>a list of world coordinates</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def path_map_to_world(self, path: List[Tuple[int, int]]) -&gt; List[Tuple[float, float]]:\n    \"\"\"\n    Convert path from map coordinates to world coordinates\n\n    Args:\n        path: a list of map coordinates\n\n    Returns:\n        path: a list of world coordinates\n    \"\"\"\n    return [self.map_to_world(p) for p in path]\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.path_world_to_map","title":"<code>path_world_to_map(path)</code>","text":"<p>Convert path from world coordinates to map coordinates</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>List[Tuple[float, float]]</code> <p>a list of world coordinates</p> required <p>Returns:</p> Name Type Description <code>path</code> <code>List[Tuple[int, int]]</code> <p>a list of map coordinates</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def path_world_to_map(self, path: List[Tuple[float, float]]) -&gt; List[Tuple[int, int]]:\n    \"\"\"\n    Convert path from world coordinates to map coordinates\n\n    Args:\n        path: a list of world coordinates\n\n    Returns:\n        path: a list of map coordinates\n    \"\"\"\n    return [self.world_to_map(p) for p in path]\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.update_esdf","title":"<code>update_esdf()</code>","text":"<p>Update the ESDF (signed Euclidean Distance Field) based on the obstacles in the map. - Obstacle grid ESDF = 0 - Free grid ESDF &gt; 0. The value is the distance to the nearest obstacle</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def update_esdf(self) -&gt; None:\n    \"\"\"\n    Update the ESDF (signed Euclidean Distance Field) based on the obstacles in the map.\n    - Obstacle grid ESDF = 0\n    - Free grid ESDF &gt; 0. The value is the distance to the nearest obstacle\n    \"\"\"\n    obstacle_mask = (self.type_map.array == TYPES.OBSTACLE)\n    free_mask = ~obstacle_mask\n\n    # distance to obstacles\n    dist_outside = ndimage.distance_transform_edt(free_mask, sampling=self.resolution)\n    # distance to free space (internal distance of obstacles)\n    dist_inside = ndimage.distance_transform_edt(obstacle_mask, sampling=self.resolution)\n\n    self._esdf = dist_outside.astype(np.float32)\n    self._esdf[obstacle_mask] = -dist_inside[obstacle_mask]\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.within_bounds","title":"<code>within_bounds(point)</code>","text":"<p>Check if a point is within the bounds of the grid map.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[int, ...]</code> <p>Point to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the point is within the bounds of the map, False otherwise.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def within_bounds(self, point: Tuple[int, ...]) -&gt; bool:\n    \"\"\"\n    Check if a point is within the bounds of the grid map.\n\n    Args:\n        point: Point to check.\n\n    Returns:\n        bool: True if the point is within the bounds of the map, False otherwise.\n    \"\"\"\n    # if point.dim != self.dim:\n    #     raise ValueError(\"Point dimension does not match map dimension.\")\n\n    # return all(0 &lt;= point[i] &lt; self.shape[i] for i in range(self.dim))\n    dim = self.dim\n    shape = self.shape\n\n    for i in range(dim):\n        if not (0 &lt;= point[i] &lt; shape[i]):\n            return False\n    return True\n</code></pre>"},{"location":"api/common/env/map/grid/Grid.html#src.python_motion_planning.common.env.map.grid.Grid.world_to_map","title":"<code>world_to_map(point)</code>","text":"<p>Convert world coordinates to map coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, ...]</code> <p>Point in world coordinates.</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>tuple</code> <p>Point in map coordinates.</p> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>def world_to_map(self, point: Tuple[float, ...]) -&gt; tuple:\n    \"\"\"\n    Convert world coordinates to map coordinates.\n\n    Args:\n        point: Point in world coordinates.\n\n    Returns:\n        point: Point in map coordinates.\n    \"\"\"\n    if len(point) != self.dim:\n        raise ValueError(\"Point dimension does not match map dimension.\")\n\n    return tuple(round((x - float(self.bounds[i, 0])) * (1.0 / self.resolution) - 0.5) for i, x in enumerate(point))\n</code></pre>"},{"location":"api/common/env/map/grid/GridTypeMap.html","title":"GridTypeMap","text":""},{"location":"api/common/env/map/grid/GridTypeMap.html#src.python_motion_planning.common.env.map.grid.GridTypeMap","title":"<code>src.python_motion_planning.common.env.map.grid.GridTypeMap</code>","text":"<p>Class for Grid Type Map. It is like a np.ndarray, except that its shape and dtype are fixed.</p> <p>Parameters:</p> Name Type Description Default <code>type_map</code> <code>ndarray</code> <p>The np.ndarray type map.</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; type_map = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=np.int8)\n&gt;&gt;&gt; grid_type_map = GridTypeMap(type_map)\n&gt;&gt;&gt; grid_type_map\nGridTypeMap(array(\n[[0 0 0]\n [0 1 0]\n [0 0 0]]\n), shape=(3, 3), dtype=int8)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_type_map.array\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]], dtype=int8)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_type_map.shape\n(3, 3)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_type_map.dtype\ndtype('int8')\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; new_array = np.array([[1, 1, 1], [0, 0, 0], [0, 0, 0]], dtype=np.int8)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_type_map.update(new_array)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; grid_type_map\nGridTypeMap(array(\n[[1 1 1]\n [0 0 0]\n [0 0 0]]\n), shape=(3, 3), dtype=int8)\n</code></pre> Source code in <code>src\\python_motion_planning\\common\\env\\map\\grid.py</code> Python<pre><code>class GridTypeMap:\n    \"\"\"\n    Class for Grid Type Map. It is like a np.ndarray, except that its shape and dtype are fixed.\n\n    Args:\n        type_map: The np.ndarray type map.\n\n    Examples:\n        &gt;&gt;&gt; type_map = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=np.int8)\n        &gt;&gt;&gt; grid_type_map = GridTypeMap(type_map)\n        &gt;&gt;&gt; grid_type_map\n        GridTypeMap(array(\n        [[0 0 0]\n         [0 1 0]\n         [0 0 0]]\n        ), shape=(3, 3), dtype=int8)\n\n        &gt;&gt;&gt; grid_type_map.array\n        array([[0, 0, 0],\n               [0, 1, 0],\n               [0, 0, 0]], dtype=int8)\n\n        &gt;&gt;&gt; grid_type_map.shape\n        (3, 3)\n\n        &gt;&gt;&gt; grid_type_map.dtype\n        dtype('int8')\n\n        &gt;&gt;&gt; new_array = np.array([[1, 1, 1], [0, 0, 0], [0, 0, 0]], dtype=np.int8)\n\n        &gt;&gt;&gt; grid_type_map.update(new_array)\n\n        &gt;&gt;&gt; grid_type_map\n        GridTypeMap(array(\n        [[1 1 1]\n         [0 0 0]\n         [0 0 0]]\n        ), shape=(3, 3), dtype=int8)\n    \"\"\"\n    def __init__(self, type_map: np.ndarray):\n        self._array = np.asarray(type_map)\n        self._shape = self._array.shape\n        self._dtype = self._array.dtype\n\n        self._dtype_options = [np.int8, np.int16, np.int32, np.int64]\n        if self._dtype not in self._dtype_options:\n            raise ValueError(\"Dtype must be one of {} instead of {}\".format(self._dtype_options, self._dtype))\n\n    def __str__(self) -&gt; str:\n        return \"GridTypeMap(array(\\n{}\\n), shape={}, dtype={})\".format(self._array, self._shape, self._dtype)\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    def __getitem__(self, idx):\n        return self._array[idx]\n\n    def __setitem__(self, idx, value):\n        self._array[idx] = value\n\n    @property\n    def array(self) -&gt; np.ndarray:\n        return self._array.view()\n\n    @property\n    def shape(self) -&gt; Tuple:\n        return self._shape\n\n    @property\n    def dtype(self) -&gt; np.dtype:\n        return self._dtype\n\n    def update(self, new_array):\n        new_array = np.asarray(new_array)\n        if new_array.shape != self._shape:\n            raise ValueError(f\"Shape must be {self._shape}\")\n        if new_array.dtype != self.dtype:\n            raise ValueError(f\"New values dtype must be {self.dtype}\")\n        np.copyto(self._array, new_array)\n</code></pre>"},{"location":"api/common/env/node/Node.html","title":"Node","text":""},{"location":"api/common/env/node/Node.html#src.python_motion_planning.common.env.node.Node","title":"<code>src.python_motion_planning.common.env.node.Node</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for map nodes.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>tuple</code> <p>current point</p> required <code>parent</code> <code>tuple</code> <p>point of parent node</p> <code>None</code> <code>g</code> <code>float</code> <p>path cost</p> <code>0</code> <code>h</code> <code>float</code> <p>heuristic cost</p> <code>0</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; node1 = Node((1, 0), (2, 3), 1, 2)\n&gt;&gt;&gt; node2 = Node((1, 0), (2, 3), 1, 2)\n&gt;&gt;&gt; node3 = Node((1, 1), (2, 3), 1, 2)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1\nNode((1, 0), (2, 3), 1, 2)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1 + node2\nNode((2, 0), (1, 0), 2, 2)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1 == node2\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1 != node3\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1.current\n(1, 0)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1.parent\n(2, 3)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1.g\n1\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1.h\n2\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; node1.dim\n2\n</code></pre> Source code in <code>src\\python_motion_planning\\common\\env\\node.py</code> Python<pre><code>class Node(object):\n    \"\"\"\n    Class for map nodes.\n\n    Args:\n        current: current point\n        parent: point of parent node\n        g: path cost\n        h: heuristic cost\n\n    Examples:\n        &gt;&gt;&gt; node1 = Node((1, 0), (2, 3), 1, 2)\n        &gt;&gt;&gt; node2 = Node((1, 0), (2, 3), 1, 2)\n        &gt;&gt;&gt; node3 = Node((1, 1), (2, 3), 1, 2)\n\n        &gt;&gt;&gt; node1\n        Node((1, 0), (2, 3), 1, 2)\n\n        &gt;&gt;&gt; node1 + node2\n        Node((2, 0), (1, 0), 2, 2)\n\n        &gt;&gt;&gt; node1 == node2\n        True\n\n        &gt;&gt;&gt; node1 != node3\n        True\n\n        &gt;&gt;&gt; node1.current\n        (1, 0)\n\n        &gt;&gt;&gt; node1.parent\n        (2, 3)\n\n        &gt;&gt;&gt; node1.g\n        1\n\n        &gt;&gt;&gt; node1.h\n        2\n\n        &gt;&gt;&gt; node1.dim\n        2\n    \"\"\"\n    def __init__(self, current: tuple, parent: tuple = None, g: float = 0, h: float = 0) -&gt; None:\n        self._current = current\n        self.parent = parent\n        self._g = g\n        self._h = h\n\n        if self.parent is not None and len(self.current) != len(self.parent):\n            raise ValueError(\"The dimension of current \" + str(self.current) + \" and parent \" + str(self.parent) + \" must be the same.\")\n\n    def __add__(self, node: Node) -&gt; Node:\n        return Node(tuple(x+y for x, y in zip(self._current, node._current)), self._current, self._g + node._g, self._h)\n\n    def __eq__(self, node: Node) -&gt; bool:\n        if not isinstance(node, Node):\n            return False\n        return self._current == node._current\n\n    def __ne__(self, node: Node) -&gt; bool:\n        return not self.__eq__(node)\n\n    def __lt__(self, node: Node) -&gt; bool:\n        return self._g + self._h &lt; node._g + node._h or \\\n                (self._g + self._h == node._g + node._h and self._h &lt; node._h)\n\n    def __hash__(self) -&gt; int:\n        return hash(self._current)\n\n    def __str__(self) -&gt; str:\n        return \"Node({}, {}, {}, {})\".format(self._current, self.parent, self._g, self._h)\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    def __len__(self) -&gt; int:\n        return len(self.current)\n\n    @property\n    def current(self) -&gt; tuple:\n        return self._current\n\n    @property\n    def g(self) -&gt; float:\n        return self._g\n\n    @g.setter\n    def g(self, value: float) -&gt; None:\n        self._g = value\n\n    @property\n    def h(self) -&gt; float:\n        return self._h\n\n    @h.setter\n    def h(self, value: float) -&gt; None:\n        self._h = value\n\n    @property\n    def dim(self) -&gt; int:\n        return len(self.current)\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html","title":"BaseRobot","text":""},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot","title":"<code>src.python_motion_planning.common.env.robot.base_robot.BaseRobot</code>","text":"<p>Base class for robots.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension</p> <code>2</code> <code>mass</code> <code>float</code> <p>Mass of the robot</p> <code>1.0</code> <code>pose</code> <code>Optional[ndarray]</code> <p>Current pose (position + orientation) (world frame)</p> <code>None</code> <code>vel</code> <code>Optional[ndarray]</code> <p>Current velocity (linear + angular) (world frame)</p> <code>None</code> <code>max_lin_speed</code> <code>float</code> <p>Maximum linear speed</p> <code>inf</code> <code>max_ang_speed</code> <code>float</code> <p>Maximum angular speed</p> <code>inf</code> <code>action_min</code> <code>Optional[ndarray]</code> <p>Minimum action bounds (robot frame)</p> <code>None</code> <code>action_max</code> <code>Optional[ndarray]</code> <p>Maximum action bounds (robot frame)</p> <code>None</code> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>class BaseRobot:\n    \"\"\"\n    Base class for robots.\n\n    Args:\n        dim: Space dimension\n        mass: Mass of the robot\n        pose: Current pose (position + orientation) (world frame)\n        vel: Current velocity (linear + angular) (world frame)\n        max_lin_speed: Maximum linear speed\n        max_ang_speed: Maximum angular speed\n        action_min: Minimum action bounds (robot frame)\n        action_max: Maximum action bounds (robot frame)\n    \"\"\"\n    def __init__(self, dim: int = 2, mass: float = 1.0,\n                 pose: Optional[np.ndarray] = None, vel: Optional[np.ndarray] = None, \n                 max_lin_speed: float = np.inf, max_ang_speed: float = np.inf,\n                 action_min: Optional[np.ndarray] = None, action_max: Optional[np.ndarray] = None):\n        self.dim = dim\n        if dim not in (2, 3):\n            raise NotImplementedError(f\"Only 2D and 3D are supported, got {dim}D\")\n\n        self.pose_dim = 3 if dim == 2 else 6\n\n        self.mass = float(mass)\n\n        # Pose: position + orientation\n        # 2D: [x, y, theta] where theta is angle in radians\n        # 3D: [x, y, z, roll, pitch, yaw]\n        self._pose = np.zeros(self.pose_dim) if pose is None else np.array(pose, dtype=float)\n        self._vel = np.zeros(self.pose_dim) if vel is None else np.array(vel, dtype=float)\n\n        if len(self._pose) != self.pose_dim:\n            raise ValueError(f\"len(pose) must be {self.pose_dim} if dim=={self.dim}, got {len(pose)}\")\n\n        if len(self._vel) != self.pose_dim:\n            raise ValueError(f\"len(vel) must be {self.pose_dim} if dim=={self.dim}, got {len(vel)}\")\n\n        self.max_lin_speed = max_lin_speed\n        self.max_ang_speed = max_ang_speed\n\n        # acceleration is set externally by controller each step\n        # 2D actions: [longitudinal_acc, lateral_acc, angular_acc]\n        # 3D actions: [x_acc, y_acc, z_acc, roll_acc, pitch_acc, yaw_acc]\n        self.acc = np.zeros(self.pose_dim)\n\n        # action bounds per-dim (controller output bounds)\n        if action_min is None:\n            action_min = -np.ones(self.pose_dim) * 1.0\n        if action_max is None:\n            action_max = np.ones(self.pose_dim) * 1.0\n        self.action_min = np.array(action_min, dtype=float)\n        self.action_max = np.array(action_max, dtype=float)\n\n    @property\n    def pose(self):\n        \"\"\"Get position + orientation\"\"\"\n        return self._pose\n\n    @pose.setter\n    def pose(self, value: np.ndarray) -&gt; None:\n        \"\"\"Set position + orientation\"\"\"\n        self._pose[:self.dim] = value[:self.dim]\n        self._pose[self.dim:] = Geometry.regularize_orient(value[self.dim:])\n\n    @property\n    def vel(self):\n        \"\"\"Get linear + angular velocity\"\"\"\n        return self._vel\n\n    @vel.setter\n    def vel(self, value: np.ndarray) -&gt; None:\n        \"\"\"Set linear + angular velocity\"\"\"\n        self._vel = value \n\n    @property\n    def pos(self):\n        \"\"\"Get position from pose\"\"\"\n        return self._pose[:self.dim]\n\n    @pos.setter\n    def pos(self, value: np.ndarray):\n        \"\"\"Set position in pose\"\"\"\n        self._pose[:self.dim] = value\n\n    @property\n    def orient(self):\n        \"\"\"Get orientation from pose\"\"\"\n        return self._pose[self.dim:]\n\n    @orient.setter\n    def orient(self, value: np.ndarray):\n        \"\"\"Set orientation in pose\"\"\"\n        self._pose[self.dim:] = Geometry.regularize_orient(value)\n\n    @property\n    def lin_vel(self):\n        \"\"\"Get linear velocity\"\"\"\n        return self._vel[:self.dim]\n\n    @lin_vel.setter\n    def lin_vel(self, value: np.ndarray):\n        \"\"\"Set linear velocity\"\"\"\n        self._vel[:self.dim] = value\n\n    @property\n    def ang_vel(self):\n        \"\"\"Get angular velocity\"\"\"\n        return self._vel[self.dim:]\n\n    @ang_vel.setter\n    def ang_vel(self, value: np.ndarray):\n        \"\"\"Set angular velocity\"\"\"\n        self._vel[self.dim:] = value\n\n    def observation_size(self, env) -&gt; int:\n        \"\"\"\n        Default observation space: [pos, orientation, vel, ang_vel]\n        \"\"\"\n        # Pose (Position (dim) + orientation (1 if dim==2 or 3 if dim==3)) + \n        #   velocity (linear velocity (dim) + angular velocity (1 if dim==2 or 3 if dim==3))\n        if self.dim == 2:   \n            orient_dim = 1\n        elif self.dim == 3:\n            orient_dim = 3\n        else:\n            raise ValueError(\"Invalid dimension\")\n\n        return 2 * self.dim + 2 * orient_dim\n\n    def get_observation(self, env) -&gt; np.ndarray:\n        \"\"\"\n        Get observation vector for this robot including orientation.\n        \"\"\"\n        obs = []\n        obs.extend(self.pos.tolist())  # Position\n        obs.extend(self.orient.tolist())  # Orientation\n        obs.extend(self.lin_vel.tolist())  # Linear velocity\n        obs.extend(self.ang_vel.tolist())  # Angular velocity\n\n        return np.array(obs, dtype=float)\n\n    def kinematic_model(self, pose: np.ndarray, vel: np.ndarray, acc: np.ndarray, env_acc: np.ndarray, dt: float) -&gt; Tuple[np.ndarray, np.ndarray, dict]:\n        \"\"\"\n        Kinematic model (used to simulate the robot motion without updating the robot state)\n\n        Args:\n            pose: robot pose    (world frame)\n            vel: robot velocity (world frame)\n            acc: robot acceleration action (world frame)\n            env_acc: environment acceleration (world frame)\n            dt: time step length\n\n        Returns:\n            pose: new robot pose    (world frame)\n            vel: new robot velocity (world frame)\n            info: auxiliary information\n        \"\"\"\n        net_acc = acc + env_acc    # acc is clipped. env_acc no need to clip.\n\n        # semi-implicit Euler integration\n        vel = vel + net_acc * dt\n\n        # clip linear and angular velocity\n        vel = self.clip_velocity(vel)\n\n        # update pose\n        pose = pose + vel * dt\n\n        return pose, vel, {}\n\n    def step(self, env_acc: np.ndarray, dt: float) -&gt; None:\n        \"\"\"\n        Take a step in simulation using differential drive kinematics.\n        self.acc and self.vel are in world frame. You have to transform them into robot frame if needed.\n\n        Args:\n            env_acc: acceleration vector from environment\n            dt: time step size\n        \"\"\"\n        self.pose, self.vel, info = self.kinematic_model(self.pose, self.vel, self.acc, env_acc, dt)\n\n    def clip_linear_velocity(self, lv: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Clip linear velocity to maximum allowed value.\"\"\"\n        return lv if np.linalg.norm(lv) &lt;= self.max_lin_speed else lv / np.linalg.norm(lv) * self.max_lin_speed\n\n    def clip_angular_velocity(self, av: float or np.ndarray) -&gt; float or np.ndarray:\n        \"\"\"Clip angular velocity to maximum allowed value.\"\"\"\n        if self.dim == 2:\n            return av if abs(av) &lt;= self.max_ang_speed else np.sign(av) * self.max_ang_speed\n        else:  # 3D\n            norm = np.linalg.norm(av)\n            return av if norm &lt;= self.max_ang_speed else av / norm * self.max_ang_speed\n\n    def clip_velocity(self, v: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Clip linear and angular velocity to maximum allowed value.\"\"\"\n        lv = v[:self.dim]\n        av = v[self.dim:self.pose_dim]\n        return np.concatenate([self.clip_linear_velocity(lv), self.clip_angular_velocity(av)])\n\n    def clip_action(self, a: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Clip action to action bounds.\"\"\"\n        return np.minimum(np.maximum(a, self.action_min), self.action_max)\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.ang_vel","title":"<code>ang_vel</code>  <code>property</code> <code>writable</code>","text":"<p>Get angular velocity</p>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.lin_vel","title":"<code>lin_vel</code>  <code>property</code> <code>writable</code>","text":"<p>Get linear velocity</p>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.orient","title":"<code>orient</code>  <code>property</code> <code>writable</code>","text":"<p>Get orientation from pose</p>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.pos","title":"<code>pos</code>  <code>property</code> <code>writable</code>","text":"<p>Get position from pose</p>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.pose","title":"<code>pose</code>  <code>property</code> <code>writable</code>","text":"<p>Get position + orientation</p>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.vel","title":"<code>vel</code>  <code>property</code> <code>writable</code>","text":"<p>Get linear + angular velocity</p>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.clip_action","title":"<code>clip_action(a)</code>","text":"<p>Clip action to action bounds.</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def clip_action(self, a: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Clip action to action bounds.\"\"\"\n    return np.minimum(np.maximum(a, self.action_min), self.action_max)\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.clip_angular_velocity","title":"<code>clip_angular_velocity(av)</code>","text":"<p>Clip angular velocity to maximum allowed value.</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def clip_angular_velocity(self, av: float or np.ndarray) -&gt; float or np.ndarray:\n    \"\"\"Clip angular velocity to maximum allowed value.\"\"\"\n    if self.dim == 2:\n        return av if abs(av) &lt;= self.max_ang_speed else np.sign(av) * self.max_ang_speed\n    else:  # 3D\n        norm = np.linalg.norm(av)\n        return av if norm &lt;= self.max_ang_speed else av / norm * self.max_ang_speed\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.clip_linear_velocity","title":"<code>clip_linear_velocity(lv)</code>","text":"<p>Clip linear velocity to maximum allowed value.</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def clip_linear_velocity(self, lv: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Clip linear velocity to maximum allowed value.\"\"\"\n    return lv if np.linalg.norm(lv) &lt;= self.max_lin_speed else lv / np.linalg.norm(lv) * self.max_lin_speed\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.clip_velocity","title":"<code>clip_velocity(v)</code>","text":"<p>Clip linear and angular velocity to maximum allowed value.</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def clip_velocity(self, v: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Clip linear and angular velocity to maximum allowed value.\"\"\"\n    lv = v[:self.dim]\n    av = v[self.dim:self.pose_dim]\n    return np.concatenate([self.clip_linear_velocity(lv), self.clip_angular_velocity(av)])\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.get_observation","title":"<code>get_observation(env)</code>","text":"<p>Get observation vector for this robot including orientation.</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def get_observation(self, env) -&gt; np.ndarray:\n    \"\"\"\n    Get observation vector for this robot including orientation.\n    \"\"\"\n    obs = []\n    obs.extend(self.pos.tolist())  # Position\n    obs.extend(self.orient.tolist())  # Orientation\n    obs.extend(self.lin_vel.tolist())  # Linear velocity\n    obs.extend(self.ang_vel.tolist())  # Angular velocity\n\n    return np.array(obs, dtype=float)\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.kinematic_model","title":"<code>kinematic_model(pose, vel, acc, env_acc, dt)</code>","text":"<p>Kinematic model (used to simulate the robot motion without updating the robot state)</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>ndarray</code> <p>robot pose    (world frame)</p> required <code>vel</code> <code>ndarray</code> <p>robot velocity (world frame)</p> required <code>acc</code> <code>ndarray</code> <p>robot acceleration action (world frame)</p> required <code>env_acc</code> <code>ndarray</code> <p>environment acceleration (world frame)</p> required <code>dt</code> <code>float</code> <p>time step length</p> required <p>Returns:</p> Name Type Description <code>pose</code> <code>ndarray</code> <p>new robot pose    (world frame)</p> <code>vel</code> <code>ndarray</code> <p>new robot velocity (world frame)</p> <code>info</code> <code>dict</code> <p>auxiliary information</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def kinematic_model(self, pose: np.ndarray, vel: np.ndarray, acc: np.ndarray, env_acc: np.ndarray, dt: float) -&gt; Tuple[np.ndarray, np.ndarray, dict]:\n    \"\"\"\n    Kinematic model (used to simulate the robot motion without updating the robot state)\n\n    Args:\n        pose: robot pose    (world frame)\n        vel: robot velocity (world frame)\n        acc: robot acceleration action (world frame)\n        env_acc: environment acceleration (world frame)\n        dt: time step length\n\n    Returns:\n        pose: new robot pose    (world frame)\n        vel: new robot velocity (world frame)\n        info: auxiliary information\n    \"\"\"\n    net_acc = acc + env_acc    # acc is clipped. env_acc no need to clip.\n\n    # semi-implicit Euler integration\n    vel = vel + net_acc * dt\n\n    # clip linear and angular velocity\n    vel = self.clip_velocity(vel)\n\n    # update pose\n    pose = pose + vel * dt\n\n    return pose, vel, {}\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.observation_size","title":"<code>observation_size(env)</code>","text":"<p>Default observation space: [pos, orientation, vel, ang_vel]</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def observation_size(self, env) -&gt; int:\n    \"\"\"\n    Default observation space: [pos, orientation, vel, ang_vel]\n    \"\"\"\n    # Pose (Position (dim) + orientation (1 if dim==2 or 3 if dim==3)) + \n    #   velocity (linear velocity (dim) + angular velocity (1 if dim==2 or 3 if dim==3))\n    if self.dim == 2:   \n        orient_dim = 1\n    elif self.dim == 3:\n        orient_dim = 3\n    else:\n        raise ValueError(\"Invalid dimension\")\n\n    return 2 * self.dim + 2 * orient_dim\n</code></pre>"},{"location":"api/common/env/robot/base_robot/BaseRobot.html#src.python_motion_planning.common.env.robot.base_robot.BaseRobot.step","title":"<code>step(env_acc, dt)</code>","text":"<p>Take a step in simulation using differential drive kinematics. self.acc and self.vel are in world frame. You have to transform them into robot frame if needed.</p> <p>Parameters:</p> Name Type Description Default <code>env_acc</code> <code>ndarray</code> <p>acceleration vector from environment</p> required <code>dt</code> <code>float</code> <p>time step size</p> required Source code in <code>src\\python_motion_planning\\common\\env\\robot\\base_robot.py</code> Python<pre><code>def step(self, env_acc: np.ndarray, dt: float) -&gt; None:\n    \"\"\"\n    Take a step in simulation using differential drive kinematics.\n    self.acc and self.vel are in world frame. You have to transform them into robot frame if needed.\n\n    Args:\n        env_acc: acceleration vector from environment\n        dt: time step size\n    \"\"\"\n    self.pose, self.vel, info = self.kinematic_model(self.pose, self.vel, self.acc, env_acc, dt)\n</code></pre>"},{"location":"api/common/env/robot/circular_robot/CircularRobot.html","title":"CircularRobot","text":""},{"location":"api/common/env/robot/circular_robot/CircularRobot.html#src.python_motion_planning.common.env.robot.circular_robot.CircularRobot","title":"<code>src.python_motion_planning.common.env.robot.circular_robot.CircularRobot</code>","text":"<p>               Bases: <code>BaseRobot</code></p> <p>Base class for circular omnidirectional robots.</p> <p>Parameters:</p> Name Type Description Default <code>**args</code> <p>see the parent class</p> <code>()</code> <code>radius</code> <code>float</code> <p>Radius of the robot</p> <code>0.5</code> <code>color</code> <code>str</code> <p>Visualization color</p> <code>'C0'</code> <code>alpha</code> <code>float</code> <p>Visualization alpha</p> <code>1.0</code> <code>fill</code> <code>bool</code> <p>Visualization fill</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Visualization linewidth</p> <code>1.0</code> <code>linestyle</code> <code>str</code> <p>Visualization linestyle</p> <code>'-'</code> <code>text</code> <code>str</code> <p>Visualization text (visualized in the center of the robot)</p> <code>''</code> <code>text_color</code> <code>str</code> <p>Visualization text color</p> <code>'white'</code> <code>fontsize</code> <code>str</code> <p>Visualization text fontsize</p> <code>None</code> <code>**kwargs</code> <p>see the parent class</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\circular_robot.py</code> Python<pre><code>class CircularRobot(BaseRobot):\n    \"\"\"\n    Base class for circular omnidirectional robots.\n\n    Args:\n        **args: see the parent class\n        radius: Radius of the robot\n        color: Visualization color\n        alpha: Visualization alpha\n        fill: Visualization fill\n        linewidth: Visualization linewidth\n        linestyle: Visualization linestyle\n        text: Visualization text (visualized in the center of the robot)\n        text_color: Visualization text color\n        fontsize: Visualization text fontsize\n        **kwargs: see the parent class\n    \"\"\"\n    def __init__(self, *args, radius: float = 0.5, color: str = \"C0\", alpha: float = 1.0, \n                 fill: bool = True, linewidth: float = 1.0, linestyle: str = \"-\",\n                 text: str = \"\", text_color: str = 'white', fontsize: str = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.radius = float(radius)\n\n        # visualization parameters\n        self.color = color\n        self.alpha = alpha\n        self.fill = fill\n        self.linewidth = linewidth\n        self.linestyle = linestyle\n        self.text = text\n        self.text_color = text_color\n        self.fontsize = fontsize\n</code></pre>"},{"location":"api/common/env/robot/diff_drive_robot/DiffDriveRobot.html","title":"DiffDriveRobot","text":""},{"location":"api/common/env/robot/diff_drive_robot/DiffDriveRobot.html#src.python_motion_planning.common.env.robot.diff_drive_robot.DiffDriveRobot","title":"<code>src.python_motion_planning.common.env.robot.diff_drive_robot.DiffDriveRobot</code>","text":"<p>               Bases: <code>CircularRobot</code></p> <p>Differential drive robot with non-holonomic constraints. Inherits from CircularRobot and overrides the dynamics. action space should be [longitudinal_vel, 0.0, angular_vel] (lateral velocity should be 0.0)</p> <p>Parameters:</p> Name Type Description Default <code>wheel_base</code> <code>float</code> <p>Distance between left and right wheels</p> <code>0.5</code> <code>wheel_radius</code> <code>float</code> <p>Radius of wheels (for conversion between wheel speed and linear velocity)</p> <code>0.2</code> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\diff_drive_robot.py</code> Python<pre><code>class DiffDriveRobot(CircularRobot):\n    \"\"\"\n    Differential drive robot with non-holonomic constraints.\n    Inherits from CircularRobot and overrides the dynamics.\n    action space should be [longitudinal_vel, 0.0, angular_vel] (lateral velocity should be 0.0)\n\n    Args:\n        wheel_base: Distance between left and right wheels\n        wheel_radius: Radius of wheels (for conversion between wheel speed and linear velocity)\n        Other parameters are the same as CircularRobot.\n    \"\"\"\n    def __init__(self, wheel_base: float = 0.5, wheel_radius: float = 0.2, **kwargs):\n        super().__init__(**kwargs)\n        if self.dim != 2:\n            raise NotImplementedError(\"DiffDriveRobot only supports 2D\")\n\n        # diff-drive robot does not have lateral control\n        self.action_min[1] = 0.0\n        self.action_max[1] = 0.0\n\n        self.wheel_base = float(wheel_base)\n        self.wheel_radius = float(wheel_radius)\n\n        # store wheel velocities [left, right]\n        self.wheel_vel = np.zeros(2)    # robot frame\n\n    def kinematic_model(self, pose: np.ndarray, vel: np.ndarray, acc: np.ndarray, env_acc: np.ndarray, dt: float) -&gt; Tuple[np.ndarray, np.ndarray, dict]:\n        \"\"\"\n        Kinematic model (used to simulate the robot motion without updating the robot state)\n\n        Args:\n            pose: robot pose    (world frame)\n            vel: robot velocity (world frame)\n            acc: robot acceleration action (world frame)\n            env_acc: environment acceleration (world frame)\n            dt: time step length\n\n        Returns:\n            pose: new robot pose    (world frame)\n            vel: new robot velocity (world frame)\n            info: auxiliary information\n        \"\"\"\n        orient = pose[self.dim:self.dim*2]\n\n        # compute wheel velocities\n        action = FrameTransformer.vel_world_to_robot(self.dim, acc, orient) # robot frame\n\n        # compute desired velocities after integration\n        vel_robot = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)    # robot frame\n        vel_robot[0] += action[0] * dt     # longitudinal velocity robot frame\n        # no lateral velocity\n        vel_robot[2] += action[2] * dt     # angular velocity robot frame\n\n        # map to wheel velocities\n        v_l = vel_robot[0] - (self.wheel_base / 2.0) * vel_robot[2]\n        v_r = vel_robot[0] + (self.wheel_base / 2.0) * vel_robot[2]\n\n        wheel_vel = np.array([v_l, v_r])  # robot frame\n\n        # differential drive kinematics\n        v = (v_r + v_l) / 2.0       # robot frame\n        omega = (v_r - v_l) / self.wheel_base   # robot frame\n\n        old_vel_robot = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)    # robot frame\n        vel_robot = np.array([v, old_vel_robot[1], omega])   # robot frame\n\n        # lateral motion is restricted by sliding friction\n        env_acc_robot = FrameTransformer.vel_world_to_robot(self.dim, env_acc, orient)    # robot frame\n        env_acc_robot[1] *= 100.0   # The estimated multiple of sliding friction coefficient to rolling friction coefficient\n        if env_acc_robot[1] * dt &gt; vel_robot[1]:\n            env_acc_robot[1] = -vel_robot[1] / dt\n\n        vel_robot += env_acc_robot * dt    # environment force\n\n        vel = FrameTransformer.vel_robot_to_world(self.dim, vel_robot, orient)    # world frame\n\n        vel = self.clip_velocity(vel)\n\n        # update pose\n        pose = pose + vel * dt\n\n        info = {\"wheel_vel\": wheel_vel}\n\n        return pose, vel, info\n\n    def step(self, env_acc: np.ndarray, dt: float) -&gt; None:\n        \"\"\"\n        Take a step in simulation using differential drive kinematics.\n        self.acc and self.vel are in world frame. You have to transform them into robot frame if needed.\n\n        Args:\n            env_acc: acceleration vector from environment\n            dt: time step size\n        \"\"\"\n        self.pose, self.vel, info = self.kinematic_model(self.pose, self.vel, self.acc, env_acc, dt)\n        self.wheel_vel = info[\"wheel_vel\"]\n</code></pre>"},{"location":"api/common/env/robot/diff_drive_robot/DiffDriveRobot.html#src.python_motion_planning.common.env.robot.diff_drive_robot.DiffDriveRobot.kinematic_model","title":"<code>kinematic_model(pose, vel, acc, env_acc, dt)</code>","text":"<p>Kinematic model (used to simulate the robot motion without updating the robot state)</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>ndarray</code> <p>robot pose    (world frame)</p> required <code>vel</code> <code>ndarray</code> <p>robot velocity (world frame)</p> required <code>acc</code> <code>ndarray</code> <p>robot acceleration action (world frame)</p> required <code>env_acc</code> <code>ndarray</code> <p>environment acceleration (world frame)</p> required <code>dt</code> <code>float</code> <p>time step length</p> required <p>Returns:</p> Name Type Description <code>pose</code> <code>ndarray</code> <p>new robot pose    (world frame)</p> <code>vel</code> <code>ndarray</code> <p>new robot velocity (world frame)</p> <code>info</code> <code>dict</code> <p>auxiliary information</p> Source code in <code>src\\python_motion_planning\\common\\env\\robot\\diff_drive_robot.py</code> Python<pre><code>def kinematic_model(self, pose: np.ndarray, vel: np.ndarray, acc: np.ndarray, env_acc: np.ndarray, dt: float) -&gt; Tuple[np.ndarray, np.ndarray, dict]:\n    \"\"\"\n    Kinematic model (used to simulate the robot motion without updating the robot state)\n\n    Args:\n        pose: robot pose    (world frame)\n        vel: robot velocity (world frame)\n        acc: robot acceleration action (world frame)\n        env_acc: environment acceleration (world frame)\n        dt: time step length\n\n    Returns:\n        pose: new robot pose    (world frame)\n        vel: new robot velocity (world frame)\n        info: auxiliary information\n    \"\"\"\n    orient = pose[self.dim:self.dim*2]\n\n    # compute wheel velocities\n    action = FrameTransformer.vel_world_to_robot(self.dim, acc, orient) # robot frame\n\n    # compute desired velocities after integration\n    vel_robot = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)    # robot frame\n    vel_robot[0] += action[0] * dt     # longitudinal velocity robot frame\n    # no lateral velocity\n    vel_robot[2] += action[2] * dt     # angular velocity robot frame\n\n    # map to wheel velocities\n    v_l = vel_robot[0] - (self.wheel_base / 2.0) * vel_robot[2]\n    v_r = vel_robot[0] + (self.wheel_base / 2.0) * vel_robot[2]\n\n    wheel_vel = np.array([v_l, v_r])  # robot frame\n\n    # differential drive kinematics\n    v = (v_r + v_l) / 2.0       # robot frame\n    omega = (v_r - v_l) / self.wheel_base   # robot frame\n\n    old_vel_robot = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)    # robot frame\n    vel_robot = np.array([v, old_vel_robot[1], omega])   # robot frame\n\n    # lateral motion is restricted by sliding friction\n    env_acc_robot = FrameTransformer.vel_world_to_robot(self.dim, env_acc, orient)    # robot frame\n    env_acc_robot[1] *= 100.0   # The estimated multiple of sliding friction coefficient to rolling friction coefficient\n    if env_acc_robot[1] * dt &gt; vel_robot[1]:\n        env_acc_robot[1] = -vel_robot[1] / dt\n\n    vel_robot += env_acc_robot * dt    # environment force\n\n    vel = FrameTransformer.vel_robot_to_world(self.dim, vel_robot, orient)    # world frame\n\n    vel = self.clip_velocity(vel)\n\n    # update pose\n    pose = pose + vel * dt\n\n    info = {\"wheel_vel\": wheel_vel}\n\n    return pose, vel, info\n</code></pre>"},{"location":"api/common/env/robot/diff_drive_robot/DiffDriveRobot.html#src.python_motion_planning.common.env.robot.diff_drive_robot.DiffDriveRobot.step","title":"<code>step(env_acc, dt)</code>","text":"<p>Take a step in simulation using differential drive kinematics. self.acc and self.vel are in world frame. You have to transform them into robot frame if needed.</p> <p>Parameters:</p> Name Type Description Default <code>env_acc</code> <code>ndarray</code> <p>acceleration vector from environment</p> required <code>dt</code> <code>float</code> <p>time step size</p> required Source code in <code>src\\python_motion_planning\\common\\env\\robot\\diff_drive_robot.py</code> Python<pre><code>def step(self, env_acc: np.ndarray, dt: float) -&gt; None:\n    \"\"\"\n    Take a step in simulation using differential drive kinematics.\n    self.acc and self.vel are in world frame. You have to transform them into robot frame if needed.\n\n    Args:\n        env_acc: acceleration vector from environment\n        dt: time step size\n    \"\"\"\n    self.pose, self.vel, info = self.kinematic_model(self.pose, self.vel, self.acc, env_acc, dt)\n    self.wheel_vel = info[\"wheel_vel\"]\n</code></pre>"},{"location":"api/common/env/types/TYPES.html","title":"TYPES","text":""},{"location":"api/common/env/types/TYPES.html#src.python_motion_planning.common.env.types.TYPES","title":"<code>src.python_motion_planning.common.env.types.TYPES</code>","text":"<p>Macro definition of types of plots in maps. They must be integers in sequence of (0, 1, 2, ...).</p> Source code in <code>src\\python_motion_planning\\common\\env\\types.py</code> Python<pre><code>class TYPES:\n    \"\"\"\n    Macro definition of types of plots in maps. They must be integers in sequence of (0, 1, 2, ...).\n    \"\"\"\n    FREE = 0\n    OBSTACLE = 1\n    START = 2\n    GOAL = 3\n    INFLATION = 4\n    EXPAND = 5\n    CUSTOM = 6\n</code></pre>"},{"location":"api/common/env/world/base_world/BaseWorld.html","title":"BaseWorld","text":""},{"location":"api/common/env/world/base_world/BaseWorld.html#src.python_motion_planning.common.env.world.base_world.BaseWorld","title":"<code>src.python_motion_planning.common.env.world.base_world.BaseWorld</code>","text":"<p>               Bases: <code>Env</code></p> <p>Base class of world (environment contains physical robots).</p> Source code in <code>src\\python_motion_planning\\common\\env\\world\\base_world.py</code> Python<pre><code>class BaseWorld(gym.Env):\n    \"\"\"\n    Base class of world (environment contains physical robots).\n    \"\"\"\n    metadata = {\"render.modes\": [\"human\"]}\n\n    def __init__(self):\n        super().__init__()\n        self.robots: Dict[str, BaseRobot] = {}\n        # observation_space and action_space are per-robot; environment doesn't expose global spaces\n        # but we provide a dummy space to match gym's requirement\n        self.observation_space = spaces.Box(-np.inf, np.inf, shape=(1,), dtype=float)\n        self.action_space = spaces.Box(-np.inf, np.inf, shape=(1,), dtype=float)\n\n    def add_robot(self, rid: str, robot: BaseRobot):\n        \"\"\"\n        Add a robot to the world.\n\n        Args:\n            rid: unique robot id\n            robot: robot instance\n        \"\"\"\n        if robot.dim != self.dim:\n            raise ValueError(\"Robot dimension must match environment dimension\")\n        self.robots[rid] = robot\n\n    def reset(self, seed: Optional[int] = None):\n        \"\"\"\n        Reset the environment.\n\n        Args:\n            seed: random seed\n\n        Returns:\n            observation: Initial observation after reset\n        \"\"\"\n        super().reset(seed=seed)\n        self.step_count = 0\n        # optionally randomize initial states or rely on robots' initial pos/vel\n        # return dict of observations keyed by robot index\n        obs = {}\n        for rid, robot in self.robots.items():\n            obs[rid] = robot.get_observation(self)\n        return obs, {}\n\n    def step(self, actions: Dict[int, np.ndarray]):\n        \"\"\"\n        Execute one time step in the environment.\n\n        Args:\n            actions: dict mapping robot_index -&gt; acceleration ndarray (dim,)\n\n        Returns:\n            obs_dict: dict mapping robot_index -&gt; observation ndarray (dim,)\n            reward_dict: dict mapping robot_index -&gt; reward scalar\n            done_dict: dict mapping robot_index -&gt; bool\n            info: dict\n        \"\"\"\n        self.step_count += 1\n\n        obs = {rid: robot.get_observation(self) for rid, robot in self.robots.items()}\n        # no rewards by default; you can extend\n        rewards = {rid: 0.0 for rid in self.robots}\n        dones = {rid: False for rid in self.robots}\n        terminated = False\n        truncated = self.step_count &gt;= self.max_episode_steps\n        info = {}\n        return obs, rewards, dones, {\"terminated\": terminated, \"truncated\": truncated, **info}\n\n    def render(self, mode=\"human\", ax=None):\n        \"\"\"\n        Render the environment.\n\n        Args:\n            mode: rendering mode\n            ax: matplotlib axis to render to\n        \"\"\"\n        # delegated to demo functions; keep signature for Gym compatibility\n        raise NotImplementedError(\"render(): use provided demo_2d/demo_3d functions for visualization.\")\n\n    def close(self):\n        pass\n\n    # helper to build spaces per-robot\n    def build_robot_spaces(self, robot: BaseRobot) -&gt; Tuple[spaces.Box, spaces.Box]:\n        \"\"\"\n        Build observation and action spaces for given robot\n\n        Args:\n            robot: given robot\n\n        Returns:\n            observation_space: shape (observation_size,)\n            action_space: shape (dim,) bounded by robot.action_min / action_max\n        \"\"\"\n        obs_dim = robot.observation_size(self)\n        obs_low = -np.inf * np.ones(obs_dim)\n        obs_high = np.inf * np.ones(obs_dim)\n        obs_space = spaces.Box(obs_low, obs_high, dtype=float)\n        act_low = robot.action_min\n        act_high = robot.action_max\n        act_space = spaces.Box(act_low, act_high, dtype=float)\n        return obs_space, act_space\n</code></pre>"},{"location":"api/common/env/world/base_world/BaseWorld.html#src.python_motion_planning.common.env.world.base_world.BaseWorld.add_robot","title":"<code>add_robot(rid, robot)</code>","text":"<p>Add a robot to the world.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>str</code> <p>unique robot id</p> required <code>robot</code> <code>BaseRobot</code> <p>robot instance</p> required Source code in <code>src\\python_motion_planning\\common\\env\\world\\base_world.py</code> Python<pre><code>def add_robot(self, rid: str, robot: BaseRobot):\n    \"\"\"\n    Add a robot to the world.\n\n    Args:\n        rid: unique robot id\n        robot: robot instance\n    \"\"\"\n    if robot.dim != self.dim:\n        raise ValueError(\"Robot dimension must match environment dimension\")\n    self.robots[rid] = robot\n</code></pre>"},{"location":"api/common/env/world/base_world/BaseWorld.html#src.python_motion_planning.common.env.world.base_world.BaseWorld.build_robot_spaces","title":"<code>build_robot_spaces(robot)</code>","text":"<p>Build observation and action spaces for given robot</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>BaseRobot</code> <p>given robot</p> required <p>Returns:</p> Name Type Description <code>observation_space</code> <code>Box</code> <p>shape (observation_size,)</p> <code>action_space</code> <code>Box</code> <p>shape (dim,) bounded by robot.action_min / action_max</p> Source code in <code>src\\python_motion_planning\\common\\env\\world\\base_world.py</code> Python<pre><code>def build_robot_spaces(self, robot: BaseRobot) -&gt; Tuple[spaces.Box, spaces.Box]:\n    \"\"\"\n    Build observation and action spaces for given robot\n\n    Args:\n        robot: given robot\n\n    Returns:\n        observation_space: shape (observation_size,)\n        action_space: shape (dim,) bounded by robot.action_min / action_max\n    \"\"\"\n    obs_dim = robot.observation_size(self)\n    obs_low = -np.inf * np.ones(obs_dim)\n    obs_high = np.inf * np.ones(obs_dim)\n    obs_space = spaces.Box(obs_low, obs_high, dtype=float)\n    act_low = robot.action_min\n    act_high = robot.action_max\n    act_space = spaces.Box(act_low, act_high, dtype=float)\n    return obs_space, act_space\n</code></pre>"},{"location":"api/common/env/world/base_world/BaseWorld.html#src.python_motion_planning.common.env.world.base_world.BaseWorld.render","title":"<code>render(mode='human', ax=None)</code>","text":"<p>Render the environment.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <p>rendering mode</p> <code>'human'</code> <code>ax</code> <p>matplotlib axis to render to</p> <code>None</code> Source code in <code>src\\python_motion_planning\\common\\env\\world\\base_world.py</code> Python<pre><code>def render(self, mode=\"human\", ax=None):\n    \"\"\"\n    Render the environment.\n\n    Args:\n        mode: rendering mode\n        ax: matplotlib axis to render to\n    \"\"\"\n    # delegated to demo functions; keep signature for Gym compatibility\n    raise NotImplementedError(\"render(): use provided demo_2d/demo_3d functions for visualization.\")\n</code></pre>"},{"location":"api/common/env/world/base_world/BaseWorld.html#src.python_motion_planning.common.env.world.base_world.BaseWorld.reset","title":"<code>reset(seed=None)</code>","text":"<p>Reset the environment.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>Optional[int]</code> <p>random seed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>observation</code> <p>Initial observation after reset</p> Source code in <code>src\\python_motion_planning\\common\\env\\world\\base_world.py</code> Python<pre><code>def reset(self, seed: Optional[int] = None):\n    \"\"\"\n    Reset the environment.\n\n    Args:\n        seed: random seed\n\n    Returns:\n        observation: Initial observation after reset\n    \"\"\"\n    super().reset(seed=seed)\n    self.step_count = 0\n    # optionally randomize initial states or rely on robots' initial pos/vel\n    # return dict of observations keyed by robot index\n    obs = {}\n    for rid, robot in self.robots.items():\n        obs[rid] = robot.get_observation(self)\n    return obs, {}\n</code></pre>"},{"location":"api/common/env/world/base_world/BaseWorld.html#src.python_motion_planning.common.env.world.base_world.BaseWorld.step","title":"<code>step(actions)</code>","text":"<p>Execute one time step in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>Dict[int, ndarray]</code> <p>dict mapping robot_index -&gt; acceleration ndarray (dim,)</p> required <p>Returns:</p> Name Type Description <code>obs_dict</code> <p>dict mapping robot_index -&gt; observation ndarray (dim,)</p> <code>reward_dict</code> <p>dict mapping robot_index -&gt; reward scalar</p> <code>done_dict</code> <p>dict mapping robot_index -&gt; bool</p> <code>info</code> <p>dict</p> Source code in <code>src\\python_motion_planning\\common\\env\\world\\base_world.py</code> Python<pre><code>def step(self, actions: Dict[int, np.ndarray]):\n    \"\"\"\n    Execute one time step in the environment.\n\n    Args:\n        actions: dict mapping robot_index -&gt; acceleration ndarray (dim,)\n\n    Returns:\n        obs_dict: dict mapping robot_index -&gt; observation ndarray (dim,)\n        reward_dict: dict mapping robot_index -&gt; reward scalar\n        done_dict: dict mapping robot_index -&gt; bool\n        info: dict\n    \"\"\"\n    self.step_count += 1\n\n    obs = {rid: robot.get_observation(self) for rid, robot in self.robots.items()}\n    # no rewards by default; you can extend\n    rewards = {rid: 0.0 for rid in self.robots}\n    dones = {rid: False for rid in self.robots}\n    terminated = False\n    truncated = self.step_count &gt;= self.max_episode_steps\n    info = {}\n    return obs, rewards, dones, {\"terminated\": terminated, \"truncated\": truncated, **info}\n</code></pre>"},{"location":"api/common/env/world/toy_simulator/ToySimulator.html","title":"ToySimulator","text":""},{"location":"api/common/env/world/toy_simulator/ToySimulator.html#src.python_motion_planning.common.env.world.toy_simulator.ToySimulator","title":"<code>src.python_motion_planning.common.env.world.toy_simulator.ToySimulator</code>","text":"<p>               Bases: <code>BaseWorld</code></p> <p>Toy Simulator that supports multi-robot navigation in N-dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>dimension of the world (required &gt;= 2)</p> <code>2</code> <code>dt</code> <code>float</code> <p>the time step size</p> <code>0.1</code> <code>obstacle_grid</code> <code>Grid</code> <p>obstacle grid</p> <code>Grid()</code> <code>friction</code> <code>float</code> <p>the linear friction coefficient</p> <code>0.015</code> <code>restitution</code> <code>float</code> <p>the boundary/collision restitution coefficient [0,1]</p> <code>0.3</code> <code>noise</code> <code>float</code> <p>coefficient of random noise (normal distribution) acceleration proportional to speed exerted to robot [0,1]</p> <code>0.01</code> <code>max_episode_steps</code> <code>int</code> <p>the maximum number of steps per episode</p> <code>1000</code> <code>robot_collisions</code> <code>bool</code> <p>whether to resolve robot collisions</p> <code>True</code> <code>boundary_collisions</code> <code>bool</code> <p>whether to resolve boundary collisions</p> <code>True</code> Source code in <code>src\\python_motion_planning\\common\\env\\world\\toy_simulator.py</code> Python<pre><code>class ToySimulator(BaseWorld):\n    \"\"\"\n    Toy Simulator that supports multi-robot navigation in N-dimensions.\n\n    Args:\n        dim: dimension of the world (required &gt;= 2)\n        dt: the time step size\n        obstacle_grid: obstacle grid\n        friction: the linear friction coefficient\n        restitution: the boundary/collision restitution coefficient [0,1]\n        noise: coefficient of random noise (normal distribution) acceleration proportional to speed exerted to robot [0,1]\n        max_episode_steps: the maximum number of steps per episode\n        robot_collisions: whether to resolve robot collisions\n        boundary_collisions: whether to resolve boundary collisions\n    \"\"\"\n    def __init__(self, dim: int = 2,\n                 dt: float = 0.1,\n                 obstacle_grid: Grid = Grid(),\n                 friction: float = 0.015,\n                 restitution: float = 0.3,\n                 noise: float = 0.01,\n                 max_episode_steps: int = 1000,\n                 robot_collisions: bool = True,\n                 boundary_collisions: bool = True):\n        super().__init__()\n        self.dim = dim\n        self.dt = float(dt)\n        self.obstacle_grid = obstacle_grid\n        self.friction = float(friction)\n        self.restitution = float(restitution)\n        self.noise = float(noise)\n        self.max_episode_steps = int(max_episode_steps)\n        self.robot_collisions = robot_collisions\n        self.boundary_collisions = boundary_collisions\n        self.step_count = 0\n\n    @property\n    def time(self) -&gt; float:\n        \"\"\"\n        Returns the current accumulated time.\n        \"\"\"\n        return self.step_count * self.dt\n\n    def step(self, actions: Dict[int, np.ndarray]):\n        \"\"\"\n        Execute one time step in the environment.\n\n        Args:\n            actions: dict mapping robot_index -&gt; acceleration ndarray (dim,)\n                1) clip to robot action bounds\n                2) apply environment forces (friction) and integrate via semi-implicit Euler\n                3) handle collisions (robot-robot, robot-boundary)\n\n        Returns:\n            obs_dict: dict mapping robot_index -&gt; observation ndarray (dim,)\n            reward_dict: dict mapping robot_index -&gt; reward scalar\n            done_dict: dict mapping robot_index -&gt; bool\n            info: dict\n        \"\"\"\n        self.step_count += 1\n        # assign actions (accelerations) to robots\n        for rid, robot in self.robots.items():\n            act = actions.get(rid, np.zeros_like(robot.acc))    # robot frame\n            act = robot.clip_action(np.array(act, dtype=float))\n            robot.acc = FrameTransformer.vel_robot_to_world(self.dim, act, robot.orient)    # world frame\n\n        # apply environment forces -&gt; compute net acceleration: robot_net_acc = robot.acc + robot_env_acc (friction)\n        for rid, robot in self.robots.items():\n            # friction as linear damping: a_fric = -friction * v / mass\n            env_acc = self.calculate_frictional_acc(robot) + self.generate_env_noise_acc(robot)\n            robot.step(env_acc, self.dt)\n\n        # collisions: pairwise robot-robot elastic collisions and boundary collisions\n        if self.robot_collisions:\n            self._resolve_robot_collisions()\n        if self.boundary_collisions:\n            self._resolve_boundary_collisions()\n\n        # restrict the position within the grid map\n        for rid, robot in self.robots.items():\n            for d in range(robot.dim):\n                robot.pos[d] = min(max(robot.pos[d], self.obstacle_grid.bounds[d, 0]), self.obstacle_grid.bounds[d, 1])\n\n        obs = {rid: robot.get_observation(self) for rid, robot in self.robots.items()}\n        rewards = {rid: 0.0 for rid in self.robots}\n        dones = {rid: False for rid in self.robots}\n        terminated = False\n        truncated = self.step_count &gt;= self.max_episode_steps\n        info = {}\n        return obs, rewards, dones, {\"terminated\": terminated, \"truncated\": truncated, **info}\n\n    def calculate_frictional_acc(self, robot: BaseRobot) -&gt; np.ndarray:\n        if np.linalg.norm(robot.vel) &lt; 1e-6:\n            return np.zeros(robot.pose_dim)\n        robot_vel_direction = robot.vel / np.linalg.norm(robot.vel)\n        fri_acc = -self.friction * robot_vel_direction * 9.8    # 9.8 is gravitational acceleration\n        if np.linalg.norm(fri_acc * self.dt) &gt; np.linalg.norm(robot.vel):\n            fri_acc = -robot.vel / self.dt\n        return fri_acc\n\n    def generate_env_noise_acc(self, robot: BaseRobot) -&gt; np.ndarray:\n        if np.linalg.norm(robot.vel) &lt; 1e-6:\n            return np.zeros(robot.pose_dim)\n        std = np.abs(robot.vel) * self.noise + 1e-10\n        noise_acc = np.random.normal(loc=0.0, scale=std, size=robot.vel.shape)\n        return noise_acc\n\n    def _resolve_robot_collisions(self):\n        \"\"\"\n        Resolve CircularRobot-CircularRobot collisions.\n        \"\"\"\n        rids = list(self.robots.keys())\n        n = len(rids)\n        for i_ in range(n):\n            for j_ in range(i_ + 1, n):\n                i = rids[i_]\n                j = rids[j_]\n                a = self.robots[i]\n                b = self.robots[j]\n                delta = b.pos - a.pos\n                dist = np.linalg.norm(delta)\n                min_dist = a.radius + b.radius\n                if dist &lt; min_dist:\n                    if dist &lt; 1e-8:\n                        # numeric edge-case: jitter them slightly\n                        delta = np.random.randn(self.dim) * 1e-6\n                        dist = np.linalg.norm(delta)\n\n                    # push them apart and compute elastic collision impulse\n                    # normal vector\n                    nvec = delta / dist\n                    # relative velocity along normal\n                    rel_lin_vel = np.dot(b.lin_vel - a.lin_vel, nvec)\n                    # compute impulse scalar (elastic) with restitution\n                    e = self.restitution\n                    j_impulse = -(1 + e) * rel_lin_vel / (1 / a.mass + 1 / b.mass)\n                    if j_impulse &lt; 0:\n                        # apply impulse\n                        a.lin_vel -= (j_impulse / a.mass) * nvec\n                        b.lin_vel += (j_impulse / b.mass) * nvec\n                    # positional correction (simple)\n                    overlap = min_dist - dist\n                    corr = nvec * (overlap / 2.0 + 1e-6)\n                    a.pos = a.pos - corr\n                    b.pos = b.pos + corr\n\n    def _resolve_boundary_collisions(self):\n        \"\"\"\n        Resolve robot-boundary collisions.\n        \"\"\"\n        grid = self.obstacle_grid.type_map\n        cell_size = self.obstacle_grid.resolution\n        for rid, robot in self.robots.items():\n            min_pos = tuple(robot.pos[d] - robot.radius for d in range(self.dim))\n            max_pos = tuple(robot.pos[d] + robot.radius for d in range(self.dim))\n            min_idx = self.obstacle_grid.world_to_map(tuple(min_pos[d] for d in range(self.dim)))\n            min_idx = tuple(max(0, min_idx[d]) for d in range(self.dim))\n            max_idx = self.obstacle_grid.world_to_map(tuple(max_pos[d] for d in range(self.dim)))\n            max_idx = tuple(min(grid.shape[d] - 1, max_idx[d]) for d in range(self.dim))\n\n            for i in range(min_idx[0], max_idx[0] + 1):\n                for j in range(min_idx[1], max_idx[1] + 1):\n                    if grid[i, j] == TYPES.OBSTACLE:\n                        cell_center = self.obstacle_grid.map_to_world((i, j))\n                        cell_min = tuple(cell_center[d] - cell_size * 0.5 for d in range(self.dim))\n                        cell_max = tuple(cell_center[d] + cell_size * 0.5 for d in range(self.dim))\n\n                        # closest point in cell\n                        closest_x = max(cell_min[0], min(robot.pos[0], cell_max[0]))\n                        closest_y = max(cell_min[1], min(robot.pos[1], cell_max[1]))\n\n                        dx = robot.pos[0] - closest_x\n                        dy = robot.pos[1] - closest_y\n                        dist_sq = dx*dx + dy*dy\n\n                        if dist_sq &lt; robot.radius * robot.radius:\n                            dist = dist_sq**0.5 if dist_sq &gt; 1e-8 else 1e-8\n                            # normal vector\n                            nx, ny = dx / dist, dy / dist\n                            # positional correction (simple)\n                            overlap = robot.radius - dist\n                            robot.pos = np.array([robot.pos[0] + nx * overlap,\n                                         robot.pos[1] + ny * overlap])\n                            # velocity reflection\n                            vn = robot.lin_vel[0] * nx + robot.lin_vel[1] * ny\n                            if vn &lt; 0:  # reflect only if moving towards the cell\n                                robot.lin_vel = np.array([robot.lin_vel[0] - (1 + self.restitution) * vn * nx,\n                                            robot.lin_vel[1] - (1 + self.restitution) * vn * ny])\n</code></pre>"},{"location":"api/common/env/world/toy_simulator/ToySimulator.html#src.python_motion_planning.common.env.world.toy_simulator.ToySimulator.time","title":"<code>time: float</code>  <code>property</code>","text":"<p>Returns the current accumulated time.</p>"},{"location":"api/common/env/world/toy_simulator/ToySimulator.html#src.python_motion_planning.common.env.world.toy_simulator.ToySimulator.step","title":"<code>step(actions)</code>","text":"<p>Execute one time step in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>Dict[int, ndarray]</code> <p>dict mapping robot_index -&gt; acceleration ndarray (dim,) 1) clip to robot action bounds 2) apply environment forces (friction) and integrate via semi-implicit Euler 3) handle collisions (robot-robot, robot-boundary)</p> required <p>Returns:</p> Name Type Description <code>obs_dict</code> <p>dict mapping robot_index -&gt; observation ndarray (dim,)</p> <code>reward_dict</code> <p>dict mapping robot_index -&gt; reward scalar</p> <code>done_dict</code> <p>dict mapping robot_index -&gt; bool</p> <code>info</code> <p>dict</p> Source code in <code>src\\python_motion_planning\\common\\env\\world\\toy_simulator.py</code> Python<pre><code>def step(self, actions: Dict[int, np.ndarray]):\n    \"\"\"\n    Execute one time step in the environment.\n\n    Args:\n        actions: dict mapping robot_index -&gt; acceleration ndarray (dim,)\n            1) clip to robot action bounds\n            2) apply environment forces (friction) and integrate via semi-implicit Euler\n            3) handle collisions (robot-robot, robot-boundary)\n\n    Returns:\n        obs_dict: dict mapping robot_index -&gt; observation ndarray (dim,)\n        reward_dict: dict mapping robot_index -&gt; reward scalar\n        done_dict: dict mapping robot_index -&gt; bool\n        info: dict\n    \"\"\"\n    self.step_count += 1\n    # assign actions (accelerations) to robots\n    for rid, robot in self.robots.items():\n        act = actions.get(rid, np.zeros_like(robot.acc))    # robot frame\n        act = robot.clip_action(np.array(act, dtype=float))\n        robot.acc = FrameTransformer.vel_robot_to_world(self.dim, act, robot.orient)    # world frame\n\n    # apply environment forces -&gt; compute net acceleration: robot_net_acc = robot.acc + robot_env_acc (friction)\n    for rid, robot in self.robots.items():\n        # friction as linear damping: a_fric = -friction * v / mass\n        env_acc = self.calculate_frictional_acc(robot) + self.generate_env_noise_acc(robot)\n        robot.step(env_acc, self.dt)\n\n    # collisions: pairwise robot-robot elastic collisions and boundary collisions\n    if self.robot_collisions:\n        self._resolve_robot_collisions()\n    if self.boundary_collisions:\n        self._resolve_boundary_collisions()\n\n    # restrict the position within the grid map\n    for rid, robot in self.robots.items():\n        for d in range(robot.dim):\n            robot.pos[d] = min(max(robot.pos[d], self.obstacle_grid.bounds[d, 0]), self.obstacle_grid.bounds[d, 1])\n\n    obs = {rid: robot.get_observation(self) for rid, robot in self.robots.items()}\n    rewards = {rid: 0.0 for rid in self.robots}\n    dones = {rid: False for rid in self.robots}\n    terminated = False\n    truncated = self.step_count &gt;= self.max_episode_steps\n    info = {}\n    return obs, rewards, dones, {\"terminated\": terminated, \"truncated\": truncated, **info}\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html","title":"FrameTransformer","text":""},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer","title":"<code>src.python_motion_planning.common.utils.frame_transformer.FrameTransformer</code>","text":"<p>Class for transforming between world and robot frames.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>class FrameTransformer:\n    \"\"\"\n    Class for transforming between world and robot frames.\n    \"\"\"\n\n    @staticmethod\n    def lin_vel_world_to_robot(dim: int, lin_vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform linear velocity from world frame to robot frame.\n\n        Args:\n            dim (int): Space dimension.\n            lin_vel (np.ndarray): Linear velocity in world frame [vx, vy] (2D) or [vx, vy, vz] (3D).\n            orient (np.ndarray): Orientation of the robot.\n\n        Returns:\n            np.ndarray: Linear velocity in robot frame.\n        \"\"\"\n        if dim == 2:\n            theta = orient[0]\n            c, s = np.cos(theta), np.sin(theta)\n            R = np.array([[c, s],\n                          [-s, c]])\n            return R @ lin_vel[:2]\n        elif dim == 3:\n            # TODO: rotation with quaternion\n            raise NotImplementedError(\"3D velocity transform is not implemented yet.\")\n        else:\n            raise NotImplementedError(\"Only 2D and 3D cases are supported.\")\n\n    @staticmethod\n    def vel_world_to_robot(dim: int, vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform velocity from world frame to robot frame.\n\n        Args:\n            dim (int): Space dimension.\n            vel (np.ndarray): Velocity (linear and angular) in world frame.\n            orient (np.ndarray): Orientation of the robot.\n\n        Returns:\n            np.ndarray: Velocity in robot frame.\n        \"\"\"\n        lin_vel_world = vel[:dim]\n        lin_vel_robot = FrameTransformer.lin_vel_world_to_robot(dim, lin_vel_world, orient)\n        return np.concatenate([lin_vel_robot, vel[dim:]])\n\n    @staticmethod\n    def lin_vel_robot_to_world(dim: int, lin_vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform linear velocity from robot frame to world frame.\n\n        Args:\n            dim (int): Space dimension.\n            lin_vel (np.ndarray): Linear velocity in robot frame.\n            orient (np.ndarray): Orientation of the robot.\n\n        Returns:\n            np.ndarray: Linear velocity in world frame.\n        \"\"\"\n        if dim == 2:\n            theta = orient[0]\n            c, s = np.cos(theta), np.sin(theta)\n            R = np.array([[c, -s],\n                          [s,  c]])\n            return R @ lin_vel[:2]\n        elif dim == 3:\n            # TODO: rotation with quaternion\n            raise NotImplementedError(\"3D velocity transform is not implemented yet.\")\n        else:\n            raise NotImplementedError(\"Only 2D and 3D cases are supported.\")\n\n    @staticmethod\n    def vel_robot_to_world(dim: int, vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform velocity from robot frame to world frame.\n\n        Args:\n            dim (int): Space dimension.\n            vel (np.ndarray): Velocity (linear and angular) in robot frame.\n            orient (np.ndarray): Orientation of the robot.\n\n        Returns:\n            np.ndarray: Velocity in world frame.\n        \"\"\"\n        lin_vel_robot = vel[:dim]\n        lin_vel_world = FrameTransformer.lin_vel_robot_to_world(dim, lin_vel_robot, orient)\n        return np.concatenate([lin_vel_world, vel[dim:]])\n\n    @staticmethod\n    def pos_world_to_robot(dim: int, pos_world: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform a pos from world frame to robot frame.\n\n        Args:\n            dim (int): Space dimension.\n            pos_world (np.ndarray): Pos coordinates in world frame.\n            robot_pose (np.ndarray): Robot pose in world frame.\n\n        Returns:\n            np.ndarray: Pos coordinates in robot frame.\n        \"\"\"\n        if dim != 2:\n            raise NotImplementedError(\"Only 2D pos transform is implemented.\")\n\n        # pose in world frame\n        rx, ry, theta = robot_pose\n        c, s = np.cos(theta), np.sin(theta)\n\n        # translate to the origin\n        tx = pos_world[0] - rx\n        ty = pos_world[1] - ry\n\n        # rotate (use inverse rotation matrix)\n        pos_robot = np.array([\n            c * tx + s * ty,\n            -s * tx + c * ty\n        ])\n\n        return pos_robot\n\n    @staticmethod\n    def pose_world_to_robot(dim: int, pose_world: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform a pose (position and orientation) from world frame to robot frame.\n\n        Args:\n            dim (int): Space dimension.\n            pose_world (np.ndarray): Pose in world frame.\n            robot_pose (np.ndarray): Robot pose in world frame.\n\n        Returns:\n            np.ndarray: Pose in robot frame.\n        \"\"\"\n        if dim != 2:\n            raise NotImplementedError(\"Only 2D pose transform is implemented.\")\n\n        # transform position\n        position_robot = FrameTransformer.pos_world_to_robot(\n            dim, pose_world[:2], robot_pose\n        )\n\n        # transform orientation\n        orientation_robot = pose_world[2] - robot_pose[2]\n        orientation_robot = Geometry.regularize_orient(orientation_robot)\n\n        return np.concatenate([position_robot, [orientation_robot]])\n\n    @staticmethod\n    def pos_robot_to_world(dim: int, pos_robot: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform a pos from robot frame to world frame.\n\n        Args:\n            dim (int): Space dimension.\n            pos_robot (np.ndarray): Pos coordinates in robot frame.\n            robot_pose (np.ndarray): Robot pose in world frame.\n\n        Returns:\n            np.ndarray: Pos coordinates in world frame.\n        \"\"\"\n        if dim != 2:\n            raise NotImplementedError(\"Only 2D pos transform is implemented.\")\n\n        # pose in world frame\n        rx, ry, theta = robot_pose\n        c, s = np.cos(theta), np.sin(theta)\n\n        # rotate to the origin\n        tx = c * pos_robot[0] - s * pos_robot[1]\n        ty = s * pos_robot[0] + c * pos_robot[1]\n\n        # translate\n        pos_world = np.array([\n            tx + rx,\n            ty + ry\n        ])\n\n        return pos_world\n    @staticmethod\n    def pose_robot_to_world(dim: int, pose_robot: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform a pose (position and orientation) from robot frame to world frame.\n\n        Args:\n            dim (int): Space dimension.\n            pose_robot (np.ndarray): Pose in robot frame.\n            robot_pose (np.ndarray): Robot pose in world frame.\n\n        Returns:\n            np.ndarray: Pose in world frame.\n        \"\"\"\n        if dim != 2:\n            raise NotImplementedError(\"Only 2D pose transform is implemented.\")\n\n        # transform position\n        position_world = FrameTransformer.pos_robot_to_world(\n            dim, pose_robot[:2], robot_pose\n        )\n\n        # transform orientation\n        orientation_world = pose_robot[2] + robot_pose[2]\n        orientation_world = Geometry.regularize_orient(orientation_world)\n\n        return np.concatenate([position_world, [orientation_world]])\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.lin_vel_robot_to_world","title":"<code>lin_vel_robot_to_world(dim, lin_vel, orient)</code>  <code>staticmethod</code>","text":"<p>Transform linear velocity from robot frame to world frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>lin_vel</code> <code>ndarray</code> <p>Linear velocity in robot frame.</p> required <code>orient</code> <code>ndarray</code> <p>Orientation of the robot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Linear velocity in world frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef lin_vel_robot_to_world(dim: int, lin_vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform linear velocity from robot frame to world frame.\n\n    Args:\n        dim (int): Space dimension.\n        lin_vel (np.ndarray): Linear velocity in robot frame.\n        orient (np.ndarray): Orientation of the robot.\n\n    Returns:\n        np.ndarray: Linear velocity in world frame.\n    \"\"\"\n    if dim == 2:\n        theta = orient[0]\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s],\n                      [s,  c]])\n        return R @ lin_vel[:2]\n    elif dim == 3:\n        # TODO: rotation with quaternion\n        raise NotImplementedError(\"3D velocity transform is not implemented yet.\")\n    else:\n        raise NotImplementedError(\"Only 2D and 3D cases are supported.\")\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.lin_vel_world_to_robot","title":"<code>lin_vel_world_to_robot(dim, lin_vel, orient)</code>  <code>staticmethod</code>","text":"<p>Transform linear velocity from world frame to robot frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>lin_vel</code> <code>ndarray</code> <p>Linear velocity in world frame [vx, vy] (2D) or [vx, vy, vz] (3D).</p> required <code>orient</code> <code>ndarray</code> <p>Orientation of the robot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Linear velocity in robot frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef lin_vel_world_to_robot(dim: int, lin_vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform linear velocity from world frame to robot frame.\n\n    Args:\n        dim (int): Space dimension.\n        lin_vel (np.ndarray): Linear velocity in world frame [vx, vy] (2D) or [vx, vy, vz] (3D).\n        orient (np.ndarray): Orientation of the robot.\n\n    Returns:\n        np.ndarray: Linear velocity in robot frame.\n    \"\"\"\n    if dim == 2:\n        theta = orient[0]\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, s],\n                      [-s, c]])\n        return R @ lin_vel[:2]\n    elif dim == 3:\n        # TODO: rotation with quaternion\n        raise NotImplementedError(\"3D velocity transform is not implemented yet.\")\n    else:\n        raise NotImplementedError(\"Only 2D and 3D cases are supported.\")\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.pos_robot_to_world","title":"<code>pos_robot_to_world(dim, pos_robot, robot_pose)</code>  <code>staticmethod</code>","text":"<p>Transform a pos from robot frame to world frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>pos_robot</code> <code>ndarray</code> <p>Pos coordinates in robot frame.</p> required <code>robot_pose</code> <code>ndarray</code> <p>Robot pose in world frame.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Pos coordinates in world frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef pos_robot_to_world(dim: int, pos_robot: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform a pos from robot frame to world frame.\n\n    Args:\n        dim (int): Space dimension.\n        pos_robot (np.ndarray): Pos coordinates in robot frame.\n        robot_pose (np.ndarray): Robot pose in world frame.\n\n    Returns:\n        np.ndarray: Pos coordinates in world frame.\n    \"\"\"\n    if dim != 2:\n        raise NotImplementedError(\"Only 2D pos transform is implemented.\")\n\n    # pose in world frame\n    rx, ry, theta = robot_pose\n    c, s = np.cos(theta), np.sin(theta)\n\n    # rotate to the origin\n    tx = c * pos_robot[0] - s * pos_robot[1]\n    ty = s * pos_robot[0] + c * pos_robot[1]\n\n    # translate\n    pos_world = np.array([\n        tx + rx,\n        ty + ry\n    ])\n\n    return pos_world\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.pos_world_to_robot","title":"<code>pos_world_to_robot(dim, pos_world, robot_pose)</code>  <code>staticmethod</code>","text":"<p>Transform a pos from world frame to robot frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>pos_world</code> <code>ndarray</code> <p>Pos coordinates in world frame.</p> required <code>robot_pose</code> <code>ndarray</code> <p>Robot pose in world frame.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Pos coordinates in robot frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef pos_world_to_robot(dim: int, pos_world: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform a pos from world frame to robot frame.\n\n    Args:\n        dim (int): Space dimension.\n        pos_world (np.ndarray): Pos coordinates in world frame.\n        robot_pose (np.ndarray): Robot pose in world frame.\n\n    Returns:\n        np.ndarray: Pos coordinates in robot frame.\n    \"\"\"\n    if dim != 2:\n        raise NotImplementedError(\"Only 2D pos transform is implemented.\")\n\n    # pose in world frame\n    rx, ry, theta = robot_pose\n    c, s = np.cos(theta), np.sin(theta)\n\n    # translate to the origin\n    tx = pos_world[0] - rx\n    ty = pos_world[1] - ry\n\n    # rotate (use inverse rotation matrix)\n    pos_robot = np.array([\n        c * tx + s * ty,\n        -s * tx + c * ty\n    ])\n\n    return pos_robot\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.pose_robot_to_world","title":"<code>pose_robot_to_world(dim, pose_robot, robot_pose)</code>  <code>staticmethod</code>","text":"<p>Transform a pose (position and orientation) from robot frame to world frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>pose_robot</code> <code>ndarray</code> <p>Pose in robot frame.</p> required <code>robot_pose</code> <code>ndarray</code> <p>Robot pose in world frame.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Pose in world frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef pose_robot_to_world(dim: int, pose_robot: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform a pose (position and orientation) from robot frame to world frame.\n\n    Args:\n        dim (int): Space dimension.\n        pose_robot (np.ndarray): Pose in robot frame.\n        robot_pose (np.ndarray): Robot pose in world frame.\n\n    Returns:\n        np.ndarray: Pose in world frame.\n    \"\"\"\n    if dim != 2:\n        raise NotImplementedError(\"Only 2D pose transform is implemented.\")\n\n    # transform position\n    position_world = FrameTransformer.pos_robot_to_world(\n        dim, pose_robot[:2], robot_pose\n    )\n\n    # transform orientation\n    orientation_world = pose_robot[2] + robot_pose[2]\n    orientation_world = Geometry.regularize_orient(orientation_world)\n\n    return np.concatenate([position_world, [orientation_world]])\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.pose_world_to_robot","title":"<code>pose_world_to_robot(dim, pose_world, robot_pose)</code>  <code>staticmethod</code>","text":"<p>Transform a pose (position and orientation) from world frame to robot frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>pose_world</code> <code>ndarray</code> <p>Pose in world frame.</p> required <code>robot_pose</code> <code>ndarray</code> <p>Robot pose in world frame.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Pose in robot frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef pose_world_to_robot(dim: int, pose_world: np.ndarray, robot_pose: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform a pose (position and orientation) from world frame to robot frame.\n\n    Args:\n        dim (int): Space dimension.\n        pose_world (np.ndarray): Pose in world frame.\n        robot_pose (np.ndarray): Robot pose in world frame.\n\n    Returns:\n        np.ndarray: Pose in robot frame.\n    \"\"\"\n    if dim != 2:\n        raise NotImplementedError(\"Only 2D pose transform is implemented.\")\n\n    # transform position\n    position_robot = FrameTransformer.pos_world_to_robot(\n        dim, pose_world[:2], robot_pose\n    )\n\n    # transform orientation\n    orientation_robot = pose_world[2] - robot_pose[2]\n    orientation_robot = Geometry.regularize_orient(orientation_robot)\n\n    return np.concatenate([position_robot, [orientation_robot]])\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.vel_robot_to_world","title":"<code>vel_robot_to_world(dim, vel, orient)</code>  <code>staticmethod</code>","text":"<p>Transform velocity from robot frame to world frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>vel</code> <code>ndarray</code> <p>Velocity (linear and angular) in robot frame.</p> required <code>orient</code> <code>ndarray</code> <p>Orientation of the robot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Velocity in world frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef vel_robot_to_world(dim: int, vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform velocity from robot frame to world frame.\n\n    Args:\n        dim (int): Space dimension.\n        vel (np.ndarray): Velocity (linear and angular) in robot frame.\n        orient (np.ndarray): Orientation of the robot.\n\n    Returns:\n        np.ndarray: Velocity in world frame.\n    \"\"\"\n    lin_vel_robot = vel[:dim]\n    lin_vel_world = FrameTransformer.lin_vel_robot_to_world(dim, lin_vel_robot, orient)\n    return np.concatenate([lin_vel_world, vel[dim:]])\n</code></pre>"},{"location":"api/common/utils/frame_transformer/FrameTransformer.html#src.python_motion_planning.common.utils.frame_transformer.FrameTransformer.vel_world_to_robot","title":"<code>vel_world_to_robot(dim, vel, orient)</code>  <code>staticmethod</code>","text":"<p>Transform velocity from world frame to robot frame.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Space dimension.</p> required <code>vel</code> <code>ndarray</code> <p>Velocity (linear and angular) in world frame.</p> required <code>orient</code> <code>ndarray</code> <p>Orientation of the robot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Velocity in robot frame.</p> Source code in <code>src\\python_motion_planning\\common\\utils\\frame_transformer.py</code> Python<pre><code>@staticmethod\ndef vel_world_to_robot(dim: int, vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform velocity from world frame to robot frame.\n\n    Args:\n        dim (int): Space dimension.\n        vel (np.ndarray): Velocity (linear and angular) in world frame.\n        orient (np.ndarray): Orientation of the robot.\n\n    Returns:\n        np.ndarray: Velocity in robot frame.\n    \"\"\"\n    lin_vel_world = vel[:dim]\n    lin_vel_robot = FrameTransformer.lin_vel_world_to_robot(dim, lin_vel_world, orient)\n    return np.concatenate([lin_vel_robot, vel[dim:]])\n</code></pre>"},{"location":"api/common/utils/geometry/Geometry.html","title":"Geometry","text":""},{"location":"api/common/utils/geometry/Geometry.html#src.python_motion_planning.common.utils.geometry.Geometry","title":"<code>src.python_motion_planning.common.utils.geometry.Geometry</code>","text":"<p>Geometry tools class</p> Source code in <code>src\\python_motion_planning\\common\\utils\\geometry.py</code> Python<pre><code>class Geometry:\n    \"\"\"\n    Geometry tools class\n    \"\"\"\n\n    @staticmethod\n    def dist(p1: tuple, p2: tuple, type: str = 'Euclidean') -&gt; float:\n        \"\"\"\n        Calculate the distance between two points\n\n        Args:\n            p1: First point\n            p2: Second point\n            type: Type of distance calculation, either 'Euclidean' or 'Manhattan'\n\n        Returns:\n            dist: Distance between the two points\n        \"\"\"\n        if len(p1) != len(p2):\n            raise ValueError(\"Dimension mismatch\")\n        if type == 'Euclidean':\n            return math.sqrt(sum((a - b)** 2 for a, b in zip(p1, p2)))\n        elif type == 'Manhattan':\n            return sum(abs(a - b) for a, b in zip(p1, p2))\n        else:\n            raise ValueError(\"Invalid distance type\")\n\n    # @staticmethod\n    # def angle(v1: tuple, v2: tuple) -&gt; float:\n    #     \"\"\"\n    #     Calculate the angle between two vectors\n\n    #     Args:\n    #         v1: First vector\n    #         v2: Second vector\n\n    #     Returns:\n    #         angle_rad: Angle in rad between the two vectors\n    #     \"\"\"\n    #     if len(v1) != len(v2):\n    #         raise ValueError(\"Dimension mismatch\")\n\n    #     dot_product = sum(a * b for a, b in zip(v1, v2))\n    #     v1_norm = math.sqrt(sum(a**2 for a in v1))\n    #     v2_norm = math.sqrt(sum(b**2 for b in v2))\n\n    #     if  v1_norm == 0 or v2_norm == 0:\n    #         raise ValueError(\"Zero vector cannot calculate angle\")\n\n    #     cos_theta = dot_product / (v1_norm * v2_norm)\n\n    #     cos_theta = min(1.0, max(-1.0, cos_theta))\n\n    #     angle_rad = math.acos(cos_theta)\n\n    #     return angle_rad\n\n    @staticmethod\n    def regularize_orient(orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Regularize orientation to be within (-pi, pi]\n        \"\"\"\n        return np.mod(orient + np.pi, 2 * np.pi) - np.pi\n\n    @staticmethod\n    def add_orient_to_2d_path(path: List[Tuple[float, float]]) -&gt; List[Tuple[float, float, float]]:\n        \"\"\"\n        Add orientation information to a 2D point path. Each point in the path has a third value representing the angle (in radians) between the current point and the next point.\n\n        Args:\n            path: a list of 2D points\n\n        Returns:\n            new_path: a list of 2D poses\n        \"\"\"\n        if len(path) &lt; 2:\n            return [(x, y, 0.0) for x, y in path]\n\n        path_with_orient = []\n        for i in range(len(path) - 1):\n            x1, y1 = path[i]\n            x2, y2 = path[i + 1]\n\n            dx = x2 - x1\n            dy = y2 - y1\n\n            orient = math.atan2(dy, dx)\n\n            path_with_orient.append((x1, y1, orient))\n\n        # last pose\n        last_x, last_y = path[-1]\n        path_with_orient.append((last_x, last_y, path_with_orient[-1][2]))\n\n        return path_with_orient\n</code></pre>"},{"location":"api/common/utils/geometry/Geometry.html#src.python_motion_planning.common.utils.geometry.Geometry.add_orient_to_2d_path","title":"<code>add_orient_to_2d_path(path)</code>  <code>staticmethod</code>","text":"<p>Add orientation information to a 2D point path. Each point in the path has a third value representing the angle (in radians) between the current point and the next point.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>List[Tuple[float, float]]</code> <p>a list of 2D points</p> required <p>Returns:</p> Name Type Description <code>new_path</code> <code>List[Tuple[float, float, float]]</code> <p>a list of 2D poses</p> Source code in <code>src\\python_motion_planning\\common\\utils\\geometry.py</code> Python<pre><code>@staticmethod\ndef add_orient_to_2d_path(path: List[Tuple[float, float]]) -&gt; List[Tuple[float, float, float]]:\n    \"\"\"\n    Add orientation information to a 2D point path. Each point in the path has a third value representing the angle (in radians) between the current point and the next point.\n\n    Args:\n        path: a list of 2D points\n\n    Returns:\n        new_path: a list of 2D poses\n    \"\"\"\n    if len(path) &lt; 2:\n        return [(x, y, 0.0) for x, y in path]\n\n    path_with_orient = []\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i + 1]\n\n        dx = x2 - x1\n        dy = y2 - y1\n\n        orient = math.atan2(dy, dx)\n\n        path_with_orient.append((x1, y1, orient))\n\n    # last pose\n    last_x, last_y = path[-1]\n    path_with_orient.append((last_x, last_y, path_with_orient[-1][2]))\n\n    return path_with_orient\n</code></pre>"},{"location":"api/common/utils/geometry/Geometry.html#src.python_motion_planning.common.utils.geometry.Geometry.dist","title":"<code>dist(p1, p2, type='Euclidean')</code>  <code>staticmethod</code>","text":"<p>Calculate the distance between two points</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>tuple</code> <p>First point</p> required <code>p2</code> <code>tuple</code> <p>Second point</p> required <code>type</code> <code>str</code> <p>Type of distance calculation, either 'Euclidean' or 'Manhattan'</p> <code>'Euclidean'</code> <p>Returns:</p> Name Type Description <code>dist</code> <code>float</code> <p>Distance between the two points</p> Source code in <code>src\\python_motion_planning\\common\\utils\\geometry.py</code> Python<pre><code>@staticmethod\ndef dist(p1: tuple, p2: tuple, type: str = 'Euclidean') -&gt; float:\n    \"\"\"\n    Calculate the distance between two points\n\n    Args:\n        p1: First point\n        p2: Second point\n        type: Type of distance calculation, either 'Euclidean' or 'Manhattan'\n\n    Returns:\n        dist: Distance between the two points\n    \"\"\"\n    if len(p1) != len(p2):\n        raise ValueError(\"Dimension mismatch\")\n    if type == 'Euclidean':\n        return math.sqrt(sum((a - b)** 2 for a, b in zip(p1, p2)))\n    elif type == 'Manhattan':\n        return sum(abs(a - b) for a, b in zip(p1, p2))\n    else:\n        raise ValueError(\"Invalid distance type\")\n</code></pre>"},{"location":"api/common/utils/geometry/Geometry.html#src.python_motion_planning.common.utils.geometry.Geometry.regularize_orient","title":"<code>regularize_orient(orient)</code>  <code>staticmethod</code>","text":"<p>Regularize orientation to be within (-pi, pi]</p> Source code in <code>src\\python_motion_planning\\common\\utils\\geometry.py</code> Python<pre><code>@staticmethod\ndef regularize_orient(orient: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Regularize orientation to be within (-pi, pi]\n    \"\"\"\n    return np.mod(orient + np.pi, 2 * np.pi) - np.pi\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html","title":"Visualizer","text":""},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer","title":"<code>src.python_motion_planning.common.visualizer.visualizer.Visualizer</code>","text":"<p>Simple visualizer for motion planning using matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>figname</code> <code>str</code> <p>Figure name (window title).</p> <code>''</code> <code>figsize</code> <code>tuple</code> <p>Figure size (width, height).</p> <code>(10, 8)</code> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>class Visualizer:\n    \"\"\"\n    Simple visualizer for motion planning using matplotlib.\n\n    Args:\n        figname: Figure name (window title).\n        figsize: Figure size (width, height).\n    \"\"\"\n    def __init__(self, figname: str = \"\", figsize: tuple = (10, 8)):\n        self.fig = plt.figure(figname, figsize=figsize)\n        self.ax = self.fig.add_subplot()\n        self.ani = None\n\n        # colors\n        self.cmap_dict = {\n            TYPES.FREE: \"#ffffff\",\n            TYPES.OBSTACLE: \"#000000\",\n            TYPES.START: \"#ff0000\",\n            TYPES.GOAL: \"#1155cc\",\n            TYPES.INFLATION: \"#ffccff\",\n            TYPES.EXPAND: \"#eeeeee\",\n            TYPES.CUSTOM: \"#bbbbbb\",\n        }\n        # self.norm = mcolors.BoundaryNorm(list(range(len(self.cmap_dict))), len(self.cmap_dict))\n\n        self.zorder = {\n            'grid_map': 10,\n            'voxels': 10,\n            'esdf': 20,\n            'expand_tree_edge': 30,\n            'expand_tree_node': 40,\n            'path_2d': 50,\n            'path_3d': 700,\n            'traj': 60,\n            'lookahead_pose_node': 70,\n            'lookahead_pose_orient': 80,\n            'pred_traj': 90,\n            'robot_circle': 100,\n            'robot_orient': 110,\n            'robot_text': 120,\n            'env_info_text': 10000\n        }\n\n        self.cmap = mcolors.ListedColormap([info for info in self.cmap_dict.values()])\n        self.norm = mcolors.BoundaryNorm([i for i in range(self.cmap.N + 1)], self.cmap.N)\n        self.grid_map = None\n        self.dim = None\n\n        self.trajs = {}\n\n    def __del__(self):\n        self.close()\n\n    def plot_grid_map(self, grid_map: Grid, equal: bool = False, alpha_3d: dict = {\n                            TYPES.FREE: 0.0,\n                            TYPES.OBSTACLE: 0.5,\n                            TYPES.START: 0.5,\n                            TYPES.GOAL: 0.5,\n                            TYPES.INFLATION: 0.0,\n                            TYPES.EXPAND: 0.1,\n                            TYPES.CUSTOM: 0.5,\n                        },\n                        show_esdf: bool = False, alpha_esdf: float = 0.5) -&gt; None:\n        '''\n        Plot grid map with static obstacles.\n\n        Args:\n            map: Grid map or its type map.\n            equal: Whether to set axis equal.\n            alpha_3d: Alpha of occupancy for 3d visualization.\n            show_esdf: Whether to show esdf.\n            alpha_esdf: Alpha of esdf.\n        '''\n        self.grid_map = grid_map\n        self.dim = grid_map.dim\n        if grid_map.dim == 2:\n            plt.imshow(\n                np.transpose(grid_map.type_map.array), \n                cmap=self.cmap, \n                norm=self.norm, \n                origin='lower', \n                interpolation='nearest', \n                extent=[*grid_map.bounds[0], *grid_map.bounds[1]],\n                zorder=self.zorder['grid_map'],\n                )\n\n            if show_esdf:   # draw esdf hotmap\n                plt.imshow(\n                    np.transpose(grid_map.esdf),\n                    cmap=\"jet\",\n                    origin=\"lower\",\n                    interpolation=\"nearest\",\n                    extent=[*grid_map.bounds[0], *grid_map.bounds[1]],\n                    alpha=alpha_esdf,\n                    zorder=self.zorder['esdf'],\n                )\n                plt.colorbar(label=\"ESDF distance\")\n\n            if equal: \n                plt.axis(\"equal\")\n\n        elif grid_map.dim == 3:\n            self.ax = self.fig.add_subplot(projection='3d')\n\n            data = grid_map.type_map.array\n            nx, ny, nz = data.shape\n\n            filled = np.zeros_like(data, dtype=bool)\n            colors = np.zeros(data.shape + (4,), dtype=float)  # RGBA\n\n            for key, color in self.cmap_dict.items():\n                mask = (data == key)\n                if alpha_3d[key] &lt; 1e-6:\n                    continue\n                filled |= mask\n                rgba = matplotlib.colors.to_rgba(color, alpha=alpha_3d[key])\n                colors[mask] = rgba\n\n            self.ax.voxels(filled, facecolors=colors, zorder=self.zorder['voxels'])\n\n            if show_esdf:\n                # TODO\n                raise NotImplementedError\n\n            self.ax.set_xlabel(\"X\")\n            self.ax.set_ylabel(\"Y\")\n            self.ax.set_zlabel(\"Z\")\n\n            # let voxels look not stretched\n            max_range = 0\n            for d in range(grid_map.dim):\n                max_range = max(max_range, grid_map.bounds[d, 1] - grid_map.bounds[d, 0])\n            self.ax.set_xlim(grid_map.bounds[0, 0], grid_map.bounds[0, 0] + max_range)\n            self.ax.set_ylim(grid_map.bounds[1, 0], grid_map.bounds[1, 0] + max_range)\n            self.ax.set_zlim(grid_map.bounds[2, 0], grid_map.bounds[2, 0] + max_range)\n\n            if equal:\n                self.ax.set_box_aspect([1,1,1])\n\n        else:\n            raise NotImplementedError(f\"Grid map with dim={grid_map.dim} not supported.\")\n\n    def plot_expand_tree(self, expand_tree: Dict[Union[Tuple[int, ...], Tuple[float, ...]], Node], \n                        node_color: str = \"C5\", \n                        edge_color: str = \"C6\", \n                        node_size: float = 5, \n                        linewidth: float = 1.0, \n                        node_alpha: float = 1.0,\n                        edge_alpha: float = 1.0,\n                        connect_to_parent: bool = True,\n                        map_frame: bool = True) -&gt; None:\n        \"\"\"\n        Visualize an expand tree (e.g. RRT).\n\n        Args:\n            expand_tree: Dict mapping coordinate tuple -&gt; Node (world frame).\n            node_color: Color of the nodes.\n            edge_color: Color of the edges (parent -&gt; child).\n            node_size: Size of node markers.\n            linewidth: Line width of edges.\n            connect_to_parent: Whether to draw parent-child connections.\n            map_frame: whether path is in map frame or not (world frame)\n        \"\"\"\n        if self.dim == 2:\n            for coord, node in expand_tree.items():\n                current = node.current\n                if map_frame:\n                    current = self.grid_map.map_to_world(current)\n\n                self.ax.scatter(current[0], current[1],\n                                c=node_color, s=node_size, zorder=self.zorder['expand_tree_node'], alpha=node_alpha)\n                if connect_to_parent and node.parent is not None:\n                    parent = node.parent\n                    if map_frame:\n                        parent = self.grid_map.map_to_world(parent)\n                    self.ax.plot([parent[0], current[0]],\n                                [parent[1], current[1]],\n                                color=edge_color, linewidth=linewidth, zorder=self.zorder['expand_tree_edge'], alpha=edge_alpha)\n\n        elif self.dim == 3:\n            for coord, node in expand_tree.items():\n                current = node.current\n                if map_frame:\n                    current = self.grid_map.map_to_world(current)\n\n                self.ax.scatter(current[0], current[1], current[2],\n                                c=node_color, s=node_size, zorder=self.zorder['expand_tree_node'], alpha=node_alpha)\n                if connect_to_parent and node.parent is not None:\n                    parent = node.parent\n                    if map_frame:\n                        parent = self.grid_map.map_to_world(parent)\n                    self.ax.plot([parent[0], current[0]],\n                                [parent[1], current[1]],\n                                [parent[2], current[2]],\n                                color=edge_color, linewidth=linewidth, zorder=self.zorder['expand_tree_edge'], alpha=edge_alpha)\n\n        else:\n            raise ValueError(\"Dimension must be 2 or 3\")\n\n\n    def plot_path(self, path: List[Union[Tuple[int, ...], Tuple[float, ...]]], \n                    style: str = \"-\", color: str = \"#13ae00\", label: str = None, \n                    linewidth: float = 3, marker: str = None, map_frame: bool = True) -&gt; None:\n        '''\n        Plot path-like information.\n        The meaning of parameters are similar to matplotlib.pyplot.plot (https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).\n\n        Args:\n            path: point list of path\n            style: style of path\n            color: color of path\n            label: label of path\n            linewidth: linewidth of path\n            marker: marker of path\n            map_frame: whether path is in map frame or not (world frame)\n        '''\n        if len(path) == 0:\n            return\n\n        if map_frame:\n            path = [self.grid_map.map_to_world(point) for point in path]\n\n        path = np.array(path)\n\n        if self.dim == 2:\n            self.ax.plot(path[:, 0], path[:, 1], style, lw=linewidth, color=color, label=label, marker=marker, zorder=self.zorder['path_2d'])\n        elif self.dim == 3:\n            self.ax.plot(path[:, 0], path[:, 1], path[:, 2], style, lw=linewidth, color=color, label=label, marker=marker, zorder=self.zorder['path_3d'])\n        else:\n            raise ValueError(\"Dimension not supported\")\n\n        if label:\n            self.ax.legend()\n\n    def plot_circular_robot(self, robot: CircularRobot, axis_equal: bool = True) -&gt; None:\n        \"\"\"\n        Plot a circular robot.\n\n        Args:\n            robot: CircularRobot object.\n            axis_equal: Whether to set equal aspect ratio for x and y axes.\n        \"\"\"\n        patch = plt.Circle(tuple(robot.pos), robot.radius, \n            color=robot.color, alpha=robot.alpha, fill=robot.fill, \n            linewidth=robot.linewidth, linestyle=robot.linestyle,\n            zorder=self.zorder['robot_circle'])\n        self.ax.add_patch(patch)\n\n        fontsize = robot.fontsize if robot.fontsize else robot.radius * 10\n        text = self.ax.text(*robot.pos, robot.text, color=robot.text_color, ha='center', va='center', \n                            fontsize=fontsize, zorder=self.zorder['robot_text'])\n\n        if robot.dim == 2:\n            theta = robot.orient[0]\n            dx = np.cos(theta) * robot.radius\n            dy = np.sin(theta) * robot.radius\n            orient_patch = self.ax.arrow(robot.pos[0], robot.pos[1], dx, dy,\n                                         head_width=0.1*robot.radius, head_length=0.2*robot.radius,\n                                         fc=robot.color, ec=robot.text_color, zorder=self.zorder['robot_orient'])\n            return patch, text, orient_patch\n        elif robot.dim == 3:\n            # TODO: quiver for 3D vector\n            return patch, text\n        else:\n            return patch, text\n\n    def render_toy_simulator(self, env: ToySimulator, controllers: Dict[str, BaseController],\n            steps: int = 1000, interval: int = None,\n            show_traj: bool = True, traj_kwargs: dict = {\"linestyle\": '-', \"alpha\": 0.7, \"linewidth\": 1.5},\n            show_env_info: bool = False, rtf_limit: float = 1.0, grid_kwargs: dict = {},\n            show_pred_traj: bool = True) -&gt; None:\n        \"\"\"\n        Render the toy simulator.\n\n        Args:\n            env: ToySimulator object.\n            controllers: Controllers for each robot.\n            steps: Number of steps to render.\n            interval: Interval between frames in milliseconds.\n            show_traj: Whether to show trajectories.\n            traj_kwargs: Keyword arguments for trajectories.\n            show_env_info: Whether to show environment information.\n            rtf_limit: Maximum real-time factor.\n            grid_kwargs: Keyword arguments for grid map.\n            show_pred_traj: Whether to show predicted trajectories (for DWA etc.).\n        \"\"\"\n\n        if interval is None:\n            interval = int(1000 * env.dt)\n\n        if traj_kwargs.get(\"color\") is None:\n            traj_color = {rid: robot.color for rid, robot in env.robots.items()}\n        else:\n            traj_color = {rid: traj_kwargs.get(\"color\") for rid, robot in env.robots.items()}\n\n        # \u5148\u753b\u9759\u6001\u7684\u5730\u56fe\u548c\u8def\u5f84\n        self.ax.clear()\n        self.plot_grid_map(env.obstacle_grid, **grid_kwargs)\n\n        self.trajs = {rid: {\n            \"poses\": [],\n            \"time\": []\n        } for rid in env.robots}\n\n        last_time = time.time()\n        if show_env_info:\n            env_info_text = self.ax.text(0.02, 0.95, \"\", transform=self.ax.transAxes, \n                                        ha=\"left\", va=\"top\", alpha=0.5, color=\"white\", zorder=self.zorder['env_info_text'])\n            env_info_text.set_path_effects([path_effects.withStroke(linewidth=2, foreground='black')])\n\n        prepare_frames = 5\n\n        def update(frame):\n            nonlocal last_time\n            nonlocal prepare_frames\n\n            patches = []\n            actions = {}\n\n            while prepare_frames &gt; 0:    # matplotlib has a bug\n                prepare_frames -= 1\n                return patches\n\n            for rid, robot in env.robots.items():\n                self.trajs[rid][\"poses\"].append(robot.pose.copy())\n                self.trajs[rid][\"time\"].append(env.time)\n\n                ob = robot.get_observation(env)\n                act, lookahead_pose = controllers[rid].get_action(ob)\n\n                if lookahead_pose is not None:\n                    lookahead_pose_patch = plt.Circle(lookahead_pose[:2], 0.2, color=robot.color, alpha=0.5, zorder=self.zorder['lookahead_pose_node'])\n                    self.ax.add_patch(lookahead_pose_patch)\n                    patches.append(lookahead_pose_patch)\n\n                    theta = lookahead_pose[2]\n                    dx = np.cos(theta) * robot.radius\n                    dy = np.sin(theta) * robot.radius\n                    orient_patch = self.ax.arrow(lookahead_pose[0], lookahead_pose[1], dx, dy,\n                                                width=0.2*robot.radius,\n                                                fc=robot.color, ec=robot.color, alpha=0.5, zorder=self.zorder['lookahead_pose_orient'])\n                    patches.append(orient_patch)\n\n                actions[rid] = act\n\n            for rid, robot in env.robots.items():\n                items = self.plot_circular_robot(robot)\n                for item in items:\n                    if item is not None:\n                        patches.append(item)\n\n            # draw trajectories\n            if show_traj:\n                for rid, traj in self.trajs.items():\n                    poses = traj[\"poses\"]\n                    if len(poses) &gt; 1:\n                        pose_x = [p[0] for p in poses]\n                        pose_y = [p[1] for p in poses]\n                        traj_line, = self.ax.plot(pose_x, pose_y, color=traj_color[rid], zorder=self.zorder['traj'], **traj_kwargs)\n                        patches.append(traj_line)\n\n            if show_pred_traj:\n                for rid, controller in controllers.items():\n                    pred_traj = controller.pred_traj\n                    if len(pred_traj) &gt; 1:\n                        pred_traj_x = [p[0] for p in pred_traj]\n                        pred_traj_y = [p[1] for p in pred_traj]\n                        pred_traj_line, = self.ax.plot(pred_traj_x, pred_traj_y, color=traj_color[rid], zorder=self.zorder['pred_traj'], **traj_kwargs)\n                        patches.append(pred_traj_line)\n\n            elapsed = time.time() - last_time\n            if rtf_limit and env.dt / elapsed &gt; rtf_limit:\n                time.sleep(env.dt / rtf_limit - elapsed)\n                elapsed = time.time() - last_time\n\n            if show_env_info:\n                step_count = env.step_count\n                sim_time = step_count * env.dt\n                rtf = env.dt / elapsed\n                env_info_text.set_text(f\"Step: {step_count}, Time: {sim_time:.3f}s, RTF: {rtf:.3f}\")\n                patches.append(env_info_text)\n\n            last_time = time.time()\n\n            if env.step_count &lt; steps:\n                obs, rewards, dones, info = env.step(actions)\n\n            return patches\n\n        self.ani = animation.FuncAnimation(\n            self.fig, update, frames=steps+prepare_frames, interval=interval, blit=True, repeat=False\n        )\n\n    def get_traj_info(self, rid: int, goal_pose: np.ndarray, goal_dist_tol: float, goal_orient_tol: float) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get trajectory information.\n\n        Args:\n            rid: Robot ID.\n            goal_pose: Goal pose.\n            goal_dist_tol: Distance tolerance for goal.\n            goal_orient_tol: Orientation tolerance for goal.\n        \"\"\"\n        traj = self.trajs[rid]\n\n        info = {\n            \"traj_length\": 0.0,\n            \"success\": False,\n            \"dist_success\": False, \n            \"oracle_success\": False,\n            \"oracle_dist_success\": False,\n            \"success_time\": None,\n            \"dist_success_time\": None,\n            \"oracle_success_time\": None,\n            \"oracle_dist_success_time\": None,\n        }\n\n        for i in range(len(traj[\"poses\"])):\n            pose = traj[\"poses\"][i]\n            time = traj[\"time\"][i]\n\n            pos = pose[:self.dim]\n            orient = pose[self.dim:]\n            goal_pos = goal_pose[:self.dim]\n            goal_orient = goal_pose[self.dim:]\n\n            if i &gt; 0:\n                info[\"traj_length\"] += np.linalg.norm(pos - traj[\"poses\"][i-1][:self.dim])\n\n            if np.linalg.norm(pos - goal_pos) &lt; goal_dist_tol:\n                if not info[\"oracle_dist_success\"]:\n                    info[\"oracle_dist_success\"] = True\n                    info[\"oracle_dist_success_time\"] = time\n\n                if not info[\"dist_success\"]:\n                    info[\"dist_success\"] = True\n                    info[\"dist_success_time\"] = time\n\n                if np.abs(Geometry.regularize_orient(orient - goal_orient)) &lt; goal_orient_tol:\n                    if not info[\"oracle_success\"]:\n                        info[\"oracle_success\"] = True\n                        info[\"oracle_success_time\"] = time  \n\n                    if not info[\"success\"]:\n                        info[\"success\"] = True\n                        info[\"success_time\"] = time\n\n                else:\n                    info[\"success\"] = False\n                    info[\"success_time\"] = None\n\n            else:\n                info[\"success\"] = False\n                info[\"success_time\"] = None\n                info[\"dist_success\"] = False\n                info[\"dist_success_time\"] = None\n\n        info[\"traj_length\"] = float(info[\"traj_length\"])\n        return info\n\n\n    def set_title(self, title: str) -&gt; None:\n        \"\"\"\n        Set title.\n\n        Args:\n            title: Title.\n        \"\"\"\n        plt.title(title)\n\n    def connect(self, name: str, func) -&gt; None:\n        \"\"\"\n        Connect event.\n\n        Args:\n            name: Event name.\n            func: Event function.\n        \"\"\"\n        self.fig.canvas.mpl_connect(name, func)\n\n    def clean(self):\n        \"\"\"\n        Clean plot.\n        \"\"\"\n        plt.cla()\n\n    def update(self):\n        \"\"\"\n        Update plot.\n        \"\"\"\n        self.fig.canvas.draw_idle()\n\n    def show(self):\n        \"\"\"\n        Show plot.\n        \"\"\"\n        plt.show()\n\n    def legend(self):\n        \"\"\"\n        Add legend.\n        \"\"\"\n        plt.legend()\n\n    def close(self):\n        \"\"\"\n        Close plot.\n        \"\"\"\n        plt.close()\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.clean","title":"<code>clean()</code>","text":"<p>Clean plot.</p> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def clean(self):\n    \"\"\"\n    Clean plot.\n    \"\"\"\n    plt.cla()\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.close","title":"<code>close()</code>","text":"<p>Close plot.</p> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def close(self):\n    \"\"\"\n    Close plot.\n    \"\"\"\n    plt.close()\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.connect","title":"<code>connect(name, func)</code>","text":"<p>Connect event.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name.</p> required <code>func</code> <p>Event function.</p> required Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def connect(self, name: str, func) -&gt; None:\n    \"\"\"\n    Connect event.\n\n    Args:\n        name: Event name.\n        func: Event function.\n    \"\"\"\n    self.fig.canvas.mpl_connect(name, func)\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.get_traj_info","title":"<code>get_traj_info(rid, goal_pose, goal_dist_tol, goal_orient_tol)</code>","text":"<p>Get trajectory information.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Robot ID.</p> required <code>goal_pose</code> <code>ndarray</code> <p>Goal pose.</p> required <code>goal_dist_tol</code> <code>float</code> <p>Distance tolerance for goal.</p> required <code>goal_orient_tol</code> <code>float</code> <p>Orientation tolerance for goal.</p> required Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def get_traj_info(self, rid: int, goal_pose: np.ndarray, goal_dist_tol: float, goal_orient_tol: float) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get trajectory information.\n\n    Args:\n        rid: Robot ID.\n        goal_pose: Goal pose.\n        goal_dist_tol: Distance tolerance for goal.\n        goal_orient_tol: Orientation tolerance for goal.\n    \"\"\"\n    traj = self.trajs[rid]\n\n    info = {\n        \"traj_length\": 0.0,\n        \"success\": False,\n        \"dist_success\": False, \n        \"oracle_success\": False,\n        \"oracle_dist_success\": False,\n        \"success_time\": None,\n        \"dist_success_time\": None,\n        \"oracle_success_time\": None,\n        \"oracle_dist_success_time\": None,\n    }\n\n    for i in range(len(traj[\"poses\"])):\n        pose = traj[\"poses\"][i]\n        time = traj[\"time\"][i]\n\n        pos = pose[:self.dim]\n        orient = pose[self.dim:]\n        goal_pos = goal_pose[:self.dim]\n        goal_orient = goal_pose[self.dim:]\n\n        if i &gt; 0:\n            info[\"traj_length\"] += np.linalg.norm(pos - traj[\"poses\"][i-1][:self.dim])\n\n        if np.linalg.norm(pos - goal_pos) &lt; goal_dist_tol:\n            if not info[\"oracle_dist_success\"]:\n                info[\"oracle_dist_success\"] = True\n                info[\"oracle_dist_success_time\"] = time\n\n            if not info[\"dist_success\"]:\n                info[\"dist_success\"] = True\n                info[\"dist_success_time\"] = time\n\n            if np.abs(Geometry.regularize_orient(orient - goal_orient)) &lt; goal_orient_tol:\n                if not info[\"oracle_success\"]:\n                    info[\"oracle_success\"] = True\n                    info[\"oracle_success_time\"] = time  \n\n                if not info[\"success\"]:\n                    info[\"success\"] = True\n                    info[\"success_time\"] = time\n\n            else:\n                info[\"success\"] = False\n                info[\"success_time\"] = None\n\n        else:\n            info[\"success\"] = False\n            info[\"success_time\"] = None\n            info[\"dist_success\"] = False\n            info[\"dist_success_time\"] = None\n\n    info[\"traj_length\"] = float(info[\"traj_length\"])\n    return info\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.legend","title":"<code>legend()</code>","text":"<p>Add legend.</p> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def legend(self):\n    \"\"\"\n    Add legend.\n    \"\"\"\n    plt.legend()\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.plot_circular_robot","title":"<code>plot_circular_robot(robot, axis_equal=True)</code>","text":"<p>Plot a circular robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>CircularRobot</code> <p>CircularRobot object.</p> required <code>axis_equal</code> <code>bool</code> <p>Whether to set equal aspect ratio for x and y axes.</p> <code>True</code> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def plot_circular_robot(self, robot: CircularRobot, axis_equal: bool = True) -&gt; None:\n    \"\"\"\n    Plot a circular robot.\n\n    Args:\n        robot: CircularRobot object.\n        axis_equal: Whether to set equal aspect ratio for x and y axes.\n    \"\"\"\n    patch = plt.Circle(tuple(robot.pos), robot.radius, \n        color=robot.color, alpha=robot.alpha, fill=robot.fill, \n        linewidth=robot.linewidth, linestyle=robot.linestyle,\n        zorder=self.zorder['robot_circle'])\n    self.ax.add_patch(patch)\n\n    fontsize = robot.fontsize if robot.fontsize else robot.radius * 10\n    text = self.ax.text(*robot.pos, robot.text, color=robot.text_color, ha='center', va='center', \n                        fontsize=fontsize, zorder=self.zorder['robot_text'])\n\n    if robot.dim == 2:\n        theta = robot.orient[0]\n        dx = np.cos(theta) * robot.radius\n        dy = np.sin(theta) * robot.radius\n        orient_patch = self.ax.arrow(robot.pos[0], robot.pos[1], dx, dy,\n                                     head_width=0.1*robot.radius, head_length=0.2*robot.radius,\n                                     fc=robot.color, ec=robot.text_color, zorder=self.zorder['robot_orient'])\n        return patch, text, orient_patch\n    elif robot.dim == 3:\n        # TODO: quiver for 3D vector\n        return patch, text\n    else:\n        return patch, text\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.plot_expand_tree","title":"<code>plot_expand_tree(expand_tree, node_color='C5', edge_color='C6', node_size=5, linewidth=1.0, node_alpha=1.0, edge_alpha=1.0, connect_to_parent=True, map_frame=True)</code>","text":"<p>Visualize an expand tree (e.g. RRT).</p> <p>Parameters:</p> Name Type Description Default <code>expand_tree</code> <code>Dict[Union[Tuple[int, ...], Tuple[float, ...]], Node]</code> <p>Dict mapping coordinate tuple -&gt; Node (world frame).</p> required <code>node_color</code> <code>str</code> <p>Color of the nodes.</p> <code>'C5'</code> <code>edge_color</code> <code>str</code> <p>Color of the edges (parent -&gt; child).</p> <code>'C6'</code> <code>node_size</code> <code>float</code> <p>Size of node markers.</p> <code>5</code> <code>linewidth</code> <code>float</code> <p>Line width of edges.</p> <code>1.0</code> <code>connect_to_parent</code> <code>bool</code> <p>Whether to draw parent-child connections.</p> <code>True</code> <code>map_frame</code> <code>bool</code> <p>whether path is in map frame or not (world frame)</p> <code>True</code> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def plot_expand_tree(self, expand_tree: Dict[Union[Tuple[int, ...], Tuple[float, ...]], Node], \n                    node_color: str = \"C5\", \n                    edge_color: str = \"C6\", \n                    node_size: float = 5, \n                    linewidth: float = 1.0, \n                    node_alpha: float = 1.0,\n                    edge_alpha: float = 1.0,\n                    connect_to_parent: bool = True,\n                    map_frame: bool = True) -&gt; None:\n    \"\"\"\n    Visualize an expand tree (e.g. RRT).\n\n    Args:\n        expand_tree: Dict mapping coordinate tuple -&gt; Node (world frame).\n        node_color: Color of the nodes.\n        edge_color: Color of the edges (parent -&gt; child).\n        node_size: Size of node markers.\n        linewidth: Line width of edges.\n        connect_to_parent: Whether to draw parent-child connections.\n        map_frame: whether path is in map frame or not (world frame)\n    \"\"\"\n    if self.dim == 2:\n        for coord, node in expand_tree.items():\n            current = node.current\n            if map_frame:\n                current = self.grid_map.map_to_world(current)\n\n            self.ax.scatter(current[0], current[1],\n                            c=node_color, s=node_size, zorder=self.zorder['expand_tree_node'], alpha=node_alpha)\n            if connect_to_parent and node.parent is not None:\n                parent = node.parent\n                if map_frame:\n                    parent = self.grid_map.map_to_world(parent)\n                self.ax.plot([parent[0], current[0]],\n                            [parent[1], current[1]],\n                            color=edge_color, linewidth=linewidth, zorder=self.zorder['expand_tree_edge'], alpha=edge_alpha)\n\n    elif self.dim == 3:\n        for coord, node in expand_tree.items():\n            current = node.current\n            if map_frame:\n                current = self.grid_map.map_to_world(current)\n\n            self.ax.scatter(current[0], current[1], current[2],\n                            c=node_color, s=node_size, zorder=self.zorder['expand_tree_node'], alpha=node_alpha)\n            if connect_to_parent and node.parent is not None:\n                parent = node.parent\n                if map_frame:\n                    parent = self.grid_map.map_to_world(parent)\n                self.ax.plot([parent[0], current[0]],\n                            [parent[1], current[1]],\n                            [parent[2], current[2]],\n                            color=edge_color, linewidth=linewidth, zorder=self.zorder['expand_tree_edge'], alpha=edge_alpha)\n\n    else:\n        raise ValueError(\"Dimension must be 2 or 3\")\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.plot_grid_map","title":"<code>plot_grid_map(grid_map, equal=False, alpha_3d={TYPES.FREE: 0.0, TYPES.OBSTACLE: 0.5, TYPES.START: 0.5, TYPES.GOAL: 0.5, TYPES.INFLATION: 0.0, TYPES.EXPAND: 0.1, TYPES.CUSTOM: 0.5}, show_esdf=False, alpha_esdf=0.5)</code>","text":"<p>Plot grid map with static obstacles.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <p>Grid map or its type map.</p> required <code>equal</code> <code>bool</code> <p>Whether to set axis equal.</p> <code>False</code> <code>alpha_3d</code> <code>dict</code> <p>Alpha of occupancy for 3d visualization.</p> <code>{FREE: 0.0, OBSTACLE: 0.5, START: 0.5, GOAL: 0.5, INFLATION: 0.0, EXPAND: 0.1, CUSTOM: 0.5}</code> <code>show_esdf</code> <code>bool</code> <p>Whether to show esdf.</p> <code>False</code> <code>alpha_esdf</code> <code>float</code> <p>Alpha of esdf.</p> <code>0.5</code> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def plot_grid_map(self, grid_map: Grid, equal: bool = False, alpha_3d: dict = {\n                        TYPES.FREE: 0.0,\n                        TYPES.OBSTACLE: 0.5,\n                        TYPES.START: 0.5,\n                        TYPES.GOAL: 0.5,\n                        TYPES.INFLATION: 0.0,\n                        TYPES.EXPAND: 0.1,\n                        TYPES.CUSTOM: 0.5,\n                    },\n                    show_esdf: bool = False, alpha_esdf: float = 0.5) -&gt; None:\n    '''\n    Plot grid map with static obstacles.\n\n    Args:\n        map: Grid map or its type map.\n        equal: Whether to set axis equal.\n        alpha_3d: Alpha of occupancy for 3d visualization.\n        show_esdf: Whether to show esdf.\n        alpha_esdf: Alpha of esdf.\n    '''\n    self.grid_map = grid_map\n    self.dim = grid_map.dim\n    if grid_map.dim == 2:\n        plt.imshow(\n            np.transpose(grid_map.type_map.array), \n            cmap=self.cmap, \n            norm=self.norm, \n            origin='lower', \n            interpolation='nearest', \n            extent=[*grid_map.bounds[0], *grid_map.bounds[1]],\n            zorder=self.zorder['grid_map'],\n            )\n\n        if show_esdf:   # draw esdf hotmap\n            plt.imshow(\n                np.transpose(grid_map.esdf),\n                cmap=\"jet\",\n                origin=\"lower\",\n                interpolation=\"nearest\",\n                extent=[*grid_map.bounds[0], *grid_map.bounds[1]],\n                alpha=alpha_esdf,\n                zorder=self.zorder['esdf'],\n            )\n            plt.colorbar(label=\"ESDF distance\")\n\n        if equal: \n            plt.axis(\"equal\")\n\n    elif grid_map.dim == 3:\n        self.ax = self.fig.add_subplot(projection='3d')\n\n        data = grid_map.type_map.array\n        nx, ny, nz = data.shape\n\n        filled = np.zeros_like(data, dtype=bool)\n        colors = np.zeros(data.shape + (4,), dtype=float)  # RGBA\n\n        for key, color in self.cmap_dict.items():\n            mask = (data == key)\n            if alpha_3d[key] &lt; 1e-6:\n                continue\n            filled |= mask\n            rgba = matplotlib.colors.to_rgba(color, alpha=alpha_3d[key])\n            colors[mask] = rgba\n\n        self.ax.voxels(filled, facecolors=colors, zorder=self.zorder['voxels'])\n\n        if show_esdf:\n            # TODO\n            raise NotImplementedError\n\n        self.ax.set_xlabel(\"X\")\n        self.ax.set_ylabel(\"Y\")\n        self.ax.set_zlabel(\"Z\")\n\n        # let voxels look not stretched\n        max_range = 0\n        for d in range(grid_map.dim):\n            max_range = max(max_range, grid_map.bounds[d, 1] - grid_map.bounds[d, 0])\n        self.ax.set_xlim(grid_map.bounds[0, 0], grid_map.bounds[0, 0] + max_range)\n        self.ax.set_ylim(grid_map.bounds[1, 0], grid_map.bounds[1, 0] + max_range)\n        self.ax.set_zlim(grid_map.bounds[2, 0], grid_map.bounds[2, 0] + max_range)\n\n        if equal:\n            self.ax.set_box_aspect([1,1,1])\n\n    else:\n        raise NotImplementedError(f\"Grid map with dim={grid_map.dim} not supported.\")\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.plot_path","title":"<code>plot_path(path, style='-', color='#13ae00', label=None, linewidth=3, marker=None, map_frame=True)</code>","text":"<p>Plot path-like information. The meaning of parameters are similar to matplotlib.pyplot.plot (https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>List[Union[Tuple[int, ...], Tuple[float, ...]]]</code> <p>point list of path</p> required <code>style</code> <code>str</code> <p>style of path</p> <code>'-'</code> <code>color</code> <code>str</code> <p>color of path</p> <code>'#13ae00'</code> <code>label</code> <code>str</code> <p>label of path</p> <code>None</code> <code>linewidth</code> <code>float</code> <p>linewidth of path</p> <code>3</code> <code>marker</code> <code>str</code> <p>marker of path</p> <code>None</code> <code>map_frame</code> <code>bool</code> <p>whether path is in map frame or not (world frame)</p> <code>True</code> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def plot_path(self, path: List[Union[Tuple[int, ...], Tuple[float, ...]]], \n                style: str = \"-\", color: str = \"#13ae00\", label: str = None, \n                linewidth: float = 3, marker: str = None, map_frame: bool = True) -&gt; None:\n    '''\n    Plot path-like information.\n    The meaning of parameters are similar to matplotlib.pyplot.plot (https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html).\n\n    Args:\n        path: point list of path\n        style: style of path\n        color: color of path\n        label: label of path\n        linewidth: linewidth of path\n        marker: marker of path\n        map_frame: whether path is in map frame or not (world frame)\n    '''\n    if len(path) == 0:\n        return\n\n    if map_frame:\n        path = [self.grid_map.map_to_world(point) for point in path]\n\n    path = np.array(path)\n\n    if self.dim == 2:\n        self.ax.plot(path[:, 0], path[:, 1], style, lw=linewidth, color=color, label=label, marker=marker, zorder=self.zorder['path_2d'])\n    elif self.dim == 3:\n        self.ax.plot(path[:, 0], path[:, 1], path[:, 2], style, lw=linewidth, color=color, label=label, marker=marker, zorder=self.zorder['path_3d'])\n    else:\n        raise ValueError(\"Dimension not supported\")\n\n    if label:\n        self.ax.legend()\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.render_toy_simulator","title":"<code>render_toy_simulator(env, controllers, steps=1000, interval=None, show_traj=True, traj_kwargs={'linestyle': '-', 'alpha': 0.7, 'linewidth': 1.5}, show_env_info=False, rtf_limit=1.0, grid_kwargs={}, show_pred_traj=True)</code>","text":"<p>Render the toy simulator.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>ToySimulator</code> <p>ToySimulator object.</p> required <code>controllers</code> <code>Dict[str, BaseController]</code> <p>Controllers for each robot.</p> required <code>steps</code> <code>int</code> <p>Number of steps to render.</p> <code>1000</code> <code>interval</code> <code>int</code> <p>Interval between frames in milliseconds.</p> <code>None</code> <code>show_traj</code> <code>bool</code> <p>Whether to show trajectories.</p> <code>True</code> <code>traj_kwargs</code> <code>dict</code> <p>Keyword arguments for trajectories.</p> <code>{'linestyle': '-', 'alpha': 0.7, 'linewidth': 1.5}</code> <code>show_env_info</code> <code>bool</code> <p>Whether to show environment information.</p> <code>False</code> <code>rtf_limit</code> <code>float</code> <p>Maximum real-time factor.</p> <code>1.0</code> <code>grid_kwargs</code> <code>dict</code> <p>Keyword arguments for grid map.</p> <code>{}</code> <code>show_pred_traj</code> <code>bool</code> <p>Whether to show predicted trajectories (for DWA etc.).</p> <code>True</code> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def render_toy_simulator(self, env: ToySimulator, controllers: Dict[str, BaseController],\n        steps: int = 1000, interval: int = None,\n        show_traj: bool = True, traj_kwargs: dict = {\"linestyle\": '-', \"alpha\": 0.7, \"linewidth\": 1.5},\n        show_env_info: bool = False, rtf_limit: float = 1.0, grid_kwargs: dict = {},\n        show_pred_traj: bool = True) -&gt; None:\n    \"\"\"\n    Render the toy simulator.\n\n    Args:\n        env: ToySimulator object.\n        controllers: Controllers for each robot.\n        steps: Number of steps to render.\n        interval: Interval between frames in milliseconds.\n        show_traj: Whether to show trajectories.\n        traj_kwargs: Keyword arguments for trajectories.\n        show_env_info: Whether to show environment information.\n        rtf_limit: Maximum real-time factor.\n        grid_kwargs: Keyword arguments for grid map.\n        show_pred_traj: Whether to show predicted trajectories (for DWA etc.).\n    \"\"\"\n\n    if interval is None:\n        interval = int(1000 * env.dt)\n\n    if traj_kwargs.get(\"color\") is None:\n        traj_color = {rid: robot.color for rid, robot in env.robots.items()}\n    else:\n        traj_color = {rid: traj_kwargs.get(\"color\") for rid, robot in env.robots.items()}\n\n    # \u5148\u753b\u9759\u6001\u7684\u5730\u56fe\u548c\u8def\u5f84\n    self.ax.clear()\n    self.plot_grid_map(env.obstacle_grid, **grid_kwargs)\n\n    self.trajs = {rid: {\n        \"poses\": [],\n        \"time\": []\n    } for rid in env.robots}\n\n    last_time = time.time()\n    if show_env_info:\n        env_info_text = self.ax.text(0.02, 0.95, \"\", transform=self.ax.transAxes, \n                                    ha=\"left\", va=\"top\", alpha=0.5, color=\"white\", zorder=self.zorder['env_info_text'])\n        env_info_text.set_path_effects([path_effects.withStroke(linewidth=2, foreground='black')])\n\n    prepare_frames = 5\n\n    def update(frame):\n        nonlocal last_time\n        nonlocal prepare_frames\n\n        patches = []\n        actions = {}\n\n        while prepare_frames &gt; 0:    # matplotlib has a bug\n            prepare_frames -= 1\n            return patches\n\n        for rid, robot in env.robots.items():\n            self.trajs[rid][\"poses\"].append(robot.pose.copy())\n            self.trajs[rid][\"time\"].append(env.time)\n\n            ob = robot.get_observation(env)\n            act, lookahead_pose = controllers[rid].get_action(ob)\n\n            if lookahead_pose is not None:\n                lookahead_pose_patch = plt.Circle(lookahead_pose[:2], 0.2, color=robot.color, alpha=0.5, zorder=self.zorder['lookahead_pose_node'])\n                self.ax.add_patch(lookahead_pose_patch)\n                patches.append(lookahead_pose_patch)\n\n                theta = lookahead_pose[2]\n                dx = np.cos(theta) * robot.radius\n                dy = np.sin(theta) * robot.radius\n                orient_patch = self.ax.arrow(lookahead_pose[0], lookahead_pose[1], dx, dy,\n                                            width=0.2*robot.radius,\n                                            fc=robot.color, ec=robot.color, alpha=0.5, zorder=self.zorder['lookahead_pose_orient'])\n                patches.append(orient_patch)\n\n            actions[rid] = act\n\n        for rid, robot in env.robots.items():\n            items = self.plot_circular_robot(robot)\n            for item in items:\n                if item is not None:\n                    patches.append(item)\n\n        # draw trajectories\n        if show_traj:\n            for rid, traj in self.trajs.items():\n                poses = traj[\"poses\"]\n                if len(poses) &gt; 1:\n                    pose_x = [p[0] for p in poses]\n                    pose_y = [p[1] for p in poses]\n                    traj_line, = self.ax.plot(pose_x, pose_y, color=traj_color[rid], zorder=self.zorder['traj'], **traj_kwargs)\n                    patches.append(traj_line)\n\n        if show_pred_traj:\n            for rid, controller in controllers.items():\n                pred_traj = controller.pred_traj\n                if len(pred_traj) &gt; 1:\n                    pred_traj_x = [p[0] for p in pred_traj]\n                    pred_traj_y = [p[1] for p in pred_traj]\n                    pred_traj_line, = self.ax.plot(pred_traj_x, pred_traj_y, color=traj_color[rid], zorder=self.zorder['pred_traj'], **traj_kwargs)\n                    patches.append(pred_traj_line)\n\n        elapsed = time.time() - last_time\n        if rtf_limit and env.dt / elapsed &gt; rtf_limit:\n            time.sleep(env.dt / rtf_limit - elapsed)\n            elapsed = time.time() - last_time\n\n        if show_env_info:\n            step_count = env.step_count\n            sim_time = step_count * env.dt\n            rtf = env.dt / elapsed\n            env_info_text.set_text(f\"Step: {step_count}, Time: {sim_time:.3f}s, RTF: {rtf:.3f}\")\n            patches.append(env_info_text)\n\n        last_time = time.time()\n\n        if env.step_count &lt; steps:\n            obs, rewards, dones, info = env.step(actions)\n\n        return patches\n\n    self.ani = animation.FuncAnimation(\n        self.fig, update, frames=steps+prepare_frames, interval=interval, blit=True, repeat=False\n    )\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.set_title","title":"<code>set_title(title)</code>","text":"<p>Set title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title.</p> required Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def set_title(self, title: str) -&gt; None:\n    \"\"\"\n    Set title.\n\n    Args:\n        title: Title.\n    \"\"\"\n    plt.title(title)\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.show","title":"<code>show()</code>","text":"<p>Show plot.</p> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def show(self):\n    \"\"\"\n    Show plot.\n    \"\"\"\n    plt.show()\n</code></pre>"},{"location":"api/common/visualizer/visualizer/Visualizer.html#src.python_motion_planning.common.visualizer.visualizer.Visualizer.update","title":"<code>update()</code>","text":"<p>Update plot.</p> Source code in <code>src\\python_motion_planning\\common\\visualizer\\visualizer.py</code> Python<pre><code>def update(self):\n    \"\"\"\n    Update plot.\n    \"\"\"\n    self.fig.canvas.draw_idle()\n</code></pre>"},{"location":"api/controller/base_controller/BaseController.html","title":"BaseController","text":""},{"location":"api/controller/base_controller/BaseController.html#src.python_motion_planning.controller.base_controller.BaseController","title":"<code>src.python_motion_planning.controller.base_controller.BaseController</code>","text":"<p>Base class for controllers. - The controller only knows observation_space, action_space</p> <p>Parameters:</p> Name Type Description Default <code>observation_space</code> <code>Space</code> <p>observation space ([pos, orient, lin_vel, ang_vel])</p> required <code>action_space</code> <code>Box</code> <p>action space ([lin_acc, ang_acc])</p> required <code>dt</code> <code>float</code> <p>time step for control</p> required <code>path</code> <code>List[Tuple[float, ...]]</code> <p>pose path to follow</p> <code>[]</code> <code>max_lin_speed</code> <code>float</code> <p>maximum linear speed of the robot</p> <code>inf</code> <code>max_ang_speed</code> <code>float</code> <p>maximum angular speed of the robot</p> <code>inf</code> <code>goal_dist_tol</code> <code>float</code> <p>goal distance tolerance</p> <code>0.5</code> <code>goal_orient_tol</code> <code>float</code> <p>goal orient tolerance</p> <code>deg2rad(5)</code> <code>eps</code> <code>float</code> <p>epsilon (numerical precision)</p> <code>1e-08</code> Source code in <code>src\\python_motion_planning\\controller\\base_controller.py</code> Python<pre><code>class BaseController:\n    \"\"\"\n    Base class for controllers.\n    - The controller only knows observation_space, action_space\n\n    Args:\n        observation_space: observation space ([pos, orient, lin_vel, ang_vel])\n        action_space: action space ([lin_acc, ang_acc])\n        dt: time step for control\n        path: pose path to follow\n        max_lin_speed: maximum linear speed of the robot\n        max_ang_speed: maximum angular speed of the robot\n        goal_dist_tol: goal distance tolerance\n        goal_orient_tol: goal orient tolerance\n        eps: epsilon (numerical precision)\n    \"\"\"\n    def __init__(self, observation_space: spaces.Space, action_space: spaces.Box,\n                 dt: float, path: List[Tuple[float, ...]] = [], \n                 max_lin_speed: float = np.inf, max_ang_speed: float = np.inf,\n                 goal_dist_tol: float = 0.5, goal_orient_tol: float = np.deg2rad(5),\n                 eps: float = 1e-8):\n        self.observation_space = observation_space\n        self.action_space = action_space\n        self.dt = dt\n        self.path = path\n        self.max_lin_speed = max_lin_speed\n        self.max_ang_speed = max_ang_speed\n        self.goal_dist_tol = goal_dist_tol\n        self.goal_orient_tol = goal_orient_tol\n        self.eps = eps\n\n        # Guess dimension from action space\n        if self.action_space.shape[0] == 3:\n            self.dim = 2\n            self.pose_dim = 3\n        elif self.action_space.shape[0] == 6:\n            self.dim = 3\n            self.pose_dim = 6\n        else:\n            raise NotImplementedError(\"Action space shape must be 3 (dim=2) or 6 (dim=3). Other dimensions are not supported yet.\")\n\n        if len(self.path) &gt; 0:\n            if len(self.path[0]) == self.dim:\n                self.path = Geometry.add_orient_to_2d_path(self.path)\n            self.goal = self.path[-1]\n        else:\n            self.goal = None\n            self.path = False \n\n        self.pred_traj = np.array([])\n\n    def reset(self):\n        \"\"\"\n        Reset the controller to initial state.\n        \"\"\"\n        pass\n\n    def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get action from observation.\n\n        Args:\n            obs: observation ([pos, orient, lin_vel, ang_vel])\n\n        Returns:\n            action: action ([lin_acc, ang_acc])\n            target_pose: lookahead pose ([pos, orient])\n        \"\"\"\n        return np.zeros(self.action_space.shape), self.goal\n\n    def clip_velocity(self, v: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Clip the velocity to the maximum allowed value.\n\n        Args:\n            v (np.ndarray): The velocity to clip.\n\n        Returns:\n            np.ndarray: The clipped velocity.\n        \"\"\"\n        lv = v[:self.dim]   # linear velocity\n        av = v[self.dim:]   # angular velocity\n        lv = lv if np.linalg.norm(lv) &lt;= self.max_lin_speed else lv / np.linalg.norm(lv) * self.max_lin_speed\n        av = av if np.linalg.norm(av) &lt;= self.max_ang_speed else av / np.linalg.norm(av) * self.max_ang_speed\n        return np.concatenate([lv, av])\n\n    def clip_action(self, a: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Clip action to action bounds.\n\n        Args:\n            a(np.ndarray): Action vector\n\n        Returns:\n            np.ndarray: Clipped action vector\n        \"\"\"\n        return np.clip(a, self.action_space.low, self.action_space.high)\n\n    def get_pose_velocity(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Get pose and velocity from observation.\n\n        Args:\n            obs: observation ([pos, orient, lin_vel, ang_vel])\n\n        Returns:\n            pose: pose ([pos, orient])\n            vel: velocity ([lin_vel, ang_vel])\n            pos: position ([pos_x, pos_y])\n            orient: orientation ([orient])\n            lin_vel: linear velocity ([lin_vel_x, lin_vel_y])\n            ang_vel: angular velocity (ang_vel)\n        \"\"\"\n        pose = obs[:self.pose_dim]\n        vel = obs[self.pose_dim:self.pose_dim*2]\n\n        pos = pose[:self.dim]\n        orient = pose[self.dim:]\n        lin_vel = vel[:self.dim]\n        ang_vel = vel[self.dim:]\n\n        return pose, vel, pos, orient, lin_vel, ang_vel\n\n    def _stop_if_reached(self, desired_vel: np.ndarray, pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Stop if the robot has reached the target (within the tolerance).\n\n        Args:\n            desired_vel: the desired velocity (robot frame)\n            pose: the current pose (world frame)\n\n        Returns:\n            desired_vel: the desired velocity (robot frame)\n        \"\"\"\n        pos = pose[:self.dim]\n        orient = pose[self.dim:]\n        goal_pos = self.goal[:self.dim]\n        goal_orient = self.goal[self.dim:]\n\n        if np.linalg.norm(pos - goal_pos) &lt; self.goal_dist_tol:\n            desired_vel[:self.dim] = 0.0\n\n            if np.abs(Geometry.regularize_orient(orient - goal_orient)) &lt; self.goal_orient_tol:\n                desired_vel[self.dim:] = 0.0\n\n        return desired_vel\n</code></pre>"},{"location":"api/controller/base_controller/BaseController.html#src.python_motion_planning.controller.base_controller.BaseController.clip_action","title":"<code>clip_action(a)</code>","text":"<p>Clip action to action bounds.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Action vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Clipped action vector</p> Source code in <code>src\\python_motion_planning\\controller\\base_controller.py</code> Python<pre><code>def clip_action(self, a: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Clip action to action bounds.\n\n    Args:\n        a(np.ndarray): Action vector\n\n    Returns:\n        np.ndarray: Clipped action vector\n    \"\"\"\n    return np.clip(a, self.action_space.low, self.action_space.high)\n</code></pre>"},{"location":"api/controller/base_controller/BaseController.html#src.python_motion_planning.controller.base_controller.BaseController.clip_velocity","title":"<code>clip_velocity(v)</code>","text":"<p>Clip the velocity to the maximum allowed value.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>The velocity to clip.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The clipped velocity.</p> Source code in <code>src\\python_motion_planning\\controller\\base_controller.py</code> Python<pre><code>def clip_velocity(self, v: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Clip the velocity to the maximum allowed value.\n\n    Args:\n        v (np.ndarray): The velocity to clip.\n\n    Returns:\n        np.ndarray: The clipped velocity.\n    \"\"\"\n    lv = v[:self.dim]   # linear velocity\n    av = v[self.dim:]   # angular velocity\n    lv = lv if np.linalg.norm(lv) &lt;= self.max_lin_speed else lv / np.linalg.norm(lv) * self.max_lin_speed\n    av = av if np.linalg.norm(av) &lt;= self.max_ang_speed else av / np.linalg.norm(av) * self.max_ang_speed\n    return np.concatenate([lv, av])\n</code></pre>"},{"location":"api/controller/base_controller/BaseController.html#src.python_motion_planning.controller.base_controller.BaseController.get_action","title":"<code>get_action(obs)</code>","text":"<p>Get action from observation.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>ndarray</code> <p>observation ([pos, orient, lin_vel, ang_vel])</p> required <p>Returns:</p> Name Type Description <code>action</code> <code>ndarray</code> <p>action ([lin_acc, ang_acc])</p> <code>target_pose</code> <code>ndarray</code> <p>lookahead pose ([pos, orient])</p> Source code in <code>src\\python_motion_planning\\controller\\base_controller.py</code> Python<pre><code>def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get action from observation.\n\n    Args:\n        obs: observation ([pos, orient, lin_vel, ang_vel])\n\n    Returns:\n        action: action ([lin_acc, ang_acc])\n        target_pose: lookahead pose ([pos, orient])\n    \"\"\"\n    return np.zeros(self.action_space.shape), self.goal\n</code></pre>"},{"location":"api/controller/base_controller/BaseController.html#src.python_motion_planning.controller.base_controller.BaseController.get_pose_velocity","title":"<code>get_pose_velocity(obs)</code>","text":"<p>Get pose and velocity from observation.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>ndarray</code> <p>observation ([pos, orient, lin_vel, ang_vel])</p> required <p>Returns:</p> Name Type Description <code>pose</code> <code>ndarray</code> <p>pose ([pos, orient])</p> <code>vel</code> <code>ndarray</code> <p>velocity ([lin_vel, ang_vel])</p> <code>pos</code> <code>ndarray</code> <p>position ([pos_x, pos_y])</p> <code>orient</code> <code>ndarray</code> <p>orientation ([orient])</p> <code>lin_vel</code> <code>ndarray</code> <p>linear velocity ([lin_vel_x, lin_vel_y])</p> <code>ang_vel</code> <code>ndarray</code> <p>angular velocity (ang_vel)</p> Source code in <code>src\\python_motion_planning\\controller\\base_controller.py</code> Python<pre><code>def get_pose_velocity(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Get pose and velocity from observation.\n\n    Args:\n        obs: observation ([pos, orient, lin_vel, ang_vel])\n\n    Returns:\n        pose: pose ([pos, orient])\n        vel: velocity ([lin_vel, ang_vel])\n        pos: position ([pos_x, pos_y])\n        orient: orientation ([orient])\n        lin_vel: linear velocity ([lin_vel_x, lin_vel_y])\n        ang_vel: angular velocity (ang_vel)\n    \"\"\"\n    pose = obs[:self.pose_dim]\n    vel = obs[self.pose_dim:self.pose_dim*2]\n\n    pos = pose[:self.dim]\n    orient = pose[self.dim:]\n    lin_vel = vel[:self.dim]\n    ang_vel = vel[self.dim:]\n\n    return pose, vel, pos, orient, lin_vel, ang_vel\n</code></pre>"},{"location":"api/controller/base_controller/BaseController.html#src.python_motion_planning.controller.base_controller.BaseController.reset","title":"<code>reset()</code>","text":"<p>Reset the controller to initial state.</p> Source code in <code>src\\python_motion_planning\\controller\\base_controller.py</code> Python<pre><code>def reset(self):\n    \"\"\"\n    Reset the controller to initial state.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/controller/path_tracker/apf/APF.html","title":"APF","text":""},{"location":"api/controller/path_tracker/apf/APF.html#src.python_motion_planning.controller.path_tracker.apf.APF","title":"<code>src.python_motion_planning.controller.path_tracker.apf.APF</code>","text":"<p>               Bases: <code>PathTracker</code></p> <p>Artificial Potential Field (APF) path-tracking controller.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>robot_model</code> <code>BaseRobot</code> <p>robot model for kinematic parameters</p> required <code>obstacle_grid</code> <code>Grid</code> <p>occupancy grid map for collision checking</p> <code>None</code> <code>attr_weight</code> <code>float</code> <p>weight factor for attractive potential</p> <code>1.0</code> <code>rep_weight</code> <code>float</code> <p>weight factor for repulsive potential</p> <code>1.0</code> <code>rep_range</code> <code>float</code> <p>influence range for repulsive potential</p> <code>None</code> <code>**kwargs</code> <p>see the parent class.</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\apf.py</code> Python<pre><code>class APF(PathTracker):\n    \"\"\"\n    Artificial Potential Field (APF) path-tracking controller.\n\n    Args:\n        *args: see the parent class.\n        robot_model: robot model for kinematic parameters\n        obstacle_grid: occupancy grid map for collision checking\n        attr_weight: weight factor for attractive potential\n        rep_weight: weight factor for repulsive potential\n        rep_range: influence range for repulsive potential\n        **kwargs: see the parent class.\n    \"\"\"\n    def __init__(self,\n                 *args,\n                 robot_model: BaseRobot,\n                 obstacle_grid: Grid = None,\n                 attr_weight: float = 1.0,\n                 rep_weight: float = 1.0,\n                 rep_range: float = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        if robot_model.dim != self.dim:\n            raise ValueError(\"Dimension of robot model and controller must be the same\")\n        self.robot_model = robot_model\n\n        if obstacle_grid and obstacle_grid.dim != self.dim:\n            raise ValueError(\"Dimension of obstacle grid and controller must be the same\")\n        self.obstacle_grid = obstacle_grid\n\n        # APF parameters\n        self.attr_weight = attr_weight  # Attractive potential weight\n        self.rep_weight = rep_weight    # Repulsive potential weight\n        self.rep_range = rep_range if rep_range is not None else self.robot_model.radius * 2.0  # Repulsive influence range\n\n    def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get action from observation using Artificial Potential Field method.\n\n        Args:\n            obs: observation ([pos, orient, lin_vel, ang_vel])\n\n        Returns:\n            action: action in robot frame ([lin_acc, ang_acc])\n            target_pose: lookahead pose ([pos, orient])\n        \"\"\"\n        if self.goal is None:\n            return np.zeros(self.action_space.shape), self.goal\n\n        pose, vel, pos, orient, lin_vel, ang_vel = self.get_pose_velocity(obs)\n\n        # Find the lookahead pose as the target for attractive potential\n        target_pose = self._get_lookahead_pose(pos)\n\n        # Calculate potential field forces\n        attractive_force = self._calculate_attractive_force(pos, target_pose[:self.dim])\n        repulsive_force = self._calculate_repulsive_force(pos)\n\n        # Total force is the sum of attractive and repulsive forces\n        total_force = attractive_force + repulsive_force\n\n        # Calculate desired velocity from total force\n        desired_vel = self._force_to_velocity(total_force, orient)\n        desired_vel = self._stop_if_reached(desired_vel, pose)\n\n        # Convert current velocity to robot frame and calculate action\n        robot_vel = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)\n        action = self._get_desired_action(desired_vel, robot_vel, orient)\n\n        return action, target_pose\n\n    def _calculate_attractive_force(self, current_pos: np.ndarray, target_pos: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate attractive force towards the target position.\n\n        Args:\n            current_pos: Current position of the robot in world frame\n            target_pos: Target position (lookahead point) in world frame\n\n        Returns:\n            attractive_force: Attractive force vector in world frame\n        \"\"\"\n        # Vector from current position to target position\n        direction = target_pos - current_pos\n        distance = np.linalg.norm(direction)\n\n        # If distance is very small, return zero force to avoid division issues\n        if distance &lt; self.eps:\n            return np.zeros_like(direction)\n\n        # Normalize direction and scale by weight and distance\n        # For standard APF, attractive force is proportional to distance\n        attractive_force = self.attr_weight * direction\n\n        return attractive_force\n\n    def _calculate_repulsive_force(self, current_pos: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate repulsive force from obstacles using ESDF.\n\n        Args:\n            current_pos: Current position of the robot in world frame\n\n        Returns:\n            repulsive_force: Repulsive force vector in world frame\n        \"\"\"\n        if self.obstacle_grid is None:\n            return np.zeros(self.dim)\n\n        # Convert world position to grid coordinates\n        grid_pt = self.obstacle_grid.world_to_map(tuple(current_pos[:2]))\n        grid_x, grid_y = grid_pt\n\n        # Check if position is out of bounds or in an obstacle\n        if not self.obstacle_grid.within_bounds(grid_pt) or self.obstacle_grid.type_map[grid_pt] == TYPES.OBSTACLE:\n            # Large repulsive force if in collision\n            return np.full(self.dim, self.rep_weight * self.rep_range)\n\n        # Get distance to nearest obstacle from ESDF (in world units)\n        dist_to_obstacle = self.obstacle_grid.esdf[grid_pt] * self.obstacle_grid.resolution\n\n        # No repulsive force if outside influence range\n        if dist_to_obstacle &gt;= self.rep_range:\n            return np.zeros(self.dim)\n\n        # Calculate gradient of repulsive potential using numpy's gradient function\n        # Extract a small window around current grid point to compute gradient\n        window_size = 3  # 3x3 window for gradient calculation\n        half_window = window_size // 2\n\n        # Initialize window with current distance value\n        window = np.zeros((window_size, window_size))\n        window[half_window, half_window] = self.obstacle_grid.esdf[grid_pt]\n\n        # Fill window with neighboring ESDF values, handling boundary conditions\n        for i in range(window_size):\n            for j in range(window_size):\n                # Calculate grid coordinates for this window position\n                grid_i = grid_x + (i - half_window)\n                grid_j = grid_y + (j - half_window)\n\n                # Check if neighboring grid point is within bounds\n                if self.obstacle_grid.within_bounds((grid_i, grid_j)):\n                    window[i, j] = self.obstacle_grid.esdf[(grid_i, grid_j)]\n                else:\n                    # For points outside bounds, use distance decreasing away from map\n                    dx = abs(i - half_window)\n                    dy = abs(j - half_window)\n                    dist_from_center = math.sqrt(dx*dx + dy*dy)\n                    window[i, j] = max(0, self.obstacle_grid.esdf[grid_pt] - dist_from_center)\n\n        window *= self.obstacle_grid.resolution\n\n        # Calculate gradient using numpy.gradient\n        # The gradient is scaled by grid resolution to get world coordinates    \n        # TODO: Check if this is correct\n        # gy, gx = np.gradient(window) \n        gx, gy = np.gradient(window)\n\n        # The gradient at the center of the window gives the direction of maximum increase\n        # This is the direction away from obstacles\n        gradient_dir = np.array([gx[half_window, half_window], gy[half_window, half_window]])\n\n        # Normalize gradient direction\n        grad_mag = np.linalg.norm(gradient_dir)\n        if grad_mag &lt; 1e-6:\n            return np.zeros(self.dim)\n        gradient_dir = gradient_dir / grad_mag\n\n        # Calculate repulsive force magnitude using standard APF formula\n        rep_force_magnitude = self.rep_weight * (1.0 / dist_to_obstacle - 1.0 / self.rep_range) / (dist_to_obstacle ** 2)\n\n        # Scale direction by repulsive force magnitude\n        repulsive_force = rep_force_magnitude * gradient_dir\n\n        return repulsive_force\n\n    def _force_to_velocity(self, force: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Convert force vector to desired velocity in robot frame.\n\n        Args:\n            force: Total force vector in world frame\n            orient: Current orientation in world frame\n\n        Returns:\n            desired_vel: Desired velocity in robot frame\n        \"\"\"\n        force_magnitude = np.linalg.norm(force)\n\n        # If force is very small, return zero velocity\n        if force_magnitude &lt; self.eps:\n            return np.zeros(self.action_space.shape[0])\n\n        # Desired linear velocity is proportional to force magnitude\n        desired_lin_speed = min(force_magnitude, self.max_lin_speed)\n        desired_lin_dir = force / force_magnitude  # Direction of force\n\n        # Desired angular velocity is based on angle difference between force direction and robot orientation\n        force_angle = np.array([math.atan2(desired_lin_dir[1], desired_lin_dir[0])])\n        angle_diff = Geometry.regularize_orient(force_angle - orient)\n        desired_ang_speed = min(np.linalg.norm(angle_diff) / self.dt, self.max_ang_speed)\n        desired_ang_speed *= np.sign(angle_diff[0])  # Preserve direction\n\n        desired_ang_speed = np.array([desired_ang_speed])\n\n        # Combine linear and angular velocity\n        desired_vel_world = np.concatenate([desired_lin_dir * desired_lin_speed, desired_ang_speed])\n\n        # Convert desired velocity to robot frame\n        desired_vel_robot = FrameTransformer.vel_world_to_robot(self.dim, desired_vel_world, orient)\n\n        return self.clip_velocity(desired_vel_robot)\n</code></pre>"},{"location":"api/controller/path_tracker/apf/APF.html#src.python_motion_planning.controller.path_tracker.apf.APF.get_action","title":"<code>get_action(obs)</code>","text":"<p>Get action from observation using Artificial Potential Field method.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>ndarray</code> <p>observation ([pos, orient, lin_vel, ang_vel])</p> required <p>Returns:</p> Name Type Description <code>action</code> <code>ndarray</code> <p>action in robot frame ([lin_acc, ang_acc])</p> <code>target_pose</code> <code>ndarray</code> <p>lookahead pose ([pos, orient])</p> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\apf.py</code> Python<pre><code>def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get action from observation using Artificial Potential Field method.\n\n    Args:\n        obs: observation ([pos, orient, lin_vel, ang_vel])\n\n    Returns:\n        action: action in robot frame ([lin_acc, ang_acc])\n        target_pose: lookahead pose ([pos, orient])\n    \"\"\"\n    if self.goal is None:\n        return np.zeros(self.action_space.shape), self.goal\n\n    pose, vel, pos, orient, lin_vel, ang_vel = self.get_pose_velocity(obs)\n\n    # Find the lookahead pose as the target for attractive potential\n    target_pose = self._get_lookahead_pose(pos)\n\n    # Calculate potential field forces\n    attractive_force = self._calculate_attractive_force(pos, target_pose[:self.dim])\n    repulsive_force = self._calculate_repulsive_force(pos)\n\n    # Total force is the sum of attractive and repulsive forces\n    total_force = attractive_force + repulsive_force\n\n    # Calculate desired velocity from total force\n    desired_vel = self._force_to_velocity(total_force, orient)\n    desired_vel = self._stop_if_reached(desired_vel, pose)\n\n    # Convert current velocity to robot frame and calculate action\n    robot_vel = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)\n    action = self._get_desired_action(desired_vel, robot_vel, orient)\n\n    return action, target_pose\n</code></pre>"},{"location":"api/controller/path_tracker/dwa/DWA.html","title":"DWA","text":""},{"location":"api/controller/path_tracker/dwa/DWA.html#src.python_motion_planning.controller.path_tracker.dwa.DWA","title":"<code>src.python_motion_planning.controller.path_tracker.dwa.DWA</code>","text":"<p>               Bases: <code>PathTracker</code></p> <p>Dynamic Window Approach (DWA) path-tracking controller.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>robot_model</code> <code>BaseRobot</code> <p>robot model for kinematic simulation</p> required <code>obstacle_grid</code> <code>Grid</code> <p>occupancy grid map for collision checking</p> <code>None</code> <code>vel_reso</code> <code>float</code> <p>resolution of velocity sampling</p> <code>array([0.2, 0.2, deg2rad(15)])</code> <code>predict_time</code> <code>float</code> <p>forward simulation time horizon</p> <code>None</code> <code>heading_weight</code> <code>float</code> <p>weight for heading term</p> <code>0.5</code> <code>velocity_weight</code> <code>float</code> <p>weight for velocity term</p> <code>0.2</code> <code>clearance_weight</code> <code>float</code> <p>weight for obstacle clearance term</p> <code>0.3</code> <code>**kwargs</code> <p>see the parent class.</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\dwa.py</code> Python<pre><code>class DWA(PathTracker):\n    \"\"\"\n    Dynamic Window Approach (DWA) path-tracking controller.\n\n    Args:\n        *args: see the parent class.\n        robot_model: robot model for kinematic simulation\n        obstacle_grid: occupancy grid map for collision checking\n        vel_reso: resolution of velocity sampling\n        predict_time: forward simulation time horizon\n        heading_weight: weight for heading term\n        velocity_weight: weight for velocity term\n        clearance_weight: weight for obstacle clearance term\n        **kwargs: see the parent class.\n    \"\"\"\n    def __init__(self,\n                 *args,\n                 robot_model: BaseRobot,\n                 obstacle_grid: Grid = None,\n                 vel_reso: float = np.array([0.2, 0.2, np.deg2rad(15)]),\n                 predict_time: float = None,\n                 heading_weight: float = 0.5,\n                 velocity_weight: float = 0.2,\n                 clearance_weight: float = 0.3,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        if robot_model.dim != self.dim:\n            raise ValueError(\"Dimension of robot model and controller must be the same\")\n        self.robot_model = robot_model\n\n        if obstacle_grid.dim != self.dim:\n            raise ValueError(\"Dimension of obstacle grid and controller must be the same\")\n        self.obstacle_grid = obstacle_grid\n\n        self.vel_reso = vel_reso\n        self.predict_time = predict_time if predict_time is not None else self.lookahead_distance / self.max_lin_speed\n        self.heading_weight = heading_weight\n        self.velocity_weight = velocity_weight\n        self.clearance_weight = clearance_weight\n\n    def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get action from observation using Dynamic Window Approach.\n\n        Args:\n            obs: observation ([pos, orient, lin_vel, ang_vel])\n\n        Returns:\n            action: action in robot frame ([lin_acc, ang_acc])\n            target_pose: selected local goal ([pos, orient])\n        \"\"\"\n        if self.goal is None:\n            return np.zeros(self.action_space.shape), self.goal\n\n        pose, vel, pos, orient, lin_vel, ang_vel = self.get_pose_velocity(obs)  # world frame\n\n        # Find the lookahead pose\n        target_pose = self._get_lookahead_pose(pos)\n\n        # search best control within dynamic window\n        best_vel, best_traj = self._evaluate_trajectories(pose, vel, target_pose)\n\n        # compute action (acceleration) to reach best velocity\n        desired_vel = best_vel    # robot frame\n        desired_vel = self._stop_if_reached(desired_vel, pose)  # robot frame\n        robot_vel = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)\n        action = self._get_desired_action(desired_vel, robot_vel, orient)   # robot frame\n\n        self.pred_traj = best_traj  # for visualization\n\n        return action, target_pose\n\n    def _evaluate_trajectories(self, pose: np.ndarray, vel: np.ndarray, target_pose: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Evaluate trajectories in dynamic window and choose the best.\n\n        Args:\n            pose: current pose ([x, y, theta])  world frame\n            vel: current velocity ([vx, vy, omega]) world frame\n            target_pose: target pose ([x, y, theta])    world frame\n\n        Returns:\n            best_vel: best velocity command [vx, vy, omega]   robot frame\n            best_traj: best simulated trajectory\n        \"\"\"\n        # v_min, v_max, w_min, w_max = dw\n        best_score = -float(\"inf\")\n        best_vel = np.zeros_like(vel)   # should be in world frame\n        best_scores = (0.0,0.0,0.0)\n        best_traj = []\n\n        orient = pose[self.dim:]\n        vel_robot = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)  # robot frame\n\n        vel_points = []\n        for d in range(self.action_space.shape[0]):\n            low = vel_robot[d] + self.action_space.low[d] * self.dt\n            high = vel_robot[d] + self.action_space.high[d] * self.dt\n            reso = self.vel_reso[d]\n\n            sample_points = np.arange(low, high, reso)\n\n            # make sure the high boundary velocity is included\n            sample_points = np.append(sample_points, [high])\n\n            if low &lt; 0 and high &gt; 0:\n                sample_points = np.append(sample_points, [0.0])\n\n            sample_points = np.unique(np.round(sample_points / self.eps) * self.eps)  # unique with numerical precision\n\n            vel_points.append(sample_points)\n\n        vel_grid = np.meshgrid(*vel_points)\n        sampled_vels = np.stack(vel_grid, axis=-1).reshape(-1, vel_robot.shape[0])  # robot frame\n\n        for sampled_vel in sampled_vels:\n            # exclude velocities that exceed max speed limitation\n            sampled_lin_speed = np.linalg.norm(sampled_vel[:self.dim])\n            if sampled_lin_speed &gt; self.max_lin_speed: \n                continue\n\n            sampled_ang_speed = np.linalg.norm(sampled_vel[self.dim:])\n            if sampled_ang_speed &gt; self.max_ang_speed: \n                continue\n\n            vel_world = FrameTransformer.vel_robot_to_world(self.dim, sampled_vel, orient)  # world frame\n            traj = self._forward_sim(pose, vel_world)\n\n            # evaluate cost terms\n            heading = self._heading_score(traj, target_pose)\n            velocity = self._velocity_score(sampled_lin_speed)\n            clearance = self._clearance_score(traj)\n\n            score = (self.heading_weight * heading +\n                        self.velocity_weight * velocity +\n                        self.clearance_weight * clearance)\n\n            if score &gt; best_score:\n                best_score = score\n                best_scores = (self.heading_weight * heading, self.velocity_weight * velocity, self.clearance_weight * clearance)\n                best_vel = sampled_vel\n                best_traj = traj\n\n        return best_vel, np.array(best_traj)\n\n    def _forward_sim(self, pose: np.ndarray, vel: np.ndarray) -&gt; List[np.ndarray]:\n        \"\"\"\n        Forward simulate trajectory using robot kinematic model.\n\n        Args:\n            pose: pose of robot (world frame)\n            vel: velocity of robot (world frame)\n\n        Returns:\n            traj: simulated trajectory (list of poses)\n        \"\"\"\n        traj = [pose.copy()]\n        time = 0.0\n        while time &lt;= self.predict_time:\n            pose, vel, _ = self.robot_model.kinematic_model(pose, vel, np.zeros_like(vel), np.zeros_like(vel), self.dt)\n            traj.append(pose)\n            time += self.dt\n        return traj\n\n    def _heading_score(self, traj: List[np.ndarray], target_pose: np.ndarray) -&gt; float:\n        \"\"\"\n        Compute heading cost (distance to goal).\n\n        Args:\n            traj: Trajectory.\n            target_pose: Target pose.\n\n        Returns:\n            float: Heading score.\n        \"\"\"\n        last_pose = traj[-1]\n        dist = np.linalg.norm(last_pose[:self.dim] - target_pose[:self.dim])\n        orient = np.linalg.norm(Geometry.regularize_orient(last_pose[self.dim:] - target_pose[self.dim:]))\n\n        normalized_dist = dist / self.goal_dist_tol\n        normalized_orient = orient / self.goal_orient_tol\n\n        dist_score = 0.5 * np.clip(1.0 / normalized_dist, 0.0, 1.0)     # normalized_dist &gt; 1.0\n        dist_score += 0.5 * np.clip(1.0 - normalized_dist, 0.0, 1.0)    # 0.0 &lt;= normalized_dist &lt;= 1.0\n\n        orient_score = 0.5 * np.clip(1.0 / normalized_orient, 0.0, 1.0)  # normalized_orient &gt; 1.0\n        orient_score += 0.5 * np.clip(1.0 - normalized_orient, 0.0, 1.0) # 0.0 &lt;= normalized_orient &lt;= 1.0\n\n        total_score = self.k_theta * dist_score + (1 - self.k_theta) * orient_score\n\n        return total_score\n\n    def _velocity_score(self, lin_speed: np.ndarray) -&gt; float:\n        \"\"\"\n        Compute the velocity score.\n\n        Args:\n            lin_speed (np.ndarray): The linear speed (robot frame)\n\n        Returns:\n            float: The velocity score\n        \"\"\"\n        return lin_speed / self.max_lin_speed\n\n    def _clearance_score(self, traj: List[np.ndarray]) -&gt; float:\n        \"\"\"\n        Compute clearance score (min distance to obstacles).\n        If no grid map is provided, return 1.0.\n\n        Args:\n            traj: The trajectory\n\n        Returns:\n            float: The clearance score\n        \"\"\"\n        if self.obstacle_grid is None:\n            return 1.0\n\n        radius = self.robot_model.radius\n\n        min_dist = float(\"inf\") \n        for p in traj:\n            grid_pt = self.obstacle_grid.world_to_map(tuple(p[:2]))\n            if not self.obstacle_grid.within_bounds(grid_pt) or self.obstacle_grid.type_map[grid_pt] == TYPES.OBSTACLE:\n                return -float(\"inf\")     # collision\n            # update min distance (Euclidean to occupied cells could be added here)\n            dist = self.obstacle_grid.esdf[grid_pt] * self.obstacle_grid.resolution # using ESDF to compute distance to nearest obstacle\n            min_dist = min(min_dist, dist)\n\n        normalized_min_dist = min_dist / self.robot_model.radius\n\n        if normalized_min_dist &lt; self.eps:\n            return -float(\"inf\")\n\n        return np.clip(1.0 - 1.0 / normalized_min_dist, 0.0, 1.0)  # normalized\n</code></pre>"},{"location":"api/controller/path_tracker/dwa/DWA.html#src.python_motion_planning.controller.path_tracker.dwa.DWA.get_action","title":"<code>get_action(obs)</code>","text":"<p>Get action from observation using Dynamic Window Approach.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>ndarray</code> <p>observation ([pos, orient, lin_vel, ang_vel])</p> required <p>Returns:</p> Name Type Description <code>action</code> <code>ndarray</code> <p>action in robot frame ([lin_acc, ang_acc])</p> <code>target_pose</code> <code>ndarray</code> <p>selected local goal ([pos, orient])</p> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\dwa.py</code> Python<pre><code>def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get action from observation using Dynamic Window Approach.\n\n    Args:\n        obs: observation ([pos, orient, lin_vel, ang_vel])\n\n    Returns:\n        action: action in robot frame ([lin_acc, ang_acc])\n        target_pose: selected local goal ([pos, orient])\n    \"\"\"\n    if self.goal is None:\n        return np.zeros(self.action_space.shape), self.goal\n\n    pose, vel, pos, orient, lin_vel, ang_vel = self.get_pose_velocity(obs)  # world frame\n\n    # Find the lookahead pose\n    target_pose = self._get_lookahead_pose(pos)\n\n    # search best control within dynamic window\n    best_vel, best_traj = self._evaluate_trajectories(pose, vel, target_pose)\n\n    # compute action (acceleration) to reach best velocity\n    desired_vel = best_vel    # robot frame\n    desired_vel = self._stop_if_reached(desired_vel, pose)  # robot frame\n    robot_vel = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)\n    action = self._get_desired_action(desired_vel, robot_vel, orient)   # robot frame\n\n    self.pred_traj = best_traj  # for visualization\n\n    return action, target_pose\n</code></pre>"},{"location":"api/controller/path_tracker/path_tracker/PathTracker.html","title":"PathTracker","text":""},{"location":"api/controller/path_tracker/path_tracker/PathTracker.html#src.python_motion_planning.controller.path_tracker.path_tracker.PathTracker","title":"<code>src.python_motion_planning.controller.path_tracker.path_tracker.PathTracker</code>","text":"<p>               Bases: <code>BaseController</code></p> <p>Class of proportional path-tracking controller.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>lookahead_distance</code> <code>float</code> <p>lookahead distance for path tracking (default: self.max_lin_speed)</p> <code>None</code> <code>k_theta</code> <code>float</code> <p>weight of theta error</p> <code>0.8</code> <code>pose_interp</code> <code>bool</code> <p>whether to interpolate between poses. if not, poses on the segments are last pose</p> <code>False</code> <code>**kwargs</code> <p>see the parent class.</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\path_tracker.py</code> Python<pre><code>class PathTracker(BaseController):\n    \"\"\"\n    Class of proportional path-tracking controller.\n\n    Args:\n        *args: see the parent class.\n        lookahead_distance: lookahead distance for path tracking (default: self.max_lin_speed)\n        k_theta: weight of theta error\n        pose_interp: whether to interpolate between poses. if not, poses on the segments are last pose\n        **kwargs: see the parent class.\n    \"\"\"\n    def __init__(self,\n                 *args,\n                 lookahead_distance: float = None,\n                 k_theta: float = 0.8,\n                 pose_interp: bool = False,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.lookahead_distance = lookahead_distance if lookahead_distance is not None else self.max_lin_speed\n        self.k_theta = k_theta\n        self.pose_interp = pose_interp\n        self.current_target_index = 0\n\n    def reset(self):\n        \"\"\"\n        Reset the controller to initial state.\n        \"\"\"\n        super().reset()\n        self.current_target_index = 0\n\n    def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get action from observation.\n\n        Args:\n            obs: observation in world frame ([pos, orient, lin_vel, ang_vel])\n\n        Returns:\n            action: action in robot frame ([lin_acc, ang_acc])\n            target_pose: lookahead pose ([pos, orient])\n        \"\"\"\n        if self.goal is None:\n            return np.zeros(self.action_space.shape), self.goal\n\n        pose, vel, pos, orient, lin_vel, ang_vel = self.get_pose_velocity(obs)\n\n        # Find the lookahead pose\n        target_pose = self._get_lookahead_pose(pos)\n\n        desired_vel = self._get_desired_vel(target_pose, pose)\n        desired_vel = self._stop_if_reached(desired_vel, pose)\n        robot_vel = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)\n        action = self._get_desired_action(desired_vel, robot_vel, orient)\n\n        return action, target_pose\n\n    def _get_desired_vel(self, target_pose: np.ndarray, cur_pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the desired velocity in robot frame.\n\n        Args:\n            target_pose: target pose in world frame\n            cur_pose: current pose in world frame\n\n        Returns:\n            desired_vel: desired velocity in robot frame\n        \"\"\"\n        rel_pose = FrameTransformer.pose_world_to_robot(self.dim, target_pose, cur_pose)\n\n        lin_direction = rel_pose[:self.dim]\n        lin_distance = np.linalg.norm(lin_direction)\n\n        angle_lin_diff = np.array([math.atan2(lin_direction[1], lin_direction[0])])\n        angle_ang_diff = rel_pose[self.dim:]\n        if lin_distance &lt; self.goal_dist_tol:\n            ang_direction = Geometry.regularize_orient(angle_ang_diff)\n        else:\n            ang_direction = Geometry.regularize_orient(\n                self.k_theta * angle_lin_diff +\n                (1.0 - self.k_theta) * angle_ang_diff\n                )\n        ang_distance = np.linalg.norm(ang_direction)\n\n        if lin_distance &gt; self.eps:\n            lin_direction /= lin_distance\n        if ang_distance &gt; self.eps:\n            ang_direction /= ang_distance\n\n        desired_lin_speed = min(lin_distance / self.dt, self.max_lin_speed)\n        desired_ang_speed = min(ang_distance / self.dt, self.max_ang_speed)\n\n        desired_lin_vel = lin_direction * desired_lin_speed\n        desired_ang_vel = ang_direction * desired_ang_speed\n\n        desired_vel = np.concatenate([desired_lin_vel, desired_ang_vel])\n        desired_vel = self.clip_velocity(desired_vel)\n\n        return desired_vel\n\n    def _get_desired_action(self, desired_vel: np.ndarray, vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the action to be taken to reach the desired velocity.\n\n        Args:\n            desired_vel: Desired velocity in robot frame.\n            vel: Current velocity in robot frame.\n            orient: Current orientation in world frame.\n\n        Returns:\n            np.ndarray: Action to be taken to reach the desired velocity.\n        \"\"\"\n        action = (desired_vel - vel) / self.dt\n        action = self.clip_action(action)\n        return action\n\n    def _get_lookahead_pose(self, pos: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Get the lookahead pose (x, y, theta) on the path.\n        Find the intersection point of the path with a circle centered at the robot's position with radius lookahead_distance.\n        If the goal pose is within the lookahead distance, return the goal pose.\n        If there are multiple intersections, return the one ahead of the robot along the path.\n        If there are no intersections, return the closest pose on the path.\n\n        Args:\n            pos: robot position (x, y)\n\n        Returns:\n            lookahead_pose: (x, y, theta)\n        \"\"\"\n        path = np.array(self.path)  # shape (N, 3)\n        xy_path = path[:, :self.dim]\n        r = self.lookahead_distance\n        end_pose = path[-1]\n\n        # check goal distance\n        if np.dot(end_pose[:self.dim] - pos, end_pose[:self.dim] - pos) &lt;= r * r + self.eps:\n            return end_pose\n\n        # collect intersections\n        candidates = []\n        for i in range(len(xy_path) - 1):\n            p1, p2 = xy_path[i], xy_path[i + 1]\n            theta1, theta2 = path[i, 2], path[i + 1, 2]\n            candidates.extend(\n                (i + t, pose)\n                for t, pose in self._circle_segment_intersections(pos, r, p1, p2, theta1, theta2)\n            )\n\n        if candidates:\n            candidates.sort(key=lambda x: x[0])\n            return candidates[-1][1]\n\n        # fallback: closest point on path\n        return self._closest_point_on_path(pos, path)\n\n    def _circle_segment_intersections(self, pos: np.ndarray, r: float, p1: np.ndarray, p2: np.ndarray, theta1: float, theta2: float):\n        \"\"\"\n        Find intersections between circle (center pos, radius r)\n        and line segment p1-p2 (with orientation interpolation).\n\n        Args:\n            pos: np.ndarray, circle center\n            r: float, circle radius\n            p1: np.ndarray, line segment start\n            p2: np.ndarray, line segment end\n            theta1: float, line segment start orientation\n            theta2: float, line segment end orientation\n\n        Returns:\n            List of (t, intersect_pose) where t is segment ratio in [0,1]\n        \"\"\"\n        d = p2 - p1\n        v = pos - p1\n        a = np.dot(d, d)\n        if a &lt; self.eps:\n            return []\n\n        b = -2 * np.dot(v, d)\n        c = np.dot(v, v) - r * r\n        discriminant = b * b - 4 * a * c\n        if discriminant &lt; 0:\n            return []\n\n        sqrt_d = np.sqrt(discriminant)\n        t1 = (-b + sqrt_d) / (2 * a)\n        t2 = (-b - sqrt_d) / (2 * a)\n\n        intersections = []\n        for t in (t1, t2):\n            if 0.0 &lt;= t &lt;= 1.0:\n                xy = p1 + t * d\n                theta = theta1\n                if self.pose_interp:\n                    theta += t * (theta2 - theta1)\n                theta = Geometry.regularize_orient(theta)\n                pose = np.array([xy[0], xy[1], theta])\n                intersections.append((t, pose))\n\n        return intersections\n\n    def _closest_point_on_path(self, pos: np.ndarray, path: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Find the closest point (with theta interpolation) on a polyline path to pos.\n\n        Args:\n            pos: query point (x, y)\n            path: array shape (N, 3), columns = (x, y, theta)\n\n        Returns:\n            closest_pose: np.ndarray (x, y, theta)\n        \"\"\"\n        xy_path = path[:, :2]\n        min_dist_sq = float(\"inf\")\n        closest_pose = path[0]\n\n        for i in range(len(xy_path) - 1):\n            p1, p2 = xy_path[i], xy_path[i + 1]\n            d = p2 - p1\n            v = pos - p1\n            a = np.dot(d, d)\n            if a &lt; self.eps:\n                continue\n\n            t = np.dot(v, d) / a\n            if t &lt; 0.0:\n                proj = p1\n                theta_proj = path[i, 2]\n            elif t &gt; 1.0:\n                proj = p2\n                theta_proj = path[i + 1, 2]\n            else:\n                proj = p1 + t * d\n                theta_proj = path[i, 2]\n                if self.pose_interp:\n                    theta_proj += t * (path[i + 1, 2] - path[i, 2])\n                theta_proj = Geometry.regularize_orient(theta_proj)\n\n            dist_sq = np.dot(pos - proj, pos - proj)\n            if dist_sq &lt; min_dist_sq:\n                min_dist_sq = dist_sq\n                closest_pose = np.array([proj[0], proj[1], theta_proj])\n\n        return closest_pose\n</code></pre>"},{"location":"api/controller/path_tracker/path_tracker/PathTracker.html#src.python_motion_planning.controller.path_tracker.path_tracker.PathTracker.get_action","title":"<code>get_action(obs)</code>","text":"<p>Get action from observation.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>ndarray</code> <p>observation in world frame ([pos, orient, lin_vel, ang_vel])</p> required <p>Returns:</p> Name Type Description <code>action</code> <code>ndarray</code> <p>action in robot frame ([lin_acc, ang_acc])</p> <code>target_pose</code> <code>ndarray</code> <p>lookahead pose ([pos, orient])</p> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\path_tracker.py</code> Python<pre><code>def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get action from observation.\n\n    Args:\n        obs: observation in world frame ([pos, orient, lin_vel, ang_vel])\n\n    Returns:\n        action: action in robot frame ([lin_acc, ang_acc])\n        target_pose: lookahead pose ([pos, orient])\n    \"\"\"\n    if self.goal is None:\n        return np.zeros(self.action_space.shape), self.goal\n\n    pose, vel, pos, orient, lin_vel, ang_vel = self.get_pose_velocity(obs)\n\n    # Find the lookahead pose\n    target_pose = self._get_lookahead_pose(pos)\n\n    desired_vel = self._get_desired_vel(target_pose, pose)\n    desired_vel = self._stop_if_reached(desired_vel, pose)\n    robot_vel = FrameTransformer.vel_world_to_robot(self.dim, vel, orient)\n    action = self._get_desired_action(desired_vel, robot_vel, orient)\n\n    return action, target_pose\n</code></pre>"},{"location":"api/controller/path_tracker/path_tracker/PathTracker.html#src.python_motion_planning.controller.path_tracker.path_tracker.PathTracker.reset","title":"<code>reset()</code>","text":"<p>Reset the controller to initial state.</p> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\path_tracker.py</code> Python<pre><code>def reset(self):\n    \"\"\"\n    Reset the controller to initial state.\n    \"\"\"\n    super().reset()\n    self.current_target_index = 0\n</code></pre>"},{"location":"api/controller/path_tracker/pid/PID.html","title":"PID","text":""},{"location":"api/controller/path_tracker/pid/PID.html#src.python_motion_planning.controller.path_tracker.pid.PID","title":"<code>src.python_motion_planning.controller.path_tracker.pid.PID</code>","text":"<p>               Bases: <code>PathTracker</code></p> <p>PID-based path-tracking controller.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>Kp</code> <code>float</code> <p>proportional gain</p> <code>1.0</code> <code>Ki</code> <code>float</code> <p>integral gain</p> <code>0.1</code> <code>Kd</code> <code>float</code> <p>derivative gain</p> <code>0.1</code> <code>**kwargs</code> <p>see the parent class.</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\pid.py</code> Python<pre><code>class PID(PathTracker):\n    \"\"\"\n    PID-based path-tracking controller.\n\n    Args:\n        *args: see the parent class.\n        Kp: proportional gain\n        Ki: integral gain\n        Kd: derivative gain\n        **kwargs: see the parent class.\n    \"\"\"\n    def __init__(self,\n                 *args,\n                 Kp: float = 1.0,\n                 Ki: float = 0.1,\n                 Kd: float = 0.1,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n\n        # integral and previous error for PID\n        self.integral_error = np.zeros(self.action_space.shape[0])\n        self.prev_error = np.zeros(self.action_space.shape[0])\n\n    def reset(self):\n        \"\"\"\n        Reset the controller to initial state.\n        \"\"\"\n        super().reset()\n        self.integral_error = np.zeros(self.action_space.shape[0])\n        self.prev_error = np.zeros(self.action_space.shape[0])\n\n    def _get_desired_action(self, desired_vel: np.ndarray, vel: np.ndarray, orient: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the action to be taken using PID control to reach the desired velocity.\n\n        Args:\n            desired_vel: Desired velocity in world frame.\n            vel: Current velocity in world frame.\n            orient: Current orientation in world frame.\n\n        Returns:\n            np.ndarray: Action to be taken ([lin_acc, ang_acc]).\n        \"\"\"\n        # velocity error\n        error = desired_vel - vel\n\n        # PID terms\n        self.integral_error += error * self.dt\n        derivative_error = (error - self.prev_error) / self.dt\n\n        control = (self.Kp * error +\n                   self.Ki * self.integral_error +\n                   self.Kd * derivative_error)\n\n        self.prev_error = error\n\n        action = self.clip_action(control)\n\n        return action\n</code></pre>"},{"location":"api/controller/path_tracker/pid/PID.html#src.python_motion_planning.controller.path_tracker.pid.PID.reset","title":"<code>reset()</code>","text":"<p>Reset the controller to initial state.</p> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\pid.py</code> Python<pre><code>def reset(self):\n    \"\"\"\n    Reset the controller to initial state.\n    \"\"\"\n    super().reset()\n    self.integral_error = np.zeros(self.action_space.shape[0])\n    self.prev_error = np.zeros(self.action_space.shape[0])\n</code></pre>"},{"location":"api/controller/path_tracker/pure_pursuit/PurePursuit.html","title":"PurePursuit","text":""},{"location":"api/controller/path_tracker/pure_pursuit/PurePursuit.html#src.python_motion_planning.controller.path_tracker.pure_pursuit.PurePursuit","title":"<code>src.python_motion_planning.controller.path_tracker.pure_pursuit.PurePursuit</code>","text":"<p>               Bases: <code>PathTracker</code></p> <p>Pure Pursuit path-tracking controller.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>**kwargs</code> <p>see the parent class.</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\controller\\path_tracker\\pure_pursuit.py</code> Python<pre><code>class PurePursuit(PathTracker):\n    \"\"\"\n    Pure Pursuit path-tracking controller.\n\n    Args:\n        *args: see the parent class.\n        **kwargs: see the parent class.\n    \"\"\"\n    def __init__(self,\n                 *args,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def _get_desired_vel(self, target_pose: np.ndarray, cur_pose: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the desired velocity in robot frame using pure pursuit.\n\n        Args:\n            target_pose: target pose in world frame (from lookahead)\n            cur_pose: current pose in world frame\n\n        Returns:\n            desired_vel: desired velocity in robot frame [lin_x, lin_y, ang_z] (for 2D)\n        \"\"\"\n        # transform target pose into robot frame\n        rel_pose = FrameTransformer.pose_world_to_robot(self.dim, target_pose, cur_pose)\n\n        x = rel_pose[0]\n        y = rel_pose[1]\n        L = math.hypot(x, y)\n\n        # if lookahead distance is (nearly) zero, no movement\n        if L &lt; self.eps:\n            desired_vel = np.zeros(self.action_space.shape[0])\n            return self.clip_velocity(desired_vel)\n\n        # Pure Pursuit curvature: kappa = 2*y / L^2\n        # Note: y is lateral offset in robot frame (positive left). For our coordinate,\n        # forward x, lateral y. Angular velocity = kappa * v.\n        kappa = (2.0 * y) / (L * L)\n\n        desired_lin_speed = min(self.max_lin_speed, L / self.dt) * (1.0 if x &gt;= 0 else -1.0)\n        desired_ang_speed = max(min(kappa * desired_lin_speed, self.max_ang_speed), -self.max_ang_speed)\n\n        desired_lin_vel = np.array([desired_lin_speed, 0.0])\n        desired_ang_vel = np.array([desired_ang_speed])\n\n        desired_vel = np.concatenate([desired_lin_vel, desired_ang_vel])\n        desired_vel = self.clip_velocity(desired_vel)\n\n        return desired_vel\n</code></pre>"},{"location":"api/controller/random_controller/RandomController.html","title":"RandomController","text":""},{"location":"api/controller/random_controller/RandomController.html#src.python_motion_planning.controller.random_controller.RandomController","title":"<code>src.python_motion_planning.controller.random_controller.RandomController</code>","text":"<p>               Bases: <code>BaseController</code></p> <p>Random controller</p> Source code in <code>src\\python_motion_planning\\controller\\random_controller.py</code> Python<pre><code>class RandomController(BaseController):\n    \"\"\"\n    Random controller\n    \"\"\"\n    def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, tuple]:\n        \"\"\"\n        Randomly sample action in action space.\n\n        Parameters:\n            obs: observation ([pos, vel, rel_pos_robot1, rel_pos_robot2, ...], each sub-vector length=dim)\n\n        Returns:\n            action: action ([acc], length=dim)\n            target: lookahead point\n        \"\"\"\n        return self.action_space.sample(), self.goal\n</code></pre>"},{"location":"api/controller/random_controller/RandomController.html#src.python_motion_planning.controller.random_controller.RandomController.get_action","title":"<code>get_action(obs)</code>","text":"<p>Randomly sample action in action space.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>ndarray</code> <p>observation ([pos, vel, rel_pos_robot1, rel_pos_robot2, ...], each sub-vector length=dim)</p> required <p>Returns:</p> Name Type Description <code>action</code> <code>ndarray</code> <p>action ([acc], length=dim)</p> <code>target</code> <code>tuple</code> <p>lookahead point</p> Source code in <code>src\\python_motion_planning\\controller\\random_controller.py</code> Python<pre><code>def get_action(self, obs: np.ndarray) -&gt; Tuple[np.ndarray, tuple]:\n    \"\"\"\n    Randomly sample action in action space.\n\n    Parameters:\n        obs: observation ([pos, vel, rel_pos_robot1, rel_pos_robot2, ...], each sub-vector length=dim)\n\n    Returns:\n        action: action ([acc], length=dim)\n        target: lookahead point\n    \"\"\"\n    return self.action_space.sample(), self.goal\n</code></pre>"},{"location":"api/curve_generator/bezier_curve/Bezier.html","title":"Bezier","text":""},{"location":"api/curve_generator/bezier_curve/Bezier.html#src.python_motion_planning.curve_generator.bezier_curve.Bezier","title":"<code>src.python_motion_planning.curve_generator.bezier_curve.Bezier</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Bezier curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>offset</code> <code>float</code> <p>The offset of control points</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import Bezier\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = Bezier(step, offset)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generator\\bezier_curve.py</code> Python<pre><code>class Bezier(Curve):\n\t\"\"\"\n\tClass for Bezier curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\toffset (float): The offset of control points\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import Bezier\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = Bezier(step, offset)\n\t\t&gt;&gt;&gt; generator.run(points)\n\t\"\"\"\n\tdef __init__(self, step: float, offset: float) -&gt; None:\n\t\tsuper().__init__(step)\n\t\tself.offset = offset\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Bezier Curve\"\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the Bezier Curve.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tx_list (list): x of the trajectory\n\t\t\ty_list (list): y of the trajectory\n\t\t\tyaw_list (list): yaw of the trajectory\n\t\t\"\"\"\n\t\tsx, sy, _ = start_pose\n\t\tgx, gy, _ = goal_pose\n\t\tn_points = int(np.hypot(sx - gx, sy - gy) / self.step)\n\t\tcontrol_points = self.getControlPoints(start_pose, goal_pose)\n\n\t\treturn [self.bezier(t, control_points) for t in np.linspace(0, 1, n_points)], \\\n\t\t\t   control_points\n\n\tdef bezier(self, t: float, control_points: list) -&gt;np.ndarray:\n\t\t\"\"\"\n\t\tCalculate the Bezier curve point.\n\n\t\tParameters:\n\t\t\tt (float): scale factor\n\t\t\tcontrol_points (list[tuple]): control points\n\n\t\tReturns:\n\t\t\tpoint (np.array): point in Bezier curve with t\n\t\t\"\"\"\n\t\tn = len(control_points) - 1\n\t\tcontrol_points = np.array(control_points)\n\t\treturn np.sum([comb(n, i) * t ** i * (1 - t) ** (n - i) *\n\t\t\tcontrol_points[i] for i in range(n + 1)], axis=0)\n\n\tdef getControlPoints(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tCalculate control points heuristically.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tcontrol_points (list[tuple]): Control points\n\t\t\"\"\"\n\t\tsx, sy, syaw = start_pose\n\t\tgx, gy, gyaw = goal_pose\n\n\t\tdist = np.hypot(sx - gx, sy - gy) / self.offset\n\t\treturn [(sx, sy),\n\t\t\t\t(sx + dist * np.cos(syaw), sy + dist * np.sin(syaw)),\n\t\t\t\t(gx - dist * np.cos(gyaw), gy - dist * np.sin(gyaw)),\n\t\t\t\t(gx, gy)]\n</code></pre>"},{"location":"api/curve_generator/bezier_curve/Bezier.html#src.python_motion_planning.curve_generator.bezier_curve.Bezier.bezier","title":"<code>bezier(t, control_points)</code>","text":"<p>Calculate the Bezier curve point.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>scale factor</p> required <code>control_points</code> <code>list[tuple]</code> <p>control points</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>array</code> <p>point in Bezier curve with t</p> Source code in <code>src\\python_motion_planning\\curve_generator\\bezier_curve.py</code> Python<pre><code>def bezier(self, t: float, control_points: list) -&gt;np.ndarray:\n\t\"\"\"\n\tCalculate the Bezier curve point.\n\n\tParameters:\n\t\tt (float): scale factor\n\t\tcontrol_points (list[tuple]): control points\n\n\tReturns:\n\t\tpoint (np.array): point in Bezier curve with t\n\t\"\"\"\n\tn = len(control_points) - 1\n\tcontrol_points = np.array(control_points)\n\treturn np.sum([comb(n, i) * t ** i * (1 - t) ** (n - i) *\n\t\tcontrol_points[i] for i in range(n + 1)], axis=0)\n</code></pre>"},{"location":"api/curve_generator/bezier_curve/Bezier.html#src.python_motion_planning.curve_generator.bezier_curve.Bezier.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the Bezier Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>x_list</code> <code>list</code> <p>x of the trajectory</p> <code>y_list</code> <code>list</code> <p>y of the trajectory</p> <code>yaw_list</code> <code>list</code> <p>yaw of the trajectory</p> Source code in <code>src\\python_motion_planning\\curve_generator\\bezier_curve.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the Bezier Curve.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tx_list (list): x of the trajectory\n\t\ty_list (list): y of the trajectory\n\t\tyaw_list (list): yaw of the trajectory\n\t\"\"\"\n\tsx, sy, _ = start_pose\n\tgx, gy, _ = goal_pose\n\tn_points = int(np.hypot(sx - gx, sy - gy) / self.step)\n\tcontrol_points = self.getControlPoints(start_pose, goal_pose)\n\n\treturn [self.bezier(t, control_points) for t in np.linspace(0, 1, n_points)], \\\n\t\t   control_points\n</code></pre>"},{"location":"api/curve_generator/bezier_curve/Bezier.html#src.python_motion_planning.curve_generator.bezier_curve.Bezier.getControlPoints","title":"<code>getControlPoints(start_pose, goal_pose)</code>","text":"<p>Calculate control points heuristically.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>control_points</code> <code>list[tuple]</code> <p>Control points</p> Source code in <code>src\\python_motion_planning\\curve_generator\\bezier_curve.py</code> Python<pre><code>def getControlPoints(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tCalculate control points heuristically.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tcontrol_points (list[tuple]): Control points\n\t\"\"\"\n\tsx, sy, syaw = start_pose\n\tgx, gy, gyaw = goal_pose\n\n\tdist = np.hypot(sx - gx, sy - gy) / self.offset\n\treturn [(sx, sy),\n\t\t\t(sx + dist * np.cos(syaw), sy + dist * np.sin(syaw)),\n\t\t\t(gx - dist * np.cos(gyaw), gy - dist * np.sin(gyaw)),\n\t\t\t(gx, gy)]\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html","title":"BSpline","text":""},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline","title":"<code>src.python_motion_planning.curve_generator.bspline_curve.BSpline</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for B-Spline curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>k</code> <code>int</code> <p>Degree of curve</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import BSpline\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = BSpline(step, k)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>class BSpline(Curve):\n    \"\"\"\n    Class for B-Spline curve generation.\n\n    Parameters:\n        step (float): Simulation or interpolation size\n        k (int): Degree of curve\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.curve_generation import BSpline\n        &gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n        &gt;&gt;&gt; generator = BSpline(step, k)\n        &gt;&gt;&gt; generator.run(points)\n    \"\"\"\n    def __init__(self, step: float, k: int, param_mode: str=\"centripetal\", \n                 spline_mode: str=\"interpolation\") -&gt; None:\n        super().__init__(step)\n        self.k = k\n\n        assert param_mode == \"centripetal\" or param_mode == \"chord_length\" \\\n               or param_mode == \"uniform_spaced\", \"Parameter selection mode error!\"\n        self.param_mode = param_mode\n\n        assert spline_mode == \"interpolation\" or spline_mode == \"approximation\", \\\n               \"Spline mode selection error!\"\n        self.spline_mode = spline_mode\n\n    def __str__(self) -&gt; str:\n        return \"B-Spline Curve\"\n\n    def baseFunction(self, i: int, k: int, t: float, knot: list):\n        \"\"\"\n        Calculate base function using Cox-deBoor function.\n\n        Parameters:\n            i (int): The index of base function\n            k (int): The degree of curve\n            t (float): parameter\n            knot (list[float]): knot vector\n\n        Returns:\n            Nik_t (float): The value of base function Nik(t)\n        \"\"\"\n        Nik_t = 0\n        if k == 0:\n            Nik_t = 1.0 if t &gt;= knot[i] and t &lt; knot[i + 1] else 0.0\n        else:\n            length1 = knot[i + k] - knot[i]\n            length2 = knot[i + k + 1] - knot[i + 1]\n            if not length1 and not length2:\n                Nik_t = 0\n            elif not length1:\n                Nik_t = (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n            elif not length2:\n                Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot)\n            else:\n                Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot) + \\\n                        (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n        return Nik_t\n\n    def paramSelection(self, points: list):\n        \"\"\"\n        Calculate parameters using the `uniform spaced` or `chrod length`\n        or `centripetal` method.\n\n        Parameters:\n            points (list[tuple]): path points\n\n\t\tReturns:\n\t\t    Parameters (list[float]): The parameters of given points\n        \"\"\"\n        n = len(points)\n        x_list = [pt[0] for pt in points]\n        y_list = [pt[1] for pt in points]\n        dx, dy = np.diff(x_list), np.diff(y_list)\n\n        if self.param_mode == \"uniform_spaced\":\n            return np.linspace(0, 1, n).tolist()\n\n        elif self.param_mode == \"chord_length\":\n            parameters = np.zeros(n)\n            s = np.cumsum([math.hypot(idx, idy) for (idx, idy) in zip(dx, dy)])\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n\n        elif self.param_mode == \"centripetal\":\n            alpha = 0.5\n            s = np.cumsum([math.pow(math.hypot(idx, idy), alpha) for (idx, idy) in zip(dx, dy)])\n            parameters = np.zeros(n)\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n\n    def knotGeneration(self, param: list, n: int):\n        \"\"\"\n        Generate knot vector.\n\n        Parameters:\n            param (list[float]): The parameters of given points\n            n (int): The number of data points\n\n\t\tReturns:\n\t\t    knot (list[float]): The knot vector\n        \"\"\"\n        m = n + self.k + 1\n        knot = np.zeros(m)\n        for i in range(self.k + 1):\n            knot[i] = 0\n        for i in range(n, m):\n            knot[i] = 1\n        for i in range(self.k + 1, n):\n            for j in range(i - self.k, i):\n                knot[i] = knot[i] + param[j]\n            knot[i] = knot[i] / self.k\n        return knot.tolist()\n\n    def interpolation(self, points: list, param: list, knot: list):\n        \"\"\"\n        Given a set of N data points, D0, D1, ..., Dn and a degree k,\n        find a B-spline curve of degree k defined by N control points\n        that passes all data points in the given order.\n\n        Parameters:\n            points (list[tuple]): path points\n            param (list[float]): The parameters of given points\n            knot (list[float]): The knot vector\n\n        Returns:\n            control_points (np.ndarray): The control points\n        \"\"\"\n        n = len(points)\n        N = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(n):\n                N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n        N[n-1][n-1] = 1\n        N_inv = np.linalg.inv(N)\n\n        D = np.array(points)\n\n        return N_inv @ D\n\n    def approximation(self, points: list, param: list, knot: list):\n        \"\"\"\n        Given a set of N data points, D0, D1, ..., Dn, a degree k,\n        and a number H, where N &gt; H &gt; k &gt;= 1, find a B-spline curve\n        of degree k defined by H control points that satisfies the\n        following conditions:\n            1. this curve contains the first and last data points;\n            2. this curve approximates the data polygon in the sense\n            of least square\n\n        Parameters:\n            points (list[tuple]): path points\n            param (list[float]): The parameters of given points\n            knot (list[float]): The knot vector\n\n\t\tReturns:\n\t\t    control_points (np.ndarray): The control points\n        \"\"\"\n        n = len(points)\n        D = np.array(points)\n\n        # heuristically setting the number of control points\n        h = n - 1\n\n        N = np.zeros((n, h))\n        for i in range(n):\n            for j in range(h):\n                N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n        N_ = N[1 : n - 1, 1 : h - 1]\n\n        qk = np.zeros((n - 2, 2))\n        for i in range(1, n - 1):\n            qk[i - 1] = D[i, :] - N[i][0] * D[0, :] - N[i][h - 1] * D[-1, :]\n        Q = N_.T @ qk\n\n        P = np.linalg.inv(N_.T @ N_) @ Q\n        P = np.insert(P, 0, D[0, :], axis=0)\n        P = np.insert(P, len(P), D[-1, :], axis=0)\n\n        return P\n\n    def generation(self, t, k, knot, control_pts):\n        \"\"\"\n        Generate the B-spline curve.\n\n        Parameters:\n            t (np.ndarray): The parameter values\n            k (int): The degree of the B-spline curve\n            knot (list[float]): The knot vector\n            control_pts (np.ndarray): The control points\n\n        Returns:\n            curve (np.ndarray): The B-spline curve\n        \"\"\"\n        N = np.zeros((len(t), len(control_pts)))\n\n        for i in range(len(t)):\n            for j in range(len(control_pts)):\n                N[i][j] = self.baseFunction(j, k, t[i], knot)\n        N[len(t) - 1][len(control_pts) - 1] = 1\n\n        return N @ control_pts\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline.approximation","title":"<code>approximation(points, param, knot)</code>","text":"<p>Given a set of N data points, D0, D1, ..., Dn, a degree k, and a number H, where N &gt; H &gt; k &gt;= 1, find a B-spline curve of degree k defined by H control points that satisfies the following conditions:     1. this curve contains the first and last data points;     2. this curve approximates the data polygon in the sense     of least square</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required <code>param</code> <code>list[float]</code> <p>The parameters of given points</p> required <code>knot</code> <code>list[float]</code> <p>The knot vector</p> <p>Returns:     control_points (np.ndarray): The control points</p> required Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>    def approximation(self, points: list, param: list, knot: list):\n        \"\"\"\n        Given a set of N data points, D0, D1, ..., Dn, a degree k,\n        and a number H, where N &gt; H &gt; k &gt;= 1, find a B-spline curve\n        of degree k defined by H control points that satisfies the\n        following conditions:\n            1. this curve contains the first and last data points;\n            2. this curve approximates the data polygon in the sense\n            of least square\n\n        Parameters:\n            points (list[tuple]): path points\n            param (list[float]): The parameters of given points\n            knot (list[float]): The knot vector\n\n\t\tReturns:\n\t\t    control_points (np.ndarray): The control points\n        \"\"\"\n        n = len(points)\n        D = np.array(points)\n\n        # heuristically setting the number of control points\n        h = n - 1\n\n        N = np.zeros((n, h))\n        for i in range(n):\n            for j in range(h):\n                N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n        N_ = N[1 : n - 1, 1 : h - 1]\n\n        qk = np.zeros((n - 2, 2))\n        for i in range(1, n - 1):\n            qk[i - 1] = D[i, :] - N[i][0] * D[0, :] - N[i][h - 1] * D[-1, :]\n        Q = N_.T @ qk\n\n        P = np.linalg.inv(N_.T @ N_) @ Q\n        P = np.insert(P, 0, D[0, :], axis=0)\n        P = np.insert(P, len(P), D[-1, :], axis=0)\n\n        return P\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline.baseFunction","title":"<code>baseFunction(i, k, t, knot)</code>","text":"<p>Calculate base function using Cox-deBoor function.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of base function</p> required <code>k</code> <code>int</code> <p>The degree of curve</p> required <code>t</code> <code>float</code> <p>parameter</p> required <code>knot</code> <code>list[float]</code> <p>knot vector</p> required <p>Returns:</p> Name Type Description <code>Nik_t</code> <code>float</code> <p>The value of base function Nik(t)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>def baseFunction(self, i: int, k: int, t: float, knot: list):\n    \"\"\"\n    Calculate base function using Cox-deBoor function.\n\n    Parameters:\n        i (int): The index of base function\n        k (int): The degree of curve\n        t (float): parameter\n        knot (list[float]): knot vector\n\n    Returns:\n        Nik_t (float): The value of base function Nik(t)\n    \"\"\"\n    Nik_t = 0\n    if k == 0:\n        Nik_t = 1.0 if t &gt;= knot[i] and t &lt; knot[i + 1] else 0.0\n    else:\n        length1 = knot[i + k] - knot[i]\n        length2 = knot[i + k + 1] - knot[i + 1]\n        if not length1 and not length2:\n            Nik_t = 0\n        elif not length1:\n            Nik_t = (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n        elif not length2:\n            Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot)\n        else:\n            Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot) + \\\n                    (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n    return Nik_t\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline.generation","title":"<code>generation(t, k, knot, control_pts)</code>","text":"<p>Generate the B-spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>The parameter values</p> required <code>k</code> <code>int</code> <p>The degree of the B-spline curve</p> required <code>knot</code> <code>list[float]</code> <p>The knot vector</p> required <code>control_pts</code> <code>ndarray</code> <p>The control points</p> required <p>Returns:</p> Name Type Description <code>curve</code> <code>ndarray</code> <p>The B-spline curve</p> Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>def generation(self, t, k, knot, control_pts):\n    \"\"\"\n    Generate the B-spline curve.\n\n    Parameters:\n        t (np.ndarray): The parameter values\n        k (int): The degree of the B-spline curve\n        knot (list[float]): The knot vector\n        control_pts (np.ndarray): The control points\n\n    Returns:\n        curve (np.ndarray): The B-spline curve\n    \"\"\"\n    N = np.zeros((len(t), len(control_pts)))\n\n    for i in range(len(t)):\n        for j in range(len(control_pts)):\n            N[i][j] = self.baseFunction(j, k, t[i], knot)\n    N[len(t) - 1][len(control_pts) - 1] = 1\n\n    return N @ control_pts\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline.interpolation","title":"<code>interpolation(points, param, knot)</code>","text":"<p>Given a set of N data points, D0, D1, ..., Dn and a degree k, find a B-spline curve of degree k defined by N control points that passes all data points in the given order.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required <code>param</code> <code>list[float]</code> <p>The parameters of given points</p> required <code>knot</code> <code>list[float]</code> <p>The knot vector</p> required <p>Returns:</p> Name Type Description <code>control_points</code> <code>ndarray</code> <p>The control points</p> Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>def interpolation(self, points: list, param: list, knot: list):\n    \"\"\"\n    Given a set of N data points, D0, D1, ..., Dn and a degree k,\n    find a B-spline curve of degree k defined by N control points\n    that passes all data points in the given order.\n\n    Parameters:\n        points (list[tuple]): path points\n        param (list[float]): The parameters of given points\n        knot (list[float]): The knot vector\n\n    Returns:\n        control_points (np.ndarray): The control points\n    \"\"\"\n    n = len(points)\n    N = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n    N[n-1][n-1] = 1\n    N_inv = np.linalg.inv(N)\n\n    D = np.array(points)\n\n    return N_inv @ D\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline.knotGeneration","title":"<code>knotGeneration(param, n)</code>","text":"<p>Generate knot vector.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>list[float]</code> <p>The parameters of given points</p> required <code>n</code> <code>int</code> <p>The number of data points</p> <p>Returns:     knot (list[float]): The knot vector</p> required Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>    def knotGeneration(self, param: list, n: int):\n        \"\"\"\n        Generate knot vector.\n\n        Parameters:\n            param (list[float]): The parameters of given points\n            n (int): The number of data points\n\n\t\tReturns:\n\t\t    knot (list[float]): The knot vector\n        \"\"\"\n        m = n + self.k + 1\n        knot = np.zeros(m)\n        for i in range(self.k + 1):\n            knot[i] = 0\n        for i in range(n, m):\n            knot[i] = 1\n        for i in range(self.k + 1, n):\n            for j in range(i - self.k, i):\n                knot[i] = knot[i] + param[j]\n            knot[i] = knot[i] / self.k\n        return knot.tolist()\n</code></pre>"},{"location":"api/curve_generator/bspline_curve/BSpline.html#src.python_motion_planning.curve_generator.bspline_curve.BSpline.paramSelection","title":"<code>paramSelection(points)</code>","text":"<p>Calculate parameters using the <code>uniform spaced</code> or <code>chrod length</code> or <code>centripetal</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> <p>Returns:     Parameters (list[float]): The parameters of given points</p> required Source code in <code>src\\python_motion_planning\\curve_generator\\bspline_curve.py</code> Python<pre><code>    def paramSelection(self, points: list):\n        \"\"\"\n        Calculate parameters using the `uniform spaced` or `chrod length`\n        or `centripetal` method.\n\n        Parameters:\n            points (list[tuple]): path points\n\n\t\tReturns:\n\t\t    Parameters (list[float]): The parameters of given points\n        \"\"\"\n        n = len(points)\n        x_list = [pt[0] for pt in points]\n        y_list = [pt[1] for pt in points]\n        dx, dy = np.diff(x_list), np.diff(y_list)\n\n        if self.param_mode == \"uniform_spaced\":\n            return np.linspace(0, 1, n).tolist()\n\n        elif self.param_mode == \"chord_length\":\n            parameters = np.zeros(n)\n            s = np.cumsum([math.hypot(idx, idy) for (idx, idy) in zip(dx, dy)])\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n\n        elif self.param_mode == \"centripetal\":\n            alpha = 0.5\n            s = np.cumsum([math.pow(math.hypot(idx, idy), alpha) for (idx, idy) in zip(dx, dy)])\n            parameters = np.zeros(n)\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n</code></pre>"},{"location":"api/curve_generator/cubic_spline/CubicSpline.html","title":"CubicSpline","text":""},{"location":"api/curve_generator/cubic_spline/CubicSpline.html#src.python_motion_planning.curve_generator.cubic_spline.CubicSpline","title":"<code>src.python_motion_planning.curve_generator.cubic_spline.CubicSpline</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for cubic spline generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import CubicSpline\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = CubicSpline(step)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generator\\cubic_spline.py</code> Python<pre><code>class CubicSpline(Curve):\n\t\"\"\"\n\tClass for cubic spline generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import CubicSpline\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = CubicSpline(step)\n\t\t&gt;&gt;&gt; generator.run(points)\n\t\"\"\"\n\tdef __init__(self, step: float) -&gt; None:\n\t\tsuper().__init__(step)\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Cubic Spline\"\n\n\tdef spline(self, x_list: list, y_list: list, t: list):\n\t\t\"\"\"\n\t\tRunning both generation and animation.\n\n\t\tParameters:\n\t\t\tx_list (list[tuple]): path points x-direction\n\t\t\ty_list (list[tuple]): path points y-direction\n\t\t\tt (list): parameter\n\n\t\tReturns:\n\t\t\tp (list): The (x, y) of curve with given t\n\t\t\tdp (list): The derivative (dx, dy) of curve with given t\n\t\t\"\"\"\n\t\t# cubic polynomial functions\n\t\ta, b, c, d = y_list, [], [], []\n\t\th = np.diff(x_list)\n\t\tnum = len(x_list)\n\n\t\t# calculate coefficient matrix\n\t\tA = np.zeros((num, num))\n\t\tfor i in range(1, num - 1):\n\t\t\tA[i, i - 1] = h[i - 1]\n\t\t\tA[i, i] = 2.0 * (h[i - 1] + h[i])\n\t\t\tA[i, i + 1] = h[i]\n\t\tA[0, 0] = 1.0\n\t\tA[num - 1, num - 1] = 1.0\n\n\t\tB = np.zeros(num)\n\t\tfor i in range(1, num - 1):\n\t\t\tB[i] = 3.0 * (a[i + 1] - a[i]) / h[i] - \\\n\t\t\t\t\t3.0 * (a[i] - a[i - 1]) / h[i - 1]\n\n\t\tc = np.linalg.solve(A, B)\n\t\tfor i in range(num - 1):\n\t\t\td.append((c[i + 1] - c[i]) / (3.0 * h[i]))\n\t\t\tb.append((a[i + 1] - a[i]) / h[i] - h[i] * (c[i + 1] + 2.0 * c[i]) / 3.0)\n\n\t\t# calculate spline value and its derivative\n\t\tp, dp = [], []\n\t\tfor it in t:\n\t\t\tif it &lt; x_list[0] or it &gt; x_list[-1]:\n\t\t\t\tcontinue\n\t\t\ti = bisect.bisect(x_list, it) - 1\n\t\t\tdx = it - x_list[i]\n\t\t\tp.append(a[i] + b[i] * dx + c[i] * dx**2 + d[i] * dx**3)\n\t\t\tdp.append(b[i] + 2.0 * c[i] * dx + 3.0 * d[i] * dx**2)\n\n\t\treturn p, dp\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\tpass\n</code></pre>"},{"location":"api/curve_generator/cubic_spline/CubicSpline.html#src.python_motion_planning.curve_generator.cubic_spline.CubicSpline.spline","title":"<code>spline(x_list, y_list, t)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>x_list</code> <code>list[tuple]</code> <p>path points x-direction</p> required <code>y_list</code> <code>list[tuple]</code> <p>path points y-direction</p> required <code>t</code> <code>list</code> <p>parameter</p> required <p>Returns:</p> Name Type Description <code>p</code> <code>list</code> <p>The (x, y) of curve with given t</p> <code>dp</code> <code>list</code> <p>The derivative (dx, dy) of curve with given t</p> Source code in <code>src\\python_motion_planning\\curve_generator\\cubic_spline.py</code> Python<pre><code>def spline(self, x_list: list, y_list: list, t: list):\n\t\"\"\"\n\tRunning both generation and animation.\n\n\tParameters:\n\t\tx_list (list[tuple]): path points x-direction\n\t\ty_list (list[tuple]): path points y-direction\n\t\tt (list): parameter\n\n\tReturns:\n\t\tp (list): The (x, y) of curve with given t\n\t\tdp (list): The derivative (dx, dy) of curve with given t\n\t\"\"\"\n\t# cubic polynomial functions\n\ta, b, c, d = y_list, [], [], []\n\th = np.diff(x_list)\n\tnum = len(x_list)\n\n\t# calculate coefficient matrix\n\tA = np.zeros((num, num))\n\tfor i in range(1, num - 1):\n\t\tA[i, i - 1] = h[i - 1]\n\t\tA[i, i] = 2.0 * (h[i - 1] + h[i])\n\t\tA[i, i + 1] = h[i]\n\tA[0, 0] = 1.0\n\tA[num - 1, num - 1] = 1.0\n\n\tB = np.zeros(num)\n\tfor i in range(1, num - 1):\n\t\tB[i] = 3.0 * (a[i + 1] - a[i]) / h[i] - \\\n\t\t\t\t3.0 * (a[i] - a[i - 1]) / h[i - 1]\n\n\tc = np.linalg.solve(A, B)\n\tfor i in range(num - 1):\n\t\td.append((c[i + 1] - c[i]) / (3.0 * h[i]))\n\t\tb.append((a[i + 1] - a[i]) / h[i] - h[i] * (c[i + 1] + 2.0 * c[i]) / 3.0)\n\n\t# calculate spline value and its derivative\n\tp, dp = [], []\n\tfor it in t:\n\t\tif it &lt; x_list[0] or it &gt; x_list[-1]:\n\t\t\tcontinue\n\t\ti = bisect.bisect(x_list, it) - 1\n\t\tdx = it - x_list[i]\n\t\tp.append(a[i] + b[i] * dx + c[i] * dx**2 + d[i] * dx**3)\n\t\tdp.append(b[i] + 2.0 * c[i] * dx + 3.0 * d[i] * dx**2)\n\n\treturn p, dp\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html","title":"Curve","text":""},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve","title":"<code>src.python_motion_planning.curve_generator.curve.Curve</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>class Curve(ABC):\n\tdef __init__(self, step: float) -&gt; None:\n\t\t\"\"\"\n\t\tBase class for curve generation.\n\n\t\tParameters:\n\t\t\tstep (float): Simulation or interpolation size\n\t\t\"\"\"\n\t\tself.step = step\n\n\t@abstractmethod\n\tdef run(self, points: list):\n\t\t\"\"\"\n        Running both generation and animation.\n        \"\"\"\n\t\tpass\n\n\t@abstractmethod\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the curve.\n\t\t\"\"\"\n\t\tpass\n\n\tdef trigonometric(self, alpha: float, beta: float):\n\t\t\"\"\"\n\t\tCalculate some useful trigonometric value with angles.\n\t\t\"\"\"\n\t\treturn math.sin(alpha), math.sin(beta), math.cos(alpha), math.cos(beta), \\\n\t\t\tmath.sin(alpha - beta), math.cos(alpha - beta)\n\n\tdef pi2pi(self, theta: float) -&gt; float:\n\t\t\"\"\"\n\t\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\t\t\"\"\"\n\t\twhile theta &gt; math.pi:\n\t\t\ttheta -= 2.0 * math.pi\n\t\twhile theta &lt; -math.pi:\n\t\t\ttheta += 2.0 * math.pi\n\t\treturn theta\n\n\tdef mod2pi(self, theta: float) -&gt; float:\n\t\t\"\"\"\n\t\tPerform modulus operation on 2\u03c0.\n\t\t\"\"\"\n\t\treturn theta - 2.0 * math.pi * math.floor(theta / math.pi / 2.0)\n\n\tdef length(self, path: list) -&gt; float:\n\t\t\"\"\"\n\t\tCalculate path or trajectory length with `path` format [(ix, iy)] (i from 0 to N)\n\t\t\"\"\"\n\t\tdist = 0\n\t\tfor i in range(len(path) - 1):\n\t\t\tdist = dist + math.hypot(path[i + 1][0] - path[i][0], path[i + 1][1] - path[i][1])\n\t\treturn dist\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.__init__","title":"<code>__init__(step)</code>","text":"<p>Base class for curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>def __init__(self, step: float) -&gt; None:\n\t\"\"\"\n\tBase class for curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\"\"\"\n\tself.step = step\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.generation","title":"<code>generation(start_pose, goal_pose)</code>  <code>abstractmethod</code>","text":"<p>Generate the curve.</p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>@abstractmethod\ndef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the curve.\n\t\"\"\"\n\tpass\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.length","title":"<code>length(path)</code>","text":"<p>Calculate path or trajectory length with <code>path</code> format [(ix, iy)] (i from 0 to N)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>def length(self, path: list) -&gt; float:\n\t\"\"\"\n\tCalculate path or trajectory length with `path` format [(ix, iy)] (i from 0 to N)\n\t\"\"\"\n\tdist = 0\n\tfor i in range(len(path) - 1):\n\t\tdist = dist + math.hypot(path[i + 1][0] - path[i][0], path[i + 1][1] - path[i][1])\n\treturn dist\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.mod2pi","title":"<code>mod2pi(theta)</code>","text":"<p>Perform modulus operation on 2\u03c0.</p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>def mod2pi(self, theta: float) -&gt; float:\n\t\"\"\"\n\tPerform modulus operation on 2\u03c0.\n\t\"\"\"\n\treturn theta - 2.0 * math.pi * math.floor(theta / math.pi / 2.0)\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.pi2pi","title":"<code>pi2pi(theta)</code>","text":"<p>Truncate the angle to the interval of -\u03c0 to \u03c0.</p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>def pi2pi(self, theta: float) -&gt; float:\n\t\"\"\"\n\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\t\"\"\"\n\twhile theta &gt; math.pi:\n\t\ttheta -= 2.0 * math.pi\n\twhile theta &lt; -math.pi:\n\t\ttheta += 2.0 * math.pi\n\treturn theta\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.run","title":"<code>run(points)</code>  <code>abstractmethod</code>","text":"<p>Running both generation and animation.</p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>\t@abstractmethod\n\tdef run(self, points: list):\n\t\t\"\"\"\n        Running both generation and animation.\n        \"\"\"\n\t\tpass\n</code></pre>"},{"location":"api/curve_generator/curve/Curve.html#src.python_motion_planning.curve_generator.curve.Curve.trigonometric","title":"<code>trigonometric(alpha, beta)</code>","text":"<p>Calculate some useful trigonometric value with angles.</p> Source code in <code>src\\python_motion_planning\\curve_generator\\curve.py</code> Python<pre><code>def trigonometric(self, alpha: float, beta: float):\n\t\"\"\"\n\tCalculate some useful trigonometric value with angles.\n\t\"\"\"\n\treturn math.sin(alpha), math.sin(beta), math.cos(alpha), math.cos(beta), \\\n\t\tmath.sin(alpha - beta), math.cos(alpha - beta)\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html","title":"Dubins","text":""},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins","title":"<code>src.python_motion_planning.curve_generator.dubins_curve.Dubins</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Dubins curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>max_curv</code> <code>float</code> <p>The maximum curvature of the curve</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import Dubins\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = Dubins(step, max_curv)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> References <p>[1] On curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>class Dubins(Curve):\n\t\"\"\"\n\tClass for Dubins curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\tmax_curv (float): The maximum curvature of the curve\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import Dubins\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = Dubins(step, max_curv)\n\t\t&gt;&gt;&gt; generator.run(points)\n\n\tReferences:\n\t\t[1] On curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents\n\t\"\"\"\n\tdef __init__(self, step: float, max_curv: float) -&gt; None:\n\t\tsuper().__init__(step)\n\t\tself.max_curv = max_curv\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Dubins Curve\"\n\n\tdef LSL(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Left generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_lsl = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_a - sin_b)\n\t\tif p_lsl &lt; 0:\n\t\t\treturn None, None, None, [\"L\", \"S\", \"L\"]\n\t\telse:\n\t\t\tp_lsl = math.sqrt(p_lsl)\n\n\t\tt_lsl = self.mod2pi(-alpha + math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\t\tq_lsl = self.mod2pi(beta - math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\n\t\treturn t_lsl, p_lsl, q_lsl, [\"L\", \"S\", \"L\"]\n\n\tdef RSR(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tRight-Straight-Right generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_rsr = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_b - sin_a)\n\t\tif p_rsr &lt; 0:\n\t\t\treturn None, None, None, [\"R\", \"S\", \"R\"]\n\t\telse:\n\t\t\tp_rsr = math.sqrt(p_rsr)\n\n\t\tt_rsr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\t\tq_rsr = self.mod2pi(-beta + math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\n\t\treturn t_rsr, p_rsr, q_rsr, [\"R\", \"S\", \"R\"]\n\n\tdef LSR(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Right generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_lsr = -2 + dist ** 2 + 2 * cos_a_b + 2 * dist * (sin_a + sin_b)\n\t\tif p_lsr &lt; 0:\n\t\t\treturn None, None, None, [\"L\", \"S\", \"R\"]\n\t\telse:\n\t\t\tp_lsr = math.sqrt(p_lsr)\n\n\t\tt_lsr = self.mod2pi(-alpha + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\t\tq_lsr = self.mod2pi(-beta + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\n\t\treturn t_lsr, p_lsr, q_lsr, [\"L\", \"S\", \"R\"]\n\n\n\tdef RSL(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tRight-Straight-Left generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_rsl = -2 + dist ** 2 + 2 * cos_a_b - 2 * dist * (sin_a + sin_b)\n\t\tif p_rsl &lt; 0:\n\t\t\treturn None, None, None, [\"R\", \"S\", \"L\"]\n\t\telse:\n\t\t\tp_rsl = math.sqrt(p_rsl)\n\n\t\tt_rsl = self.mod2pi(alpha - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\t\tq_rsl = self.mod2pi(beta - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\n\t\treturn t_rsl, p_rsl, q_rsl, [\"R\", \"S\", \"L\"]\n\n\n\tdef RLR(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tRight-Left-Right generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_rlr = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\t\tif abs(p_rlr) &gt; 1.0:\n\t\t\treturn None, None, None, [\"R\", \"L\", \"R\"]\n\t\telse:\n\t\t\tp_rlr = self.mod2pi(2 * math.pi - math.acos(p_rlr))\n\n\t\tt_rlr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b) + p_rlr / 2.0)\n\t\tq_rlr = self.mod2pi(alpha - beta - t_rlr + p_rlr)\n\n\t\treturn t_rlr, p_rlr, q_rlr, [\"R\", \"L\", \"R\"]\n\n\tdef LRL(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tLeft-Right-Left generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_lrl = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\t\tif abs(p_lrl) &gt; 1.0:\n\t\t\treturn None, None, None, [\"L\", \"R\", \"L\"]\n\t\telse:\n\t\t\tp_lrl = self.mod2pi(2 * math.pi - math.acos(p_lrl))\n\n\t\tt_lrl = self.mod2pi(-alpha + math.atan2(-cos_a + cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)\n\t\tq_lrl = self.mod2pi(beta - alpha - t_lrl + p_lrl)\n\n\t\treturn t_lrl, p_lrl, q_lrl, [\"L\", \"R\", \"L\"]    \n\n\tdef interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\t\"\"\"\n\t\tPlanning path interpolation.\n\n\t\tParameters:\n\t\t\tmode (str): motion, e.g., L, S, R\n\t\t\tlength (float): Single step motion path length\n\t\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\t\"\"\"\n\t\tx, y, yaw = init_pose\n\n\t\tif mode == \"S\":\n\t\t\tnew_x   = x + length / self.max_curv * math.cos(yaw)\n\t\t\tnew_y   = y + length / self.max_curv * math.sin(yaw)\n\t\t\tnew_yaw = yaw\n\t\telif mode == \"L\":\n\t\t\tnew_x   = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y   = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw + length\n\t\telif mode == \"R\":\n\t\t\tnew_x   = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y   = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw - length\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\treturn new_x, new_y, new_yaw\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the Dubins Curve.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tbest_cost (float): Best planning path length\n\t\t\tbest_mode (list): Best motion modes\n\t\t\tx_list (list): Trajectory of x\n\t\t\ty_list (list): Trajectory of y\n\t\t\tyaw_list (list): Trajectory of yaw\n\t\t\"\"\"\n\t\tsx, sy, syaw = start_pose\n\t\tgx, gy, gyaw = goal_pose\n\n\t\t# coordinate transformation\n\t\tgx, gy = gx - sx, gy - sy\n\t\ttheta = self.mod2pi(math.atan2(gy, gx))\n\t\tdist = math.hypot(gx, gy) * self.max_curv\n\t\talpha = self.mod2pi(syaw - theta)\n\t\tbeta = self.mod2pi(gyaw - theta)\n\n\t\t# select the best motion\n\t\tplanners = [self.LSL, self.RSR, self.LSR, self.RSL, self.RLR, self.LRL]\n\t\tbest_t, best_p, best_q, best_mode, best_cost = None, None, None, None, float(\"inf\")\n\n\t\tfor planner in planners:\n\t\t\tt, p, q, mode = planner(alpha, beta, dist)\n\t\t\tif t is None:\n\t\t\t\tcontinue\n\t\t\tcost = (abs(t) + abs(p) + abs(q))\n\t\t\tif best_cost &gt; cost:\n\t\t\t\tbest_t, best_p, best_q, best_mode, best_cost = t, p, q, mode, cost\n\n\t\t# interpolation\n\t\tsegments = [best_t, best_p, best_q]\n\t\tpoints_num = int(sum(segments) / self.step) + len(segments) + 3\n\t\tx_list = [0.0 for _ in range(points_num)]\n\t\ty_list = [0.0 for _ in range(points_num)]\n\t\tyaw_list = [alpha for _ in range(points_num)]\n\n\t\ti = 0\n\t\tfor mode_, seg_length in zip(best_mode, segments):\n\t\t\t# path increment\n\t\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t\t# current path length\n\t\t\tlength = d_length\n\t\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\t\ti += 1\n\t\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\t\tlength += d_length\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t\t# failed\n\t\tif len(x_list) &lt;= 1:\n\t\t\treturn None, None, [], [], []\n\n\t\t# remove unused data\n\t\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\t\tx_list.pop()\n\t\t\ty_list.pop()\n\t\t\tyaw_list.pop()\n\n\t\t# coordinate transformation\n\t\trot = Rot.from_euler('z', theta).as_matrix()[0:2, 0:2]\n\t\tconverted_xy = rot @ np.stack([x_list, y_list])\n\t\tx_list = converted_xy[0, :] + sx\n\t\ty_list = converted_xy[1, :] + sy\n\t\tyaw_list = [self.pi2pi(i_yaw + theta) for i_yaw in yaw_list]\n\n\t\treturn best_cost, best_mode, x_list, y_list, yaw_list\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.LRL","title":"<code>LRL(alpha, beta, dist)</code>","text":"<p>Left-Right-Left generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def LRL(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tLeft-Right-Left generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_lrl = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\tif abs(p_lrl) &gt; 1.0:\n\t\treturn None, None, None, [\"L\", \"R\", \"L\"]\n\telse:\n\t\tp_lrl = self.mod2pi(2 * math.pi - math.acos(p_lrl))\n\n\tt_lrl = self.mod2pi(-alpha + math.atan2(-cos_a + cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)\n\tq_lrl = self.mod2pi(beta - alpha - t_lrl + p_lrl)\n\n\treturn t_lrl, p_lrl, q_lrl, [\"L\", \"R\", \"L\"]    \n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.LSL","title":"<code>LSL(alpha, beta, dist)</code>","text":"<p>Left-Straight-Left generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def LSL(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tLeft-Straight-Left generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_lsl = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_a - sin_b)\n\tif p_lsl &lt; 0:\n\t\treturn None, None, None, [\"L\", \"S\", \"L\"]\n\telse:\n\t\tp_lsl = math.sqrt(p_lsl)\n\n\tt_lsl = self.mod2pi(-alpha + math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\tq_lsl = self.mod2pi(beta - math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\n\treturn t_lsl, p_lsl, q_lsl, [\"L\", \"S\", \"L\"]\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.LSR","title":"<code>LSR(alpha, beta, dist)</code>","text":"<p>Left-Straight-Right generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def LSR(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tLeft-Straight-Right generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_lsr = -2 + dist ** 2 + 2 * cos_a_b + 2 * dist * (sin_a + sin_b)\n\tif p_lsr &lt; 0:\n\t\treturn None, None, None, [\"L\", \"S\", \"R\"]\n\telse:\n\t\tp_lsr = math.sqrt(p_lsr)\n\n\tt_lsr = self.mod2pi(-alpha + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\tq_lsr = self.mod2pi(-beta + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\n\treturn t_lsr, p_lsr, q_lsr, [\"L\", \"S\", \"R\"]\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.RLR","title":"<code>RLR(alpha, beta, dist)</code>","text":"<p>Right-Left-Right generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def RLR(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tRight-Left-Right generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_rlr = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\tif abs(p_rlr) &gt; 1.0:\n\t\treturn None, None, None, [\"R\", \"L\", \"R\"]\n\telse:\n\t\tp_rlr = self.mod2pi(2 * math.pi - math.acos(p_rlr))\n\n\tt_rlr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b) + p_rlr / 2.0)\n\tq_rlr = self.mod2pi(alpha - beta - t_rlr + p_rlr)\n\n\treturn t_rlr, p_rlr, q_rlr, [\"R\", \"L\", \"R\"]\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.RSL","title":"<code>RSL(alpha, beta, dist)</code>","text":"<p>Right-Straight-Left generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def RSL(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tRight-Straight-Left generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_rsl = -2 + dist ** 2 + 2 * cos_a_b - 2 * dist * (sin_a + sin_b)\n\tif p_rsl &lt; 0:\n\t\treturn None, None, None, [\"R\", \"S\", \"L\"]\n\telse:\n\t\tp_rsl = math.sqrt(p_rsl)\n\n\tt_rsl = self.mod2pi(alpha - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\tq_rsl = self.mod2pi(beta - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\n\treturn t_rsl, p_rsl, q_rsl, [\"R\", \"S\", \"L\"]\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.RSR","title":"<code>RSR(alpha, beta, dist)</code>","text":"<p>Right-Straight-Right generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def RSR(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tRight-Straight-Right generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_rsr = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_b - sin_a)\n\tif p_rsr &lt; 0:\n\t\treturn None, None, None, [\"R\", \"S\", \"R\"]\n\telse:\n\t\tp_rsr = math.sqrt(p_rsr)\n\n\tt_rsr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\tq_rsr = self.mod2pi(-beta + math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\n\treturn t_rsr, p_rsr, q_rsr, [\"R\", \"S\", \"R\"]\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the Dubins Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>best_cost</code> <code>float</code> <p>Best planning path length</p> <code>best_mode</code> <code>list</code> <p>Best motion modes</p> <code>x_list</code> <code>list</code> <p>Trajectory of x</p> <code>y_list</code> <code>list</code> <p>Trajectory of y</p> <code>yaw_list</code> <code>list</code> <p>Trajectory of yaw</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the Dubins Curve.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tbest_cost (float): Best planning path length\n\t\tbest_mode (list): Best motion modes\n\t\tx_list (list): Trajectory of x\n\t\ty_list (list): Trajectory of y\n\t\tyaw_list (list): Trajectory of yaw\n\t\"\"\"\n\tsx, sy, syaw = start_pose\n\tgx, gy, gyaw = goal_pose\n\n\t# coordinate transformation\n\tgx, gy = gx - sx, gy - sy\n\ttheta = self.mod2pi(math.atan2(gy, gx))\n\tdist = math.hypot(gx, gy) * self.max_curv\n\talpha = self.mod2pi(syaw - theta)\n\tbeta = self.mod2pi(gyaw - theta)\n\n\t# select the best motion\n\tplanners = [self.LSL, self.RSR, self.LSR, self.RSL, self.RLR, self.LRL]\n\tbest_t, best_p, best_q, best_mode, best_cost = None, None, None, None, float(\"inf\")\n\n\tfor planner in planners:\n\t\tt, p, q, mode = planner(alpha, beta, dist)\n\t\tif t is None:\n\t\t\tcontinue\n\t\tcost = (abs(t) + abs(p) + abs(q))\n\t\tif best_cost &gt; cost:\n\t\t\tbest_t, best_p, best_q, best_mode, best_cost = t, p, q, mode, cost\n\n\t# interpolation\n\tsegments = [best_t, best_p, best_q]\n\tpoints_num = int(sum(segments) / self.step) + len(segments) + 3\n\tx_list = [0.0 for _ in range(points_num)]\n\ty_list = [0.0 for _ in range(points_num)]\n\tyaw_list = [alpha for _ in range(points_num)]\n\n\ti = 0\n\tfor mode_, seg_length in zip(best_mode, segments):\n\t\t# path increment\n\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t# current path length\n\t\tlength = d_length\n\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\tlength += d_length\n\t\ti += 1\n\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t# failed\n\tif len(x_list) &lt;= 1:\n\t\treturn None, None, [], [], []\n\n\t# remove unused data\n\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\tx_list.pop()\n\t\ty_list.pop()\n\t\tyaw_list.pop()\n\n\t# coordinate transformation\n\trot = Rot.from_euler('z', theta).as_matrix()[0:2, 0:2]\n\tconverted_xy = rot @ np.stack([x_list, y_list])\n\tx_list = converted_xy[0, :] + sx\n\ty_list = converted_xy[1, :] + sy\n\tyaw_list = [self.pi2pi(i_yaw + theta) for i_yaw in yaw_list]\n\n\treturn best_cost, best_mode, x_list, y_list, yaw_list\n</code></pre>"},{"location":"api/curve_generator/dubins_curve/Dubins.html#src.python_motion_planning.curve_generator.dubins_curve.Dubins.interpolate","title":"<code>interpolate(mode, length, init_pose)</code>","text":"<p>Planning path interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>motion, e.g., L, S, R</p> required <code>length</code> <code>float</code> <p>Single step motion path length</p> required <code>init_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>new_pose</code> <code>tuple</code> <p>New pose (new_x, new_y, new_yaw) after moving</p> Source code in <code>src\\python_motion_planning\\curve_generator\\dubins_curve.py</code> Python<pre><code>def interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\"\"\"\n\tPlanning path interpolation.\n\n\tParameters:\n\t\tmode (str): motion, e.g., L, S, R\n\t\tlength (float): Single step motion path length\n\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\tReturns:\n\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\"\"\"\n\tx, y, yaw = init_pose\n\n\tif mode == \"S\":\n\t\tnew_x   = x + length / self.max_curv * math.cos(yaw)\n\t\tnew_y   = y + length / self.max_curv * math.sin(yaw)\n\t\tnew_yaw = yaw\n\telif mode == \"L\":\n\t\tnew_x   = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y   = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw + length\n\telif mode == \"R\":\n\t\tnew_x   = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y   = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw - length\n\telse:\n\t\traise NotImplementedError\n\n\treturn new_x, new_y, new_yaw\n</code></pre>"},{"location":"api/curve_generator/fem_pos_smooth/FemPosSmoother.html","title":"FemPosSmoother","text":""},{"location":"api/curve_generator/fem_pos_smooth/FemPosSmoother.html#src.python_motion_planning.curve_generator.fem_pos_smooth.FemPosSmoother","title":"<code>src.python_motion_planning.curve_generator.fem_pos_smooth.FemPosSmoother</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Fem-pos smoother.</p> <p>Parameters:</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import FemPosSmoother\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = FemPosSmoother(w_smooth, w_length, w_ref, dx_l, dx_u, dy_l, dy_u)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generator\\fem_pos_smooth.py</code> Python<pre><code>class FemPosSmoother(Curve):\n\t\"\"\"\n\tClass for Fem-pos smoother.\n\n\tParameters:\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import FemPosSmoother\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = FemPosSmoother(w_smooth, w_length, w_ref, dx_l, dx_u, dy_l, dy_u)\n\t\t&gt;&gt;&gt; generator.run(points)\n\t\"\"\"\n\tdef __init__(self, w_smooth: float, w_length: float, w_ref: float,\n\t\tdx_l: float, dx_u: float, dy_l: float, dy_u: float) -&gt; None:\n\t\tsuper().__init__(0.1)\n\t\tself.w_smooth = w_smooth\n\t\tself.w_length = w_length\n\t\tself.w_ref = w_ref\n\t\tself.dx_l = dx_l\n\t\tself.dx_u = dx_u\n\t\tself.dy_l = dy_l\n\t\tself.dy_u = dy_u\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Fem-pos Smoother\"\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\tpass\n</code></pre>"},{"location":"api/curve_generator/polynomial_curve/Polynomial.html","title":"Polynomial","text":""},{"location":"api/curve_generator/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generator.polynomial_curve.Polynomial","title":"<code>src.python_motion_planning.curve_generator.polynomial_curve.Polynomial</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for polynomial curve generation(Quintic).</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>max_acc</code> <code>float</code> <p>Maximum acceleration</p> required <code>max_jerk</code> <code>float</code> <p>Maximum jerk</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import Polynomial\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = Polynomial(step, max_acc, max_jerk)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generator\\polynomial_curve.py</code> Python<pre><code>class Polynomial(Curve):\n    \"\"\"\n    Class for polynomial curve generation(Quintic).\n\n    Parameters:\n        step (float): Simulation or interpolation size\n        max_acc (float): Maximum acceleration\n        max_jerk (float): Maximum jerk\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.curve_generation import Polynomial\n        &gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n        &gt;&gt;&gt; generator = Polynomial(step, max_acc, max_jerk)\n        &gt;&gt;&gt; generator.run(points)\n    \"\"\"\n    def __init__(self, step: float, max_acc: float, max_jerk: float) -&gt; None:\n        super().__init__(step)\n        self.max_acc = max_acc\n        self.max_jerk = max_jerk\n        self.dt = 0.1\n        self.t_min = 1\n        self.t_max = 30\n\n    def __str__(self) -&gt; str:\n        return \"Quintic Polynomial Curve\"\n\n    class Poly:\n        \"\"\"\n        Polynomial interpolation solver\n        \"\"\"\n        def __init__(self, state0: tuple, state1: tuple, t: float) -&gt; None:\n            x0, v0, a0 = state0\n            xt, vt, at = state1\n\n            A = np.array([[t ** 3, t ** 4, t ** 5],\n                          [3 * t ** 2, 4 * t ** 3, 5 * t ** 4],\n                          [6 * t, 12 * t ** 2, 20 * t ** 3]])\n            b = np.array([xt - x0 - v0 * t - a0 * t ** 2 / 2,\n                          vt - v0 - a0 * t,\n                          at - a0])\n            X = np.linalg.solve(A, b)\n\n            # Quintic polynomial coefficient\n            self.p0 = x0\n            self.p1 = v0\n            self.p2 = a0 / 2.0\n            self.p3 = X[0]\n            self.p4 = X[1]\n            self.p5 = X[2]\n\n        def x(self, t):\n            return self.p0 + self.p1 * t + self.p2 * t ** 2 + \\\n                self.p3 * t ** 3 + self.p4 * t ** 4 + self.p5 * t ** 5\n\n        def dx(self, t):\n            return self.p1 + 2 * self.p2 * t + 3 * self.p3 * t ** 2 + \\\n                4 * self.p4 * t ** 3 + 5 * self.p5 * t ** 4\n\n        def ddx(self, t):\n            return 2 * self.p2 + 6 * self.p3 * t + 12 * self.p4 * t ** 2 + 20 * self.p5 * t ** 3\n\n        def dddx(self, t):\n            return 6 * self.p3 + 24 * self.p4 * t + 60 * self.p5 * t ** 2\n\n    class Trajectory:\n        \"\"\"\n        Polynomial interpolation solver\n        \"\"\"\n        def __init__(self):\n            self.clear()\n\n        def clear(self):\n            self.time = []\n            self.x = []\n            self.y = []\n            self.yaw = []\n            self.v = []\n            self.a = []\n            self.jerk = []\n\n        @property\n        def size(self):\n            assert len(self.time) == len(self.x) and \\\n                   len(self.x) == len(self.y) and    \\\n                   len(self.y) == len(self.yaw) and  \\\n                   len(self.yaw) == len(self.v) and  \\\n                   len(self.v) == len(self.a) and    \\\n                   len(self.a) == len(self.jerk),    \\\n                   \"Unequal dimensions of each attribute, this should not happen.\"\n            return len(self.time)\n\n    def generation(self, start_pose: tuple, goal_pose: tuple):\n        \"\"\"\n        Generate the polynomial Curve.\n\n        Parameters:\n            start_pose (tuple): Initial pose (x, y, yaw)\n            goal_pose (tuple): Target pose (x, y, yaw)\n\n        Returns:\n            traj (Traj): The first trajectory that satisfies the acceleration and jerk constraint\n        \"\"\"\n        sx, sy, syaw, sv, sa = start_pose\n        gx, gy, gyaw, gv, ga = goal_pose\n\n        sv_x = sv * math.cos(syaw)\n        sv_y = sv * math.sin(syaw)\n        gv_x = gv * math.cos(gyaw)\n        gv_y = gv * math.sin(gyaw)\n\n        sa_x = sa * math.cos(syaw)\n        sa_y = sa * math.sin(syaw)\n        ga_x = ga * math.cos(gyaw)\n        ga_y = ga * math.sin(gyaw)\n\n        traj = self.Trajectory()\n\n        for T in np.arange(self.t_min, self.t_max, self.step):\n            x_psolver = self.Poly((sx, sv_x, sa_x), (gx, gv_x, ga_x), T)\n            y_psolver = self.Poly((sy, sv_y, sa_y), (gy, gv_y, ga_y), T)\n\n            for t in np.arange(0.0, T + self.dt, self.dt):\n                traj.time.append(t)\n                traj.x.append(x_psolver.x(t))\n                traj.y.append(y_psolver.x(t))\n\n                vx = x_psolver.dx(t)\n                vy = y_psolver.dx(t)\n                traj.v.append(math.hypot(vx, vy))\n                traj.yaw.append(math.atan2(vy, vx))\n\n                ax = x_psolver.ddx(t)\n                ay = y_psolver.ddx(t)\n                a = math.hypot(ax, ay)\n                if len(traj.v) &gt;= 2 and traj.v[-1] - traj.v[-2] &lt; 0.0:\n                    a *= -1\n                traj.a.append(a)\n\n                jx = x_psolver.dddx(t)\n                jy = y_psolver.dddx(t)\n                j = math.hypot(jx, jy)\n                if len(traj.a) &gt;= 2 and traj.a[-1] - traj.a[-2] &lt; 0.0:\n                    j *= -1\n                traj.jerk.append(j)\n\n            if max(np.abs(traj.a)) &lt;= self.max_acc and \\\n               max(np.abs(traj.jerk)) &lt;= self.max_jerk:\n                return traj\n            else:\n                traj.clear()\n\n        return traj\n</code></pre>"},{"location":"api/curve_generator/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generator.polynomial_curve.Polynomial.Poly","title":"<code>Poly</code>","text":"<p>Polynomial interpolation solver</p> Source code in <code>src\\python_motion_planning\\curve_generator\\polynomial_curve.py</code> Python<pre><code>class Poly:\n    \"\"\"\n    Polynomial interpolation solver\n    \"\"\"\n    def __init__(self, state0: tuple, state1: tuple, t: float) -&gt; None:\n        x0, v0, a0 = state0\n        xt, vt, at = state1\n\n        A = np.array([[t ** 3, t ** 4, t ** 5],\n                      [3 * t ** 2, 4 * t ** 3, 5 * t ** 4],\n                      [6 * t, 12 * t ** 2, 20 * t ** 3]])\n        b = np.array([xt - x0 - v0 * t - a0 * t ** 2 / 2,\n                      vt - v0 - a0 * t,\n                      at - a0])\n        X = np.linalg.solve(A, b)\n\n        # Quintic polynomial coefficient\n        self.p0 = x0\n        self.p1 = v0\n        self.p2 = a0 / 2.0\n        self.p3 = X[0]\n        self.p4 = X[1]\n        self.p5 = X[2]\n\n    def x(self, t):\n        return self.p0 + self.p1 * t + self.p2 * t ** 2 + \\\n            self.p3 * t ** 3 + self.p4 * t ** 4 + self.p5 * t ** 5\n\n    def dx(self, t):\n        return self.p1 + 2 * self.p2 * t + 3 * self.p3 * t ** 2 + \\\n            4 * self.p4 * t ** 3 + 5 * self.p5 * t ** 4\n\n    def ddx(self, t):\n        return 2 * self.p2 + 6 * self.p3 * t + 12 * self.p4 * t ** 2 + 20 * self.p5 * t ** 3\n\n    def dddx(self, t):\n        return 6 * self.p3 + 24 * self.p4 * t + 60 * self.p5 * t ** 2\n</code></pre>"},{"location":"api/curve_generator/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generator.polynomial_curve.Polynomial.Trajectory","title":"<code>Trajectory</code>","text":"<p>Polynomial interpolation solver</p> Source code in <code>src\\python_motion_planning\\curve_generator\\polynomial_curve.py</code> Python<pre><code>class Trajectory:\n    \"\"\"\n    Polynomial interpolation solver\n    \"\"\"\n    def __init__(self):\n        self.clear()\n\n    def clear(self):\n        self.time = []\n        self.x = []\n        self.y = []\n        self.yaw = []\n        self.v = []\n        self.a = []\n        self.jerk = []\n\n    @property\n    def size(self):\n        assert len(self.time) == len(self.x) and \\\n               len(self.x) == len(self.y) and    \\\n               len(self.y) == len(self.yaw) and  \\\n               len(self.yaw) == len(self.v) and  \\\n               len(self.v) == len(self.a) and    \\\n               len(self.a) == len(self.jerk),    \\\n               \"Unequal dimensions of each attribute, this should not happen.\"\n        return len(self.time)\n</code></pre>"},{"location":"api/curve_generator/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generator.polynomial_curve.Polynomial.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the polynomial Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>traj</code> <code>Traj</code> <p>The first trajectory that satisfies the acceleration and jerk constraint</p> Source code in <code>src\\python_motion_planning\\curve_generator\\polynomial_curve.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n    \"\"\"\n    Generate the polynomial Curve.\n\n    Parameters:\n        start_pose (tuple): Initial pose (x, y, yaw)\n        goal_pose (tuple): Target pose (x, y, yaw)\n\n    Returns:\n        traj (Traj): The first trajectory that satisfies the acceleration and jerk constraint\n    \"\"\"\n    sx, sy, syaw, sv, sa = start_pose\n    gx, gy, gyaw, gv, ga = goal_pose\n\n    sv_x = sv * math.cos(syaw)\n    sv_y = sv * math.sin(syaw)\n    gv_x = gv * math.cos(gyaw)\n    gv_y = gv * math.sin(gyaw)\n\n    sa_x = sa * math.cos(syaw)\n    sa_y = sa * math.sin(syaw)\n    ga_x = ga * math.cos(gyaw)\n    ga_y = ga * math.sin(gyaw)\n\n    traj = self.Trajectory()\n\n    for T in np.arange(self.t_min, self.t_max, self.step):\n        x_psolver = self.Poly((sx, sv_x, sa_x), (gx, gv_x, ga_x), T)\n        y_psolver = self.Poly((sy, sv_y, sa_y), (gy, gv_y, ga_y), T)\n\n        for t in np.arange(0.0, T + self.dt, self.dt):\n            traj.time.append(t)\n            traj.x.append(x_psolver.x(t))\n            traj.y.append(y_psolver.x(t))\n\n            vx = x_psolver.dx(t)\n            vy = y_psolver.dx(t)\n            traj.v.append(math.hypot(vx, vy))\n            traj.yaw.append(math.atan2(vy, vx))\n\n            ax = x_psolver.ddx(t)\n            ay = y_psolver.ddx(t)\n            a = math.hypot(ax, ay)\n            if len(traj.v) &gt;= 2 and traj.v[-1] - traj.v[-2] &lt; 0.0:\n                a *= -1\n            traj.a.append(a)\n\n            jx = x_psolver.dddx(t)\n            jy = y_psolver.dddx(t)\n            j = math.hypot(jx, jy)\n            if len(traj.a) &gt;= 2 and traj.a[-1] - traj.a[-2] &lt; 0.0:\n                j *= -1\n            traj.jerk.append(j)\n\n        if max(np.abs(traj.a)) &lt;= self.max_acc and \\\n           max(np.abs(traj.jerk)) &lt;= self.max_jerk:\n            return traj\n        else:\n            traj.clear()\n\n    return traj\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html","title":"ReedsShepp","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp","title":"<code>src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Reeds shepp curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>max_curv</code> <code>float</code> <p>The maximum curvature of the curve</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import ReedsShepp\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = ReedsShepp(step, max_curv)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> References <p>[1] Optimal paths for a car that goes both forwards and backwards</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>class ReedsShepp(Curve):\n\t\"\"\"\n\tClass for Reeds shepp curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\tmax_curv (float): The maximum curvature of the curve\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import ReedsShepp\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = ReedsShepp(step, max_curv)\n\t\t&gt;&gt;&gt; generator.run(points)\n\n\tReferences:\n\t\t[1] Optimal paths for a car that goes both forwards and backwards\n\t\"\"\"\n\tdef __init__(self, step: float, max_curv: float) -&gt; None:\n\t\tsuper().__init__(step)\n\t\tself.max_curv = max_curv\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Reeds Shepp Curve\"\n\n\tdef R(self, x, y):\n\t\t\"\"\"\n\t\tReturn the polar coordinates (r, theta) of the point (x, y)\n\t\ti.e. rcos(theta) = x; rsin(theta) = y\n\n\t\tParameters:\n\t\t\tx (float): x-coordinate value\n\t\t\ty (float): y-coordinate value\n\n\t\tReturns:\n\t\t\tr, theta (float): Polar coordinates\n\n\t\t\"\"\"\n\t\tr = math.hypot(x, y)\n\t\ttheta = math.atan2(y, x)\n\n\t\treturn r, theta\n\n\tdef M(self, theta):\n\t\t\"\"\"\n\t\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\n\t\tParameters:\n\t\t\ttheta (float): Angle value\n\n\t\tReturns:\n\t\t\ttheta (float): Truncated angle value\n\t\t\"\"\"\n\t\treturn self.pi2pi(theta)\n\n\tclass Path:\n\t\t\"\"\"\n\t\tclass for Path element\n\t\t\"\"\"\n\t\tdef __init__(self, lengths: list = [], ctypes: list = [], x: list = [],\n\t\t\ty: list = [], yaw: list = [], dirs: list = []):\n\t\t\tself.lengths = lengths  \t# lengths of each part of path (+: forward, -: backward)\n\t\t\tself.ctypes = ctypes  \t\t# type of each part of the path\n\t\t\tself.path_length = sum([abs(i) for i in lengths])  # total path length\n\t\t\tself.x = x  \t\t\t\t# x-coordinate value of curve\n\t\t\tself.y = y  \t\t\t\t# y-coordinate value of curve\n\t\t\tself.yaw = yaw  \t\t\t# yaw value of curve\n\t\t\tself.dirs = dirs \t\t\t# direction value of curve (1: forward, -1: backward)\n\n\tdef SLS(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tStraight-Left-Straight generation mode.\n\t\t\"\"\"\n\t\tphi = self.M(phi)\n\n\t\tif y &gt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\t\txd = -y / math.tan(phi) + x\n\t\t\tt = xd - math.tan(phi / 2.0)\n\t\t\tu = phi\n\t\t\tv = math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\t\treturn True, t, u, v\n\t\telif y &lt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\t\txd = -y / math.tan(phi) + x\n\t\t\tt = xd - math.tan(phi / 2.0)\n\t\t\tu = phi\n\t\t\tv = -math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRL(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right-Left generation mode. (L+R-L-)\n\t\t\"\"\"\n\t\tr, theta = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\t\tif r &lt;= 4.0:\n\t\t\tu = -2.0 * math.asin(0.25 * r)\n\t\t\tt = self.M(theta + 0.5 * u + math.pi)\n\t\t\tv = self.M(phi - t + u)\n\n\t\t\tif t &gt;= 0.0 and u &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LSL(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Left generation mode. (L+S+L+)\n\t\t\"\"\"\n\t\tu, t = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\t\tif t &gt;= 0.0:\n\t\t\tv = self.M(phi - t)\n\t\t\tif v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LSR(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Right generation mode. (L+S+R+)\n\t\t\"\"\"\n\t\tr, theta = self.R(x + math.sin(phi), y - 1.0 - math.cos(phi))\n\t\tr = r ** 2\n\n\t\tif r &gt;= 4.0:\n\t\t\tu = math.sqrt(r - 4.0)\n\t\t\tt = self.M(theta + math.atan2(2.0, u))\n\t\t\tv = self.M(t - phi)\n\n\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRLRn(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R+L-R-)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\trho = 0.25 * (2.0 + math.sqrt(xi * xi + eta * eta))\n\n\t\tif rho &lt;= 1.0:\n\t\t\tu = math.acos(rho)\n\t\t\tt, v = self._calTauOmega(u, -u, xi, eta, phi)\n\t\t\tif t &gt;= 0.0 and v &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRLRp(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R-L-R+)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\trho = (20.0 - xi * xi - eta * eta) / 16.0\n\n\t\tif 0.0 &lt;= rho &lt;= 1.0:\n\t\t\tu = -math.acos(rho)\n\t\t\tif u &gt;= -0.5 * math.pi:\n\t\t\t\tt, v = self._calTauOmega(u, u, xi, eta, phi)\n\t\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRSR(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(pi/2)-Straight-Right generation mode. (L+R-S-R-)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\trho, theta = self.R(-eta, xi)\n\n\t\tif rho &gt;= 2.0:\n\t\t\tt = theta\n\t\t\tu = 2.0 - rho\n\t\t\tv = self.M(t + 0.5 * math.pi - phi)\n\t\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRSL(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(pi/2)-Straight-Left generation mode. (L+R-S-L-)\n\t\t\"\"\"\n\t\txi = x - math.sin(phi)\n\t\teta = y - 1.0 + math.cos(phi)\n\t\trho, theta = self.R(xi, eta)\n\n\t\tif rho &gt;= 2.0:\n\t\t\tr = math.sqrt(rho * rho - 4.0)\n\t\t\tu = 2.0 - r\n\t\t\tt = self.M(theta + math.atan2(r, -2.0))\n\t\t\tv = self.M(phi - 0.5 * math.pi - t)\n\t\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRSLR(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(pi/2)-Straight-Left(pi/2)-Right generation mode. (L+R-S-L-R+)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\tr, _ = self.R(xi, eta)\n\n\t\tif r &gt;= 2.0:\n\t\t\tu = 4.0 - math.sqrt(r * r - 4.0)\n\t\t\tif u &lt;= 0.0:\n\t\t\t\tt = self.M(math.atan2((4.0 - u) * xi - 2.0 * eta, -2.0 * xi + (u - 4.0) * eta))\n\t\t\t\tv = self.M(t - phi)\n\n\t\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef SCS(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 2\n\t\tStraight-Circle-Straight generation mode(using reflect).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\tflag, t, u, v = self.SLS(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"L\", \"S\"]))\n\n\t\tflag, t, u, v = self.SLS(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"R\", \"S\"]))\n\n\t\treturn paths\n\n\tdef CCC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 8\n\t\tCircle-Circle-Circle generation mode(using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R-L-\n\t\tflag, t, u, v = self.LRL(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# timefilp: L-R+L+\n\t\tflag, t, u, v = self.LRL(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# reflect: R+L-R-\n\t\tflag, t, u, v = self.LRL(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\t# timeflip + reflect: R-L+R+\n\t\tflag, t, u, v = self.LRL(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\t# backwards\n\t\txb = x * math.cos(phi) + y * math.sin(phi)\n\t\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t\t# backwards: L-R-L+\n\t\tflag, t, u, v = self.LRL(xb, yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# backwards + timefilp: L+R+L-\n\t\tflag, t, u, v = self.LRL(-xb, yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# backwards + reflect: R-L-R+\n\t\tflag, t, u, v = self.LRL(xb, -yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\t# backwards + timeflip + reflect: R+L+R-\n\t\tflag, t, u, v = self.LRL(-xb, -yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\treturn paths\n\n\tdef CSC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 8\n\t\tCircle-Straight-Circle generation mode(using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+S+L+\n\t\tflag, t, u, v = self.LSL(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t\t# timefilp: L-S-L-\n\t\tflag, t, u, v = self.LSL(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t\t# reflect: R+S+R+\n\t\tflag, t, u, v = self.LSL(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t\t# timeflip + reflect: R-S-R-\n\t\tflag, t, u, v = self.LSL(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t\t# L+S+R+\n\t\tflag, t, u, v = self.LSR(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t\t# timefilp: L-S-R-\n\t\tflag, t, u, v = self.LSR(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t\t# reflect: R+S+L+\n\t\tflag, t, u, v = self.LSR(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\t\t# timeflip + reflect: R+S+l-\n\t\tflag, t, u, v = self.LSR(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\t\treturn paths\n\n\tdef CCCC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 8\n\t\tCircle-Circle(beta)-Circle(beta)-Circle generation mode\n\t\t(using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R+L-R-\n\t\tflag, t, u, v = self.LRLRn(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# timefilp: L-R-L+R+\n\t\tflag, t, u, v = self.LRLRn(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# reflect: R+L+R-L-\n\t\tflag, t, u, v = self.LRLRn(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\t# timeflip + reflect: R-L-R+L+\n\t\tflag, t, u, v = self.LRLRn(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\t# L+R-L-R+\n\t\tflag, t, u, v = self.LRLRp(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# timefilp: L-R+L+R-\n\t\tflag, t, u, v = self.LRLRp(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# reflect: R+L-R-L+\n\t\tflag, t, u, v = self.LRLRp(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\t# timeflip + reflect: R-L+R+L-\n\t\tflag, t, u, v = self.LRLRp(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\treturn paths\n\n\tdef CCSC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 16\n\t\tCircle-Circle(pi/2)-Straight-Circle and Circle-Straight-Circle(pi/2)-Circle\n\t\tgeneration mode (using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R-(pi/2)S-L-\n\t\tflag, t, u, v = self.LRSL(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t\t# timefilp: L-R+(pi/2)S+L+\n\t\tflag, t, u, v = self.LRSL(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t\t# reflect: R+L-(pi/2)S-R-\n\t\tflag, t, u, v = self.LRSL(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t\t# timeflip + reflect: R-L+(pi/2)S+R+\n\t\tflag, t, u, v = self.LRSL(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t\t# L+R-(pi/2)S-R-\n\t\tflag, t, u, v = self.LRSR(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t\t# timefilp: L-R+(pi/2)S+R+\n\t\tflag, t, u, v = self.LRSR(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t\t# reflect: R+L-(pi/2)S-L-\n\t\tflag, t, u, v = self.LRSR(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t\t# timeflip + reflect: R-L+(pi/2)S+L+\n\t\tflag, t, u, v = self.LRSR(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t\t# backwards\n\t\txb = x * math.cos(phi) + y * math.sin(phi)\n\t\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t\t# backwards: L-S-R-(pi/2)L+\n\t\tflag, t, u, v = self.LRSL(xb, yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + timefilp: L+S+R+(pi/2)L-\n\t\tflag, t, u, v = self.LRSL(-xb, yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + reflect: R-S-L-(pi/2)R+\n\t\tflag, t, u, v = self.LRSL(xb, -yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# backwards + timefilp + reflect: R+S+L+(pi/2)R-\n\t\tflag, t, u, v = self.LRSL(-xb, -yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# backwards: R-S-R-(pi/2)L+\n\t\tflag, t, u, v = self.LRSR(xb, yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + timefilp: R+S+R+(pi/2)L-\n\t\tflag, t, u, v = self.LRSR(-xb, yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + reflect: L-S-L-(pi/2)R+\n\t\tflag, t, u, v = self.LRSR(xb, -yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\t\t# backwards + timefilp + reflect: L+S+L+(pi/2)R-\n\t\tflag, t, u, v = self.LRSR(-xb, -yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\t\treturn paths\n\n\tdef CCSCC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 4\n\t\tCircle-Circle(pi/2)-Straight--Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R-(pi/2)S-L-(pi/2)R+\n\t\tflag, t, u, v = self.LRSLR(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# timefilp: L-R+(pi/2)S+L+(pi/2)R-\n\t\tflag, t, u, v = self.LRSLR(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# reflect: R+L-(pi/2)S-R-(pi/2)L+\n\t\tflag, t, u, v = self.LRSLR(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\t\t# timefilp + reflect: R-L+(pi/2)S+R+(pi/2)L-\n\t\tflag, t, u, v = self.LRSLR(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\t\treturn paths\n\n\tdef interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\t\"\"\"\n\t\tPlanning path interpolation.\n\n\t\tParameters:\n\t\t\tmode (str): motion, e.g., L, S, R\n\t\t\tlength (float): Single step motion path length\n\t\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\t\"\"\"\n\t\tx, y, yaw = init_pose\n\n\t\tif mode == \"S\":\n\t\t\tnew_x = x + length / self.max_curv * math.cos(yaw)\n\t\t\tnew_y = y + length / self.max_curv * math.sin(yaw)\n\t\t\tnew_yaw = yaw\n\t\telif mode == \"L\":\n\t\t\tnew_x = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw + length\n\t\telif mode == \"R\":\n\t\t\tnew_x = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw - length\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\treturn new_x, new_y, new_yaw\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the Reeds Shepp Curve.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tbest_cost (float): Best planning path length\n\t\t\tbest_mode: Best motion modes\n\t\t\tx_list (list): Trajectory of x\n\t\t\ty_list (list): Trajectory of y\n\t\t\tyaw_list (list): Trajectory of yaw\n\t\t\"\"\"\n\t\tsx, sy, syaw = start_pose\n\t\tgx, gy, gyaw = goal_pose\n\n\t\t# coordinate transformation\n\t\tdx, dy, dyaw = gx - sx, gy - sy, gyaw - syaw\n\t\tx = (math.cos(syaw) * dx + math.sin(syaw) * dy) * self.max_curv\n\t\ty = (-math.sin(syaw) * dx + math.cos(syaw) * dy) * self.max_curv\n\n\t\t# select the best motion\n\t\tplanners = [self.SCS, self.CCC, self.CSC, self.CCCC, self.CCSC, self.CCSCC]\n\t\tbest_path, best_cost = None, float(\"inf\")\n\n\t\tfor planner in planners:\n\t\t\tpaths = planner(x, y, dyaw)\n\t\t\tfor path in paths:\n\t\t\t\tif path.path_length &lt; best_cost:\n\t\t\t\t\tbest_path, best_cost = path, path.path_length\n\n\t\t# interpolation\n\t\tpoints_num = int(best_cost / self.step) + len(best_path.lengths) + 3\n\t\tx_list = [0.0 for _ in range(points_num)]\n\t\ty_list = [0.0 for _ in range(points_num)]\n\t\tyaw_list = [0.0 for _ in range(points_num)]\n\n\t\ti = 0\n\t\tfor mode_, seg_length in zip(best_path.ctypes, best_path.lengths):\n\t\t\t# path increment\n\t\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t\t# current path length\n\t\t\tlength = d_length\n\t\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\t\ti += 1\n\t\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\t\tlength += d_length\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t\t# failed\n\t\tif len(x_list) &lt;= 1:\n\t\t\treturn None, None, [], [], []\n\n\t\t# remove unused data\n\t\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\t\tx_list.pop()\n\t\t\ty_list.pop()\n\t\t\tyaw_list.pop()\n\n\t\t# coordinate transformation\n\t\tx_list_ = [math.cos(-syaw) * ix + math.sin(-syaw) * iy + sx for (ix, iy) in zip(x_list, y_list)]\n\t\ty_list_ = [-math.sin(-syaw) * ix + math.cos(-syaw) * iy + sy for (ix, iy) in zip(x_list, y_list)]\n\t\tyaw_list_ = [self.pi2pi(iyaw + syaw) for iyaw in yaw_list]\n\n\t\treturn best_cost / self.max_curv, best_path.ctypes, x_list_, y_list_, yaw_list_\n\n\t# def run(self, points: list):\n\t# \t\"\"\"\n\t# \tRunning both generation and animation.\n\n\t# \tParameters:\n\t# \t\tpoints (list[tuple]): path points\n\t# \t\"\"\"\n\t# \tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\t# \timport matplotlib.pyplot as plt\n\n\t# \t# generation\n\t# \tpath_x, path_y, path_yaw = [], [], []\n\t# \tfor i in range(len(points) - 1):\n\t# \t\t_, _, x_list, y_list, yaw_list = self.generation(\n\t# \t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t# \t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t# \t\tfor j in range(len(x_list)):\n\t# \t\t\tpath_x.append(x_list[j])\n\t# \t\t\tpath_y.append(y_list[j])\n\t# \t\t\tpath_yaw.append(yaw_list[j])\n\n\t# \t# animation\n\t# \tplt.figure(\"curve generation\")\n\t# \t# # static\n\t# \t# plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t# \t# for x, y, theta in points:\n\t# \t# \tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\t# \t# dynamic\n\t# \tplt.ion()\n\t# \tfor i in range(len(path_x)):\n\t# \t\tplt.clf()\n\t# \t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t# \t\t\t\t\t\t\t\t\t\tlambda event: [exit(0) if event.key == 'escape' else None])\n\t# \t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t# \t\tfor x, y, theta in points:\n\t# \t\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\t# \t\tPlot.plotCar(path_x[i], path_y[i], path_yaw[i], 1.5, 3, \"black\")\n\t# \t\tplt.axis(\"equal\")\n\t# \t\tplt.title(str(self))\n\t# \t\tplt.draw()\n\t# \t\tplt.pause(0.001)\n\n\t# \tplt.axis(\"equal\")\n\t# \tplt.title(str(self))\n\t# \tplt.show()\n\n\n\tdef _calTauOmega(self, u, v, xi, eta, phi):\n\t\tdelta = self.M(u - v)\n\t\tA = math.sin(u) - math.sin(delta)\n\t\tB = math.cos(u) - math.cos(delta) - 1.0\n\n\t\tt1 = math.atan2(eta * A - xi * B, xi * A + eta * B)\n\t\tt2 = 2.0 * (math.cos(delta) - math.cos(v) - math.cos(u)) + 3.0\n\n\t\ttau = self.M(t1 + math.pi) if t2 &lt; 0 else self.M(t1)\n\t\tomega = self.M(tau - u + v - phi)\n\n\t\treturn tau, omega\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.Path","title":"<code>Path</code>","text":"<p>class for Path element</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>class Path:\n\t\"\"\"\n\tclass for Path element\n\t\"\"\"\n\tdef __init__(self, lengths: list = [], ctypes: list = [], x: list = [],\n\t\ty: list = [], yaw: list = [], dirs: list = []):\n\t\tself.lengths = lengths  \t# lengths of each part of path (+: forward, -: backward)\n\t\tself.ctypes = ctypes  \t\t# type of each part of the path\n\t\tself.path_length = sum([abs(i) for i in lengths])  # total path length\n\t\tself.x = x  \t\t\t\t# x-coordinate value of curve\n\t\tself.y = y  \t\t\t\t# y-coordinate value of curve\n\t\tself.yaw = yaw  \t\t\t# yaw value of curve\n\t\tself.dirs = dirs \t\t\t# direction value of curve (1: forward, -1: backward)\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCC","title":"<code>CCC(x, y, phi)</code>","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCC--8","title":"8","text":"<p>Circle-Circle-Circle generation mode(using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def CCC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 8\n\tCircle-Circle-Circle generation mode(using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R-L-\n\tflag, t, u, v = self.LRL(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# timefilp: L-R+L+\n\tflag, t, u, v = self.LRL(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# reflect: R+L-R-\n\tflag, t, u, v = self.LRL(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t# timeflip + reflect: R-L+R+\n\tflag, t, u, v = self.LRL(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t# backwards\n\txb = x * math.cos(phi) + y * math.sin(phi)\n\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t# backwards: L-R-L+\n\tflag, t, u, v = self.LRL(xb, yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# backwards + timefilp: L+R+L-\n\tflag, t, u, v = self.LRL(-xb, yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# backwards + reflect: R-L-R+\n\tflag, t, u, v = self.LRL(xb, -yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t# backwards + timeflip + reflect: R+L+R-\n\tflag, t, u, v = self.LRL(-xb, -yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\treturn paths\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCCC","title":"<code>CCCC(x, y, phi)</code>","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCCC--8","title":"8","text":"<p>Circle-Circle(beta)-Circle(beta)-Circle generation mode (using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def CCCC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 8\n\tCircle-Circle(beta)-Circle(beta)-Circle generation mode\n\t(using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R+L-R-\n\tflag, t, u, v = self.LRLRn(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# timefilp: L-R-L+R+\n\tflag, t, u, v = self.LRLRn(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# reflect: R+L+R-L-\n\tflag, t, u, v = self.LRLRn(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t# timeflip + reflect: R-L-R+L+\n\tflag, t, u, v = self.LRLRn(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t# L+R-L-R+\n\tflag, t, u, v = self.LRLRp(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# timefilp: L-R+L+R-\n\tflag, t, u, v = self.LRLRp(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# reflect: R+L-R-L+\n\tflag, t, u, v = self.LRLRp(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t# timeflip + reflect: R-L+R+L-\n\tflag, t, u, v = self.LRLRp(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\treturn paths\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCSC","title":"<code>CCSC(x, y, phi)</code>","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCSC--16","title":"16","text":"<p>Circle-Circle(pi/2)-Straight-Circle and Circle-Straight-Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def CCSC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 16\n\tCircle-Circle(pi/2)-Straight-Circle and Circle-Straight-Circle(pi/2)-Circle\n\tgeneration mode (using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R-(pi/2)S-L-\n\tflag, t, u, v = self.LRSL(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t# timefilp: L-R+(pi/2)S+L+\n\tflag, t, u, v = self.LRSL(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t# reflect: R+L-(pi/2)S-R-\n\tflag, t, u, v = self.LRSL(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t# timeflip + reflect: R-L+(pi/2)S+R+\n\tflag, t, u, v = self.LRSL(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t# L+R-(pi/2)S-R-\n\tflag, t, u, v = self.LRSR(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t# timefilp: L-R+(pi/2)S+R+\n\tflag, t, u, v = self.LRSR(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t# reflect: R+L-(pi/2)S-L-\n\tflag, t, u, v = self.LRSR(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t# timeflip + reflect: R-L+(pi/2)S+L+\n\tflag, t, u, v = self.LRSR(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t# backwards\n\txb = x * math.cos(phi) + y * math.sin(phi)\n\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t# backwards: L-S-R-(pi/2)L+\n\tflag, t, u, v = self.LRSL(xb, yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + timefilp: L+S+R+(pi/2)L-\n\tflag, t, u, v = self.LRSL(-xb, yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + reflect: R-S-L-(pi/2)R+\n\tflag, t, u, v = self.LRSL(xb, -yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t# backwards + timefilp + reflect: R+S+L+(pi/2)R-\n\tflag, t, u, v = self.LRSL(-xb, -yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t# backwards: R-S-R-(pi/2)L+\n\tflag, t, u, v = self.LRSR(xb, yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + timefilp: R+S+R+(pi/2)L-\n\tflag, t, u, v = self.LRSR(-xb, yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + reflect: L-S-L-(pi/2)R+\n\tflag, t, u, v = self.LRSR(xb, -yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\t# backwards + timefilp + reflect: L+S+L+(pi/2)R-\n\tflag, t, u, v = self.LRSR(-xb, -yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\treturn paths\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCSCC","title":"<code>CCSCC(x, y, phi)</code>","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CCSCC--4","title":"4","text":"<p>Circle-Circle(pi/2)-Straight--Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def CCSCC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 4\n\tCircle-Circle(pi/2)-Straight--Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R-(pi/2)S-L-(pi/2)R+\n\tflag, t, u, v = self.LRSLR(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t# timefilp: L-R+(pi/2)S+L+(pi/2)R-\n\tflag, t, u, v = self.LRSLR(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t# reflect: R+L-(pi/2)S-R-(pi/2)L+\n\tflag, t, u, v = self.LRSLR(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\t# timefilp + reflect: R-L+(pi/2)S+R+(pi/2)L-\n\tflag, t, u, v = self.LRSLR(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\treturn paths\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CSC","title":"<code>CSC(x, y, phi)</code>","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.CSC--8","title":"8","text":"<p>Circle-Straight-Circle generation mode(using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def CSC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 8\n\tCircle-Straight-Circle generation mode(using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+S+L+\n\tflag, t, u, v = self.LSL(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t# timefilp: L-S-L-\n\tflag, t, u, v = self.LSL(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t# reflect: R+S+R+\n\tflag, t, u, v = self.LSL(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t# timeflip + reflect: R-S-R-\n\tflag, t, u, v = self.LSL(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t# L+S+R+\n\tflag, t, u, v = self.LSR(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t# timefilp: L-S-R-\n\tflag, t, u, v = self.LSR(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t# reflect: R+S+L+\n\tflag, t, u, v = self.LSR(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\t# timeflip + reflect: R+S+l-\n\tflag, t, u, v = self.LSR(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\treturn paths\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LRL","title":"<code>LRL(x, y, phi)</code>","text":"<p>Left-Right-Left generation mode. (L+R-L-)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LRL(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right-Left generation mode. (L+R-L-)\n\t\"\"\"\n\tr, theta = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\tif r &lt;= 4.0:\n\t\tu = -2.0 * math.asin(0.25 * r)\n\t\tt = self.M(theta + 0.5 * u + math.pi)\n\t\tv = self.M(phi - t + u)\n\n\t\tif t &gt;= 0.0 and u &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LRLRn","title":"<code>LRLRn(x, y, phi)</code>","text":"<p>Left-Right(beta)-Left(beta)-Right generation mode. (L+R+L-R-)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LRLRn(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R+L-R-)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\trho = 0.25 * (2.0 + math.sqrt(xi * xi + eta * eta))\n\n\tif rho &lt;= 1.0:\n\t\tu = math.acos(rho)\n\t\tt, v = self._calTauOmega(u, -u, xi, eta, phi)\n\t\tif t &gt;= 0.0 and v &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LRLRp","title":"<code>LRLRp(x, y, phi)</code>","text":"<p>Left-Right(beta)-Left(beta)-Right generation mode. (L+R-L-R+)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LRLRp(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R-L-R+)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\trho = (20.0 - xi * xi - eta * eta) / 16.0\n\n\tif 0.0 &lt;= rho &lt;= 1.0:\n\t\tu = -math.acos(rho)\n\t\tif u &gt;= -0.5 * math.pi:\n\t\t\tt, v = self._calTauOmega(u, u, xi, eta, phi)\n\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LRSL","title":"<code>LRSL(x, y, phi)</code>","text":"<p>Left-Right(pi/2)-Straight-Left generation mode. (L+R-S-L-)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LRSL(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(pi/2)-Straight-Left generation mode. (L+R-S-L-)\n\t\"\"\"\n\txi = x - math.sin(phi)\n\teta = y - 1.0 + math.cos(phi)\n\trho, theta = self.R(xi, eta)\n\n\tif rho &gt;= 2.0:\n\t\tr = math.sqrt(rho * rho - 4.0)\n\t\tu = 2.0 - r\n\t\tt = self.M(theta + math.atan2(r, -2.0))\n\t\tv = self.M(phi - 0.5 * math.pi - t)\n\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LRSLR","title":"<code>LRSLR(x, y, phi)</code>","text":"<p>Left-Right(pi/2)-Straight-Left(pi/2)-Right generation mode. (L+R-S-L-R+)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LRSLR(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(pi/2)-Straight-Left(pi/2)-Right generation mode. (L+R-S-L-R+)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\tr, _ = self.R(xi, eta)\n\n\tif r &gt;= 2.0:\n\t\tu = 4.0 - math.sqrt(r * r - 4.0)\n\t\tif u &lt;= 0.0:\n\t\t\tt = self.M(math.atan2((4.0 - u) * xi - 2.0 * eta, -2.0 * xi + (u - 4.0) * eta))\n\t\t\tv = self.M(t - phi)\n\n\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LRSR","title":"<code>LRSR(x, y, phi)</code>","text":"<p>Left-Right(pi/2)-Straight-Right generation mode. (L+R-S-R-)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LRSR(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(pi/2)-Straight-Right generation mode. (L+R-S-R-)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\trho, theta = self.R(-eta, xi)\n\n\tif rho &gt;= 2.0:\n\t\tt = theta\n\t\tu = 2.0 - rho\n\t\tv = self.M(t + 0.5 * math.pi - phi)\n\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LSL","title":"<code>LSL(x, y, phi)</code>","text":"<p>Left-Straight-Left generation mode. (L+S+L+)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LSL(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Straight-Left generation mode. (L+S+L+)\n\t\"\"\"\n\tu, t = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\tif t &gt;= 0.0:\n\t\tv = self.M(phi - t)\n\t\tif v &gt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.LSR","title":"<code>LSR(x, y, phi)</code>","text":"<p>Left-Straight-Right generation mode. (L+S+R+)</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def LSR(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Straight-Right generation mode. (L+S+R+)\n\t\"\"\"\n\tr, theta = self.R(x + math.sin(phi), y - 1.0 - math.cos(phi))\n\tr = r ** 2\n\n\tif r &gt;= 4.0:\n\t\tu = math.sqrt(r - 4.0)\n\t\tt = self.M(theta + math.atan2(2.0, u))\n\t\tv = self.M(t - phi)\n\n\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.M","title":"<code>M(theta)</code>","text":"<p>Truncate the angle to the interval of -\u03c0 to \u03c0.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle value</p> required <p>Returns:</p> Name Type Description <code>theta</code> <code>float</code> <p>Truncated angle value</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def M(self, theta):\n\t\"\"\"\n\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\n\tParameters:\n\t\ttheta (float): Angle value\n\n\tReturns:\n\t\ttheta (float): Truncated angle value\n\t\"\"\"\n\treturn self.pi2pi(theta)\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.R","title":"<code>R(x, y)</code>","text":"<p>Return the polar coordinates (r, theta) of the point (x, y) i.e. rcos(theta) = x; rsin(theta) = y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x-coordinate value</p> required <code>y</code> <code>float</code> <p>y-coordinate value</p> required <p>Returns:</p> Type Description <p>r, theta (float): Polar coordinates</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def R(self, x, y):\n\t\"\"\"\n\tReturn the polar coordinates (r, theta) of the point (x, y)\n\ti.e. rcos(theta) = x; rsin(theta) = y\n\n\tParameters:\n\t\tx (float): x-coordinate value\n\t\ty (float): y-coordinate value\n\n\tReturns:\n\t\tr, theta (float): Polar coordinates\n\n\t\"\"\"\n\tr = math.hypot(x, y)\n\ttheta = math.atan2(y, x)\n\n\treturn r, theta\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.SCS","title":"<code>SCS(x, y, phi)</code>","text":""},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.SCS--2","title":"2","text":"<p>Straight-Circle-Straight generation mode(using reflect).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def SCS(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 2\n\tStraight-Circle-Straight generation mode(using reflect).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\tflag, t, u, v = self.SLS(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"L\", \"S\"]))\n\n\tflag, t, u, v = self.SLS(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"R\", \"S\"]))\n\n\treturn paths\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.SLS","title":"<code>SLS(x, y, phi)</code>","text":"<p>Straight-Left-Straight generation mode.</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def SLS(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tStraight-Left-Straight generation mode.\n\t\"\"\"\n\tphi = self.M(phi)\n\n\tif y &gt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\txd = -y / math.tan(phi) + x\n\t\tt = xd - math.tan(phi / 2.0)\n\t\tu = phi\n\t\tv = math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\treturn True, t, u, v\n\telif y &lt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\txd = -y / math.tan(phi) + x\n\t\tt = xd - math.tan(phi / 2.0)\n\t\tu = phi\n\t\tv = -math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the Reeds Shepp Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>best_cost</code> <code>float</code> <p>Best planning path length</p> <code>best_mode</code> <p>Best motion modes</p> <code>x_list</code> <code>list</code> <p>Trajectory of x</p> <code>y_list</code> <code>list</code> <p>Trajectory of y</p> <code>yaw_list</code> <code>list</code> <p>Trajectory of yaw</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the Reeds Shepp Curve.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tbest_cost (float): Best planning path length\n\t\tbest_mode: Best motion modes\n\t\tx_list (list): Trajectory of x\n\t\ty_list (list): Trajectory of y\n\t\tyaw_list (list): Trajectory of yaw\n\t\"\"\"\n\tsx, sy, syaw = start_pose\n\tgx, gy, gyaw = goal_pose\n\n\t# coordinate transformation\n\tdx, dy, dyaw = gx - sx, gy - sy, gyaw - syaw\n\tx = (math.cos(syaw) * dx + math.sin(syaw) * dy) * self.max_curv\n\ty = (-math.sin(syaw) * dx + math.cos(syaw) * dy) * self.max_curv\n\n\t# select the best motion\n\tplanners = [self.SCS, self.CCC, self.CSC, self.CCCC, self.CCSC, self.CCSCC]\n\tbest_path, best_cost = None, float(\"inf\")\n\n\tfor planner in planners:\n\t\tpaths = planner(x, y, dyaw)\n\t\tfor path in paths:\n\t\t\tif path.path_length &lt; best_cost:\n\t\t\t\tbest_path, best_cost = path, path.path_length\n\n\t# interpolation\n\tpoints_num = int(best_cost / self.step) + len(best_path.lengths) + 3\n\tx_list = [0.0 for _ in range(points_num)]\n\ty_list = [0.0 for _ in range(points_num)]\n\tyaw_list = [0.0 for _ in range(points_num)]\n\n\ti = 0\n\tfor mode_, seg_length in zip(best_path.ctypes, best_path.lengths):\n\t\t# path increment\n\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t# current path length\n\t\tlength = d_length\n\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\tlength += d_length\n\t\ti += 1\n\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t# failed\n\tif len(x_list) &lt;= 1:\n\t\treturn None, None, [], [], []\n\n\t# remove unused data\n\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\tx_list.pop()\n\t\ty_list.pop()\n\t\tyaw_list.pop()\n\n\t# coordinate transformation\n\tx_list_ = [math.cos(-syaw) * ix + math.sin(-syaw) * iy + sx for (ix, iy) in zip(x_list, y_list)]\n\ty_list_ = [-math.sin(-syaw) * ix + math.cos(-syaw) * iy + sy for (ix, iy) in zip(x_list, y_list)]\n\tyaw_list_ = [self.pi2pi(iyaw + syaw) for iyaw in yaw_list]\n\n\treturn best_cost / self.max_curv, best_path.ctypes, x_list_, y_list_, yaw_list_\n</code></pre>"},{"location":"api/curve_generator/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generator.reeds_shepp.ReedsShepp.interpolate","title":"<code>interpolate(mode, length, init_pose)</code>","text":"<p>Planning path interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>motion, e.g., L, S, R</p> required <code>length</code> <code>float</code> <p>Single step motion path length</p> required <code>init_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>new_pose</code> <code>tuple</code> <p>New pose (new_x, new_y, new_yaw) after moving</p> Source code in <code>src\\python_motion_planning\\curve_generator\\reeds_shepp.py</code> Python<pre><code>def interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\"\"\"\n\tPlanning path interpolation.\n\n\tParameters:\n\t\tmode (str): motion, e.g., L, S, R\n\t\tlength (float): Single step motion path length\n\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\tReturns:\n\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\"\"\"\n\tx, y, yaw = init_pose\n\n\tif mode == \"S\":\n\t\tnew_x = x + length / self.max_curv * math.cos(yaw)\n\t\tnew_y = y + length / self.max_curv * math.sin(yaw)\n\t\tnew_yaw = yaw\n\telif mode == \"L\":\n\t\tnew_x = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw + length\n\telif mode == \"R\":\n\t\tnew_x = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw - length\n\telse:\n\t\traise NotImplementedError\n\n\treturn new_x, new_y, new_yaw\n</code></pre>"},{"location":"api/path_planner/base_path_planner/BasePathPlanner.html","title":"BasePathPlanner","text":""},{"location":"api/path_planner/base_path_planner/BasePathPlanner.html#src.python_motion_planning.path_planner.base_path_planner.BasePathPlanner","title":"<code>src.python_motion_planning.path_planner.base_path_planner.BasePathPlanner</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Class for building path planner.</p> <p>Parameters:</p> Name Type Description Default <code>map_</code> <code>BaseMap</code> <p>The map which the planner is based on.</p> required <code>start</code> <code>tuple</code> <p>The start point of the planner in the map coordinate system.</p> required <code>goal</code> <code>tuple</code> <p>The goal point of the planner in the map coordinate system.</p> required Source code in <code>src\\python_motion_planning\\path_planner\\base_path_planner.py</code> Python<pre><code>class BasePathPlanner(ABC):\n    \"\"\"\n    Class for building path planner.\n\n    Args:\n        map_: The map which the planner is based on.\n        start: The start point of the planner in the map coordinate system.\n        goal: The goal point of the planner in the map coordinate system.\n    \"\"\"\n    def __init__(self, map_: BaseMap, start: tuple, goal: tuple) -&gt; None:\n        super().__init__()\n        self.map_ = map_\n        self.map_.update_esdf()\n        self.start = start\n        self.goal = goal\n        self.failed_info = [], {\"success\": False, \"start\": None, \"goal\": None, \"length\": 0, \"cost\": 0, \"expand\": {}}\n\n    @abstractmethod\n    def plan(self) -&gt; Union[list, dict]:\n        \"\"\"\n        Interface for planning.\n\n        Returns:\n            path: A list containing the path waypoints\n            path_info: A dictionary containing the path information (success, length, cost, expand)\n        \"\"\"\n        return self.failed_info\n\n    def get_cost(self, p1: tuple, p2: tuple) -&gt; float:\n        \"\"\"\n        Get the cost between two points. (default: distance defined in the map)\n\n        Args:\n            p1: Start point.\n            p2: Goal point.\n\n        Returns:\n            cost: Cost between two points.\n        \"\"\"\n        return self.map_.get_distance(p1, p2)\n\n    def get_heuristic(self, point: tuple) -&gt; float:\n        \"\"\"\n        Get the heuristic value of the point. (default: cost between current point and goal point)\n\n        Args:\n            point: Point.\n\n\n        Returns:\n            heuristic: Heuristic value of the point.\n        \"\"\"\n        return self.get_cost(point, self.goal)\n\n\n    def extract_path(self, closed_list: dict) -&gt; tuple:\n        \"\"\"\n        Extract the path based on the CLOSED list.\n\n        Args:\n            closed_list (dict): CLOSED list\n\n        Returns:\n            cost (float): the cost of planned path\n            path (list): the planning path\n        \"\"\"\n        length = 0\n        cost = 0\n        node = closed_list[self.goal]\n        path = [node.current]\n        while node.current != self.start:\n            node_parent = closed_list[node.parent]\n            length += self.map_.get_distance(node.current, node_parent.current)\n            cost += self.get_cost(node.current, node_parent.current)\n            node = node_parent\n            path.append(node.current)\n        path = path[::-1]   # make the order: start -&gt; goal\n        return path, length, cost\n</code></pre>"},{"location":"api/path_planner/base_path_planner/BasePathPlanner.html#src.python_motion_planning.path_planner.base_path_planner.BasePathPlanner.extract_path","title":"<code>extract_path(closed_list)</code>","text":"<p>Extract the path based on the CLOSED list.</p> <p>Parameters:</p> Name Type Description Default <code>closed_list</code> <code>dict</code> <p>CLOSED list</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planned path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\path_planner\\base_path_planner.py</code> Python<pre><code>def extract_path(self, closed_list: dict) -&gt; tuple:\n    \"\"\"\n    Extract the path based on the CLOSED list.\n\n    Args:\n        closed_list (dict): CLOSED list\n\n    Returns:\n        cost (float): the cost of planned path\n        path (list): the planning path\n    \"\"\"\n    length = 0\n    cost = 0\n    node = closed_list[self.goal]\n    path = [node.current]\n    while node.current != self.start:\n        node_parent = closed_list[node.parent]\n        length += self.map_.get_distance(node.current, node_parent.current)\n        cost += self.get_cost(node.current, node_parent.current)\n        node = node_parent\n        path.append(node.current)\n    path = path[::-1]   # make the order: start -&gt; goal\n    return path, length, cost\n</code></pre>"},{"location":"api/path_planner/base_path_planner/BasePathPlanner.html#src.python_motion_planning.path_planner.base_path_planner.BasePathPlanner.get_cost","title":"<code>get_cost(p1, p2)</code>","text":"<p>Get the cost between two points. (default: distance defined in the map)</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>tuple</code> <p>Start point.</p> required <code>p2</code> <code>tuple</code> <p>Goal point.</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>Cost between two points.</p> Source code in <code>src\\python_motion_planning\\path_planner\\base_path_planner.py</code> Python<pre><code>def get_cost(self, p1: tuple, p2: tuple) -&gt; float:\n    \"\"\"\n    Get the cost between two points. (default: distance defined in the map)\n\n    Args:\n        p1: Start point.\n        p2: Goal point.\n\n    Returns:\n        cost: Cost between two points.\n    \"\"\"\n    return self.map_.get_distance(p1, p2)\n</code></pre>"},{"location":"api/path_planner/base_path_planner/BasePathPlanner.html#src.python_motion_planning.path_planner.base_path_planner.BasePathPlanner.get_heuristic","title":"<code>get_heuristic(point)</code>","text":"<p>Get the heuristic value of the point. (default: cost between current point and goal point)</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple</code> <p>Point.</p> required <p>Returns:</p> Name Type Description <code>heuristic</code> <code>float</code> <p>Heuristic value of the point.</p> Source code in <code>src\\python_motion_planning\\path_planner\\base_path_planner.py</code> Python<pre><code>def get_heuristic(self, point: tuple) -&gt; float:\n    \"\"\"\n    Get the heuristic value of the point. (default: cost between current point and goal point)\n\n    Args:\n        point: Point.\n\n\n    Returns:\n        heuristic: Heuristic value of the point.\n    \"\"\"\n    return self.get_cost(point, self.goal)\n</code></pre>"},{"location":"api/path_planner/base_path_planner/BasePathPlanner.html#src.python_motion_planning.path_planner.base_path_planner.BasePathPlanner.plan","title":"<code>plan()</code>  <code>abstractmethod</code>","text":"<p>Interface for planning.</p> <p>Returns:</p> Name Type Description <code>path</code> <code>Union[list, dict]</code> <p>A list containing the path waypoints</p> <code>path_info</code> <code>Union[list, dict]</code> <p>A dictionary containing the path information (success, length, cost, expand)</p> Source code in <code>src\\python_motion_planning\\path_planner\\base_path_planner.py</code> Python<pre><code>@abstractmethod\ndef plan(self) -&gt; Union[list, dict]:\n    \"\"\"\n    Interface for planning.\n\n    Returns:\n        path: A list containing the path waypoints\n        path_info: A dictionary containing the path information (success, length, cost, expand)\n    \"\"\"\n    return self.failed_info\n</code></pre>"},{"location":"api/path_planner/graph_search/a_star/AStar.html","title":"AStar","text":""},{"location":"api/path_planner/graph_search/a_star/AStar.html#src.python_motion_planning.path_planner.graph_search.a_star.AStar","title":"<code>src.python_motion_planning.path_planner.graph_search.a_star.AStar</code>","text":"<p>               Bases: <code>Dijkstra</code></p> <p>Class for A* path planner.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>*kwargs</code> <p>see the parent class.</p> <code>{}</code> References <p>[1] A Formal Basis for the heuristic Determination of Minimum Cost Paths</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n&gt;&gt;&gt; planner = AStar(map_=map_, start=(5, 5), goal=(10, 10))\n&gt;&gt;&gt; planner.plan()\n([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0.0)}})\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n&gt;&gt;&gt; planner.plan()\n([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0.0)}})\n</code></pre> Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\a_star.py</code> Python<pre><code>class AStar(Dijkstra):\n    \"\"\"\n    Class for A* path planner.\n\n    Args:\n        *args: see the parent class.\n        *kwargs: see the parent class.\n\n    References:\n        [1] A Formal Basis for the heuristic Determination of Minimum Cost Paths\n\n    Examples:\n        &gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n        &gt;&gt;&gt; planner = AStar(map_=map_, start=(5, 5), goal=(10, 10))\n        &gt;&gt;&gt; planner.plan()\n        ([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0.0)}})\n\n        &gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n        &gt;&gt;&gt; planner.plan()\n        ([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0.0)}})\n    \"\"\"\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n\n    def __str__(self) -&gt; str:\n        return \"A*\"\n\n    def plan(self) -&gt; Union[list, dict]:\n        \"\"\"\n        Interface for planning.\n\n        Returns:\n            path: A list containing the path waypoints\n            path_info: A dictionary containing the path information (success, length, cost, expand)\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        start_node = Node(self.start, None, 0, self.get_heuristic(self.start))\n        heapq.heappush(OPEN, start_node)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # obstacle found\n            if not self.map_.is_expandable(node.current, node.parent):\n                continue\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node.current == self.goal:\n                CLOSED[node.current] = node\n                path, length, cost = self.extract_path(CLOSED)\n                return path, {\n                    \"success\": True, \n                    \"start\": self.start, \n                    \"goal\": self.goal, \n                    \"length\": length, \n                    \"cost\": cost, \n                    \"expand\": CLOSED\n                }\n\n            for node_n in self.map_.get_neighbors(node): \n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                node_n.g = node.g + self.get_cost(node.current, node_n.current)\n                node_n.h = self.get_heuristic(node_n.current)\n\n                # goal found\n                if node_n.current == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n\n        self.failed_info[1][\"expand\"] = CLOSED\n        return self.failed_info\n</code></pre>"},{"location":"api/path_planner/graph_search/a_star/AStar.html#src.python_motion_planning.path_planner.graph_search.a_star.AStar.plan","title":"<code>plan()</code>","text":"<p>Interface for planning.</p> <p>Returns:</p> Name Type Description <code>path</code> <code>Union[list, dict]</code> <p>A list containing the path waypoints</p> <code>path_info</code> <code>Union[list, dict]</code> <p>A dictionary containing the path information (success, length, cost, expand)</p> Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\a_star.py</code> Python<pre><code>def plan(self) -&gt; Union[list, dict]:\n    \"\"\"\n    Interface for planning.\n\n    Returns:\n        path: A list containing the path waypoints\n        path_info: A dictionary containing the path information (success, length, cost, expand)\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    start_node = Node(self.start, None, 0, self.get_heuristic(self.start))\n    heapq.heappush(OPEN, start_node)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # obstacle found\n        if not self.map_.is_expandable(node.current, node.parent):\n            continue\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node.current == self.goal:\n            CLOSED[node.current] = node\n            path, length, cost = self.extract_path(CLOSED)\n            return path, {\n                \"success\": True, \n                \"start\": self.start, \n                \"goal\": self.goal, \n                \"length\": length, \n                \"cost\": cost, \n                \"expand\": CLOSED\n            }\n\n        for node_n in self.map_.get_neighbors(node): \n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            node_n.g = node.g + self.get_cost(node.current, node_n.current)\n            node_n.h = self.get_heuristic(node_n.current)\n\n            # goal found\n            if node_n.current == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n\n    self.failed_info[1][\"expand\"] = CLOSED\n    return self.failed_info\n</code></pre>"},{"location":"api/path_planner/graph_search/dijkstra/Dijkstra.html","title":"Dijkstra","text":""},{"location":"api/path_planner/graph_search/dijkstra/Dijkstra.html#src.python_motion_planning.path_planner.graph_search.dijkstra.Dijkstra","title":"<code>src.python_motion_planning.path_planner.graph_search.dijkstra.Dijkstra</code>","text":"<p>               Bases: <code>BasePathPlanner</code></p> <p>Class for Dijkstra path planner.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>*kwargs</code> <p>see the parent class.</p> <code>{}</code> References <p>[1] A Note on Two Problems in Connexion with Graphs</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n&gt;&gt;&gt; planner = Dijkstra(map_=map_, start=(5, 5), goal=(10, 10))\n&gt;&gt;&gt; planner.plan()\n([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 0), (4, 5): Node((4, 5), (5, 5), 1.0, 0), (6, 5): Node((6, 5), (5, 5), 1.0, 0), (5, 4): Node((5, 4), (5, 5), 1.0, 0), (5, 6): Node((5, 6), (5, 5), 1.0, 0), (4, 6): Node((4, 6), (5, 5), 1.4142135623730951, 0), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 0), (6, 4): Node((6, 4), (5, 5), 1.4142135623730951, 0), (4, 4): Node((4, 4), (5, 5), 1.4142135623730951, 0), (5, 7): Node((5, 7), (5, 6), 2.0, 0), (5, 3): Node((5, 3), (5, 4), 2.0, 0), (3, 5): Node((3, 5), (4, 5), 2.0, 0), (7, 5): Node((7, 5), (6, 5), 2.0, 0), (4, 7): Node((4, 7), (4, 6), 2.414213562373095, 0), (3, 6): Node((3, 6), (4, 6), 2.414213562373095, 0), (6, 7): Node((6, 7), (5, 6), 2.414213562373095, 0), (4, 3): Node((4, 3), (4, 4), 2.414213562373095, 0), (6, 3): Node((6, 3), (5, 4), 2.414213562373095, 0), (3, 4): Node((3, 4), (4, 4), 2.414213562373095, 0), (7, 6): Node((7, 6), (6, 5), 2.414213562373095, 0), (7, 4): Node((7, 4), (6, 4), 2.414213562373095, 0), (3, 7): Node((3, 7), (4, 6), 2.8284271247461903, 0), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 0), (3, 3): Node((3, 3), (4, 4), 2.8284271247461903, 0), (7, 3): Node((7, 3), (6, 4), 2.8284271247461903, 0), (8, 5): Node((8, 5), (7, 5), 3.0, 0), (2, 5): Node((2, 5), (3, 5), 3.0, 0), (5, 2): Node((5, 2), (5, 3), 3.0, 0), (5, 8): Node((5, 8), (5, 7), 3.0, 0), (4, 2): Node((4, 2), (4, 3), 3.414213562373095, 0), (6, 8): Node((6, 8), (5, 7), 3.414213562373095, 0), (8, 6): Node((8, 6), (7, 6), 3.414213562373095, 0), (8, 4): Node((8, 4), (7, 5), 3.414213562373095, 0), (4, 8): Node((4, 8), (4, 7), 3.414213562373095, 0), (2, 6): Node((2, 6), (3, 6), 3.414213562373095, 0), (2, 4): Node((2, 4), (3, 5), 3.414213562373095, 0), (6, 2): Node((6, 2), (6, 3), 3.414213562373095, 0), (3, 2): Node((3, 2), (4, 3), 3.82842712474619, 0), (2, 7): Node((2, 7), (3, 6), 3.82842712474619, 0), (3, 8): Node((3, 8), (4, 7), 3.82842712474619, 0), (7, 8): Node((7, 8), (6, 7), 3.82842712474619, 0), (8, 7): Node((8, 7), (7, 6), 3.82842712474619, 0), (7, 2): Node((7, 2), (6, 3), 3.82842712474619, 0), (8, 3): Node((8, 3), (7, 4), 3.82842712474619, 0), (2, 3): Node((2, 3), (3, 4), 3.82842712474619, 0), (9, 5): Node((9, 5), (8, 5), 4.0, 0), (5, 9): Node((5, 9), (5, 8), 4.0, 0), (5, 1): Node((5, 1), (5, 2), 4.0, 0), (1, 5): Node((1, 5), (2, 5), 4.0, 0), (8, 2): Node((8, 2), (7, 3), 4.242640687119286, 0), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 0), (2, 8): Node((2, 8), (3, 7), 4.242640687119286, 0), (2, 2): Node((2, 2), (3, 3), 4.242640687119286, 0), (9, 4): Node((9, 4), (8, 5), 4.414213562373095, 0), (9, 6): Node((9, 6), (8, 5), 4.414213562373095, 0), (4, 1): Node((4, 1), (4, 2), 4.414213562373095, 0), (1, 6): Node((1, 6), (2, 6), 4.414213562373095, 0), (4, 9): Node((4, 9), (5, 8), 4.414213562373095, 0), (6, 9): Node((6, 9), (6, 8), 4.414213562373095, 0), (6, 1): Node((6, 1), (5, 2), 4.414213562373095, 0), (1, 4): Node((1, 4), (2, 5), 4.414213562373095, 0), (1, 7): Node((1, 7), (2, 6), 4.82842712474619, 0), (7, 1): Node((7, 1), (7, 2), 4.82842712474619, 0), (7, 9): Node((7, 9), (6, 8), 4.82842712474619, 0), (9, 3): Node((9, 3), (8, 4), 4.82842712474619, 0), (3, 1): Node((3, 1), (3, 2), 4.82842712474619, 0), (9, 7): Node((9, 7), (8, 6), 4.82842712474619, 0), (1, 3): Node((1, 3), (2, 3), 4.82842712474619, 0), (3, 9): Node((3, 9), (3, 8), 4.82842712474619, 0), (5, 10): Node((5, 10), (5, 9), 5.0, 0), (0, 5): Node((0, 5), (1, 5), 5.0, 0), (10, 5): Node((10, 5), (9, 5), 5.0, 0), (5, 0): Node((5, 0), (5, 1), 5.0, 0), (2, 9): Node((2, 9), (3, 8), 5.242640687119285, 0), (8, 1): Node((8, 1), (7, 2), 5.242640687119285, 0), (1, 8): Node((1, 8), (2, 7), 5.242640687119285, 0), (2, 1): Node((2, 1), (3, 2), 5.242640687119285, 0), (8, 9): Node((8, 9), (7, 8), 5.242640687119285, 0), (9, 8): Node((9, 8), (8, 7), 5.242640687119285, 0), (9, 2): Node((9, 2), (8, 3), 5.242640687119285, 0), (1, 2): Node((1, 2), (2, 3), 5.242640687119285, 0), (0, 6): Node((0, 6), (1, 6), 5.414213562373095, 0), (4, 0): Node((4, 0), (4, 1), 5.414213562373095, 0), (10, 6): Node((10, 6), (9, 6), 5.414213562373095, 0), (10, 4): Node((10, 4), (9, 4), 5.414213562373095, 0), (0, 4): Node((0, 4), (1, 5), 5.414213562373095, 0), (4, 10): Node((4, 10), (5, 9), 5.414213562373095, 0), (6, 10): Node((6, 10), (5, 9), 5.414213562373095, 0), (6, 0): Node((6, 0), (5, 1), 5.414213562373095, 0), (1, 1): Node((1, 1), (2, 2), 5.656854249492381, 0), (9, 1): Node((9, 1), (8, 2), 5.656854249492381, 0), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 0), (1, 9): Node((1, 9), (2, 8), 5.656854249492381, 0), (0, 3): Node((0, 3), (1, 4), 5.82842712474619, 0), (3, 0): Node((3, 0), (4, 1), 5.82842712474619, 0), (10, 3): Node((10, 3), (9, 4), 5.82842712474619, 0), (10, 7): Node((10, 7), (9, 6), 5.82842712474619, 0), (7, 0): Node((7, 0), (7, 1), 5.82842712474619, 0), (0, 7): Node((0, 7), (1, 7), 5.82842712474619, 0), (3, 10): Node((3, 10), (3, 9), 5.82842712474619, 0), (7, 10): Node((7, 10), (6, 9), 5.82842712474619, 0), (5, 11): Node((5, 11), (5, 10), 6.0, 0), (11, 5): Node((11, 5), (10, 5), 6.0, 0), (8, 0): Node((8, 0), (8, 1), 6.242640687119285, 0), (10, 8): Node((10, 8), (9, 8), 6.242640687119285, 0), (0, 2): Node((0, 2), (1, 3), 6.242640687119285, 0), (8, 10): Node((8, 10), (7, 9), 6.242640687119285, 0), (0, 8): Node((0, 8), (1, 7), 6.242640687119285, 0), (2, 10): Node((2, 10), (2, 9), 6.242640687119285, 0), (10, 2): Node((10, 2), (9, 2), 6.242640687119285, 0), (2, 0): Node((2, 0), (3, 1), 6.242640687119285, 0), (6, 11): Node((6, 11), (6, 10), 6.414213562373095, 0), (11, 6): Node((11, 6), (10, 6), 6.414213562373095, 0), (11, 4): Node((11, 4), (10, 4), 6.414213562373095, 0), (4, 11): Node((4, 11), (4, 10), 6.414213562373095, 0), (1, 10): Node((1, 10), (2, 9), 6.65685424949238, 0), (0, 1): Node((0, 1), (1, 2), 6.65685424949238, 0), (10, 1): Node((10, 1), (9, 2), 6.65685424949238, 0), (9, 0): Node((9, 0), (8, 1), 6.65685424949238, 0), (0, 9): Node((0, 9), (1, 8), 6.65685424949238, 0), (10, 9): Node((10, 9), (9, 8), 6.65685424949238, 0), (1, 0): Node((1, 0), (2, 1), 6.65685424949238, 0), (9, 10): Node((9, 10), (8, 9), 6.65685424949238, 0), (7, 11): Node((7, 11), (6, 10), 6.82842712474619, 0), (11, 7): Node((11, 7), (10, 6), 6.82842712474619, 0), (11, 3): Node((11, 3), (10, 4), 6.82842712474619, 0), (3, 11): Node((3, 11), (4, 10), 6.82842712474619, 0), (5, 12): Node((5, 12), (5, 11), 7.0, 0), (12, 5): Node((12, 5), (11, 5), 7.0, 0), (0, 10): Node((0, 10), (1, 9), 7.0710678118654755, 0), (10, 0): Node((10, 0), (9, 1), 7.0710678118654755, 0), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0)}})\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n&gt;&gt;&gt; planner.plan()\n([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 0), (4, 5): Node((4, 5), (5, 5), 1.0, 0), (6, 5): Node((6, 5), (5, 5), 1.0, 0), (5, 4): Node((5, 4), (5, 5), 1.0, 0), (5, 6): Node((5, 6), (5, 5), 1.0, 0), (4, 6): Node((4, 6), (5, 5), 1.4142135623730951, 0), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 0), (6, 4): Node((6, 4), (5, 5), 1.4142135623730951, 0), (4, 4): Node((4, 4), (5, 5), 1.4142135623730951, 0), (5, 7): Node((5, 7), (5, 6), 2.0, 0), (5, 3): Node((5, 3), (5, 4), 2.0, 0), (3, 5): Node((3, 5), (4, 5), 2.0, 0), (7, 5): Node((7, 5), (6, 5), 2.0, 0), (6, 7): Node((6, 7), (6, 6), 2.414213562373095, 0), (4, 7): Node((4, 7), (4, 6), 2.414213562373095, 0), (4, 3): Node((4, 3), (4, 4), 2.414213562373095, 0), (6, 3): Node((6, 3), (5, 4), 2.414213562373095, 0), (3, 4): Node((3, 4), (4, 4), 2.414213562373095, 0), (3, 6): Node((3, 6), (4, 5), 2.414213562373095, 0), (7, 6): Node((7, 6), (6, 5), 2.414213562373095, 0), (7, 4): Node((7, 4), (6, 4), 2.414213562373095, 0), (3, 7): Node((3, 7), (4, 6), 2.8284271247461903, 0), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 0), (3, 3): Node((3, 3), (4, 4), 2.8284271247461903, 0), (7, 3): Node((7, 3), (6, 4), 2.8284271247461903, 0), (8, 5): Node((8, 5), (7, 5), 3.0, 0), (2, 5): Node((2, 5), (3, 5), 3.0, 0), (5, 2): Node((5, 2), (5, 3), 3.0, 0), (5, 8): Node((5, 8), (5, 7), 3.0, 0), (8, 4): Node((8, 4), (7, 5), 3.414213562373095, 0), (2, 4): Node((2, 4), (3, 4), 3.414213562373095, 0), (8, 6): Node((8, 6), (7, 5), 3.414213562373095, 0), (6, 2): Node((6, 2), (6, 3), 3.414213562373095, 0), (4, 8): Node((4, 8), (4, 7), 3.414213562373095, 0), (6, 8): Node((6, 8), (6, 7), 3.414213562373095, 0), (2, 6): Node((2, 6), (3, 5), 3.414213562373095, 0), (4, 2): Node((4, 2), (4, 3), 3.414213562373095, 0), (7, 8): Node((7, 8), (6, 7), 3.82842712474619, 0), (2, 3): Node((2, 3), (3, 4), 3.82842712474619, 0), (8, 7): Node((8, 7), (7, 6), 3.82842712474619, 0), (7, 2): Node((7, 2), (6, 3), 3.82842712474619, 0), (3, 2): Node((3, 2), (4, 3), 3.82842712474619, 0), (3, 8): Node((3, 8), (4, 7), 3.82842712474619, 0), (2, 7): Node((2, 7), (3, 6), 3.82842712474619, 0), (8, 3): Node((8, 3), (7, 4), 3.82842712474619, 0), (5, 1): Node((5, 1), (5, 2), 4.0, 0), (5, 9): Node((5, 9), (5, 8), 4.0, 0), (9, 5): Node((9, 5), (8, 5), 4.0, 0), (1, 5): Node((1, 5), (2, 5), 4.0, 0), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 0), (8, 2): Node((8, 2), (7, 3), 4.242640687119286, 0), (2, 2): Node((2, 2), (3, 3), 4.242640687119286, 0), (2, 8): Node((2, 8), (3, 7), 4.242640687119286, 0), (9, 4): Node((9, 4), (8, 4), 4.414213562373095, 0), (6, 1): Node((6, 1), (6, 2), 4.414213562373095, 0), (6, 9): Node((6, 9), (5, 8), 4.414213562373095, 0), (4, 9): Node((4, 9), (4, 8), 4.414213562373095, 0), (9, 6): Node((9, 6), (8, 5), 4.414213562373095, 0), (1, 4): Node((1, 4), (2, 4), 4.414213562373095, 0), (4, 1): Node((4, 1), (5, 2), 4.414213562373095, 0), (1, 6): Node((1, 6), (2, 5), 4.414213562373095, 0), (7, 1): Node((7, 1), (6, 2), 4.82842712474619, 0), (3, 9): Node((3, 9), (3, 8), 4.82842712474619, 0), (9, 3): Node((9, 3), (8, 3), 4.82842712474619, 0), (9, 7): Node((9, 7), (8, 6), 4.82842712474619, 0), (1, 3): Node((1, 3), (2, 3), 4.82842712474619, 0), (7, 9): Node((7, 9), (7, 8), 4.82842712474619, 0), (1, 7): Node((1, 7), (2, 6), 4.82842712474619, 0), (3, 1): Node((3, 1), (3, 2), 4.82842712474619, 0), (5, 10): Node((5, 10), (5, 9), 5.0, 0), (5, 0): Node((5, 0), (5, 1), 5.0, 0), (0, 5): Node((0, 5), (1, 5), 5.0, 0), (10, 5): Node((10, 5), (9, 5), 5.0, 0), (9, 2): Node((9, 2), (8, 3), 5.242640687119285, 0), (9, 8): Node((9, 8), (8, 7), 5.242640687119285, 0), (8, 9): Node((8, 9), (7, 8), 5.242640687119285, 0), (1, 2): Node((1, 2), (2, 3), 5.242640687119285, 0), (2, 9): Node((2, 9), (3, 8), 5.242640687119285, 0), (8, 1): Node((8, 1), (7, 2), 5.242640687119285, 0), (2, 1): Node((2, 1), (3, 2), 5.242640687119285, 0), (1, 8): Node((1, 8), (2, 7), 5.242640687119285, 0), (0, 6): Node((0, 6), (1, 5), 5.414213562373095, 0), (4, 0): Node((4, 0), (4, 1), 5.414213562373095, 0), (6, 10): Node((6, 10), (6, 9), 5.414213562373095, 0), (6, 0): Node((6, 0), (6, 1), 5.414213562373095, 0), (10, 4): Node((10, 4), (9, 4), 5.414213562373095, 0), (4, 10): Node((4, 10), (5, 9), 5.414213562373095, 0), (0, 4): Node((0, 4), (1, 5), 5.414213562373095, 0), (10, 6): Node((10, 6), (9, 6), 5.414213562373095, 0), (1, 9): Node((1, 9), (2, 8), 5.656854249492381, 0), (1, 1): Node((1, 1), (2, 2), 5.656854249492381, 0), (9, 1): Node((9, 1), (8, 2), 5.656854249492381, 0), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 0), (7, 10): Node((7, 10), (6, 9), 5.82842712474619, 0), (7, 0): Node((7, 0), (6, 1), 5.82842712474619, 0), (10, 3): Node((10, 3), (9, 4), 5.82842712474619, 0), (3, 0): Node((3, 0), (4, 1), 5.82842712474619, 0), (3, 10): Node((3, 10), (3, 9), 5.82842712474619, 0), (10, 7): Node((10, 7), (9, 7), 5.82842712474619, 0), (0, 3): Node((0, 3), (1, 4), 5.82842712474619, 0), (0, 7): Node((0, 7), (1, 7), 5.82842712474619, 0), (11, 5): Node((11, 5), (10, 5), 6.0, 0), (5, 11): Node((5, 11), (5, 10), 6.0, 0), (0, 8): Node((0, 8), (1, 8), 6.242640687119285, 0), (8, 10): Node((8, 10), (8, 9), 6.242640687119285, 0), (10, 2): Node((10, 2), (9, 3), 6.242640687119285, 0), (8, 0): Node((8, 0), (8, 1), 6.242640687119285, 0), (2, 10): Node((2, 10), (3, 9), 6.242640687119285, 0), (10, 8): Node((10, 8), (9, 7), 6.242640687119285, 0), (2, 0): Node((2, 0), (3, 1), 6.242640687119285, 0), (0, 2): Node((0, 2), (1, 2), 6.242640687119285, 0), (11, 4): Node((11, 4), (10, 5), 6.414213562373095, 0), (4, 11): Node((4, 11), (5, 10), 6.414213562373095, 0), (11, 6): Node((11, 6), (10, 5), 6.414213562373095, 0), (6, 11): Node((6, 11), (6, 10), 6.414213562373095, 0), (0, 1): Node((0, 1), (1, 2), 6.65685424949238, 0), (9, 0): Node((9, 0), (8, 1), 6.65685424949238, 0), (0, 9): Node((0, 9), (1, 8), 6.65685424949238, 0), (1, 0): Node((1, 0), (2, 1), 6.65685424949238, 0), (9, 10): Node((9, 10), (8, 9), 6.65685424949238, 0), (10, 9): Node((10, 9), (9, 8), 6.65685424949238, 0), (10, 1): Node((10, 1), (9, 2), 6.65685424949238, 0), (1, 10): Node((1, 10), (2, 9), 6.65685424949238, 0), (7, 11): Node((7, 11), (6, 10), 6.82842712474619, 0), (11, 3): Node((11, 3), (10, 3), 6.82842712474619, 0), (3, 11): Node((3, 11), (3, 10), 6.82842712474619, 0), (11, 7): Node((11, 7), (10, 7), 6.82842712474619, 0), (5, 12): Node((5, 12), (5, 11), 7.0, 0), (12, 5): Node((12, 5), (11, 5), 7.0, 0), (0, 10): Node((0, 10), (1, 9), 7.0710678118654755, 0), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0)}})\n</code></pre> Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\dijkstra.py</code> Python<pre><code>class Dijkstra(BasePathPlanner):\n    \"\"\"\n    Class for Dijkstra path planner.\n\n    Args:\n        *args: see the parent class.\n        *kwargs: see the parent class.\n\n    References:\n        [1] A Note on Two Problems in Connexion with Graphs\n\n    Examples:\n        &gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n        &gt;&gt;&gt; planner = Dijkstra(map_=map_, start=(5, 5), goal=(10, 10))\n        &gt;&gt;&gt; planner.plan()\n        ([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 0), (4, 5): Node((4, 5), (5, 5), 1.0, 0), (6, 5): Node((6, 5), (5, 5), 1.0, 0), (5, 4): Node((5, 4), (5, 5), 1.0, 0), (5, 6): Node((5, 6), (5, 5), 1.0, 0), (4, 6): Node((4, 6), (5, 5), 1.4142135623730951, 0), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 0), (6, 4): Node((6, 4), (5, 5), 1.4142135623730951, 0), (4, 4): Node((4, 4), (5, 5), 1.4142135623730951, 0), (5, 7): Node((5, 7), (5, 6), 2.0, 0), (5, 3): Node((5, 3), (5, 4), 2.0, 0), (3, 5): Node((3, 5), (4, 5), 2.0, 0), (7, 5): Node((7, 5), (6, 5), 2.0, 0), (4, 7): Node((4, 7), (4, 6), 2.414213562373095, 0), (3, 6): Node((3, 6), (4, 6), 2.414213562373095, 0), (6, 7): Node((6, 7), (5, 6), 2.414213562373095, 0), (4, 3): Node((4, 3), (4, 4), 2.414213562373095, 0), (6, 3): Node((6, 3), (5, 4), 2.414213562373095, 0), (3, 4): Node((3, 4), (4, 4), 2.414213562373095, 0), (7, 6): Node((7, 6), (6, 5), 2.414213562373095, 0), (7, 4): Node((7, 4), (6, 4), 2.414213562373095, 0), (3, 7): Node((3, 7), (4, 6), 2.8284271247461903, 0), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 0), (3, 3): Node((3, 3), (4, 4), 2.8284271247461903, 0), (7, 3): Node((7, 3), (6, 4), 2.8284271247461903, 0), (8, 5): Node((8, 5), (7, 5), 3.0, 0), (2, 5): Node((2, 5), (3, 5), 3.0, 0), (5, 2): Node((5, 2), (5, 3), 3.0, 0), (5, 8): Node((5, 8), (5, 7), 3.0, 0), (4, 2): Node((4, 2), (4, 3), 3.414213562373095, 0), (6, 8): Node((6, 8), (5, 7), 3.414213562373095, 0), (8, 6): Node((8, 6), (7, 6), 3.414213562373095, 0), (8, 4): Node((8, 4), (7, 5), 3.414213562373095, 0), (4, 8): Node((4, 8), (4, 7), 3.414213562373095, 0), (2, 6): Node((2, 6), (3, 6), 3.414213562373095, 0), (2, 4): Node((2, 4), (3, 5), 3.414213562373095, 0), (6, 2): Node((6, 2), (6, 3), 3.414213562373095, 0), (3, 2): Node((3, 2), (4, 3), 3.82842712474619, 0), (2, 7): Node((2, 7), (3, 6), 3.82842712474619, 0), (3, 8): Node((3, 8), (4, 7), 3.82842712474619, 0), (7, 8): Node((7, 8), (6, 7), 3.82842712474619, 0), (8, 7): Node((8, 7), (7, 6), 3.82842712474619, 0), (7, 2): Node((7, 2), (6, 3), 3.82842712474619, 0), (8, 3): Node((8, 3), (7, 4), 3.82842712474619, 0), (2, 3): Node((2, 3), (3, 4), 3.82842712474619, 0), (9, 5): Node((9, 5), (8, 5), 4.0, 0), (5, 9): Node((5, 9), (5, 8), 4.0, 0), (5, 1): Node((5, 1), (5, 2), 4.0, 0), (1, 5): Node((1, 5), (2, 5), 4.0, 0), (8, 2): Node((8, 2), (7, 3), 4.242640687119286, 0), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 0), (2, 8): Node((2, 8), (3, 7), 4.242640687119286, 0), (2, 2): Node((2, 2), (3, 3), 4.242640687119286, 0), (9, 4): Node((9, 4), (8, 5), 4.414213562373095, 0), (9, 6): Node((9, 6), (8, 5), 4.414213562373095, 0), (4, 1): Node((4, 1), (4, 2), 4.414213562373095, 0), (1, 6): Node((1, 6), (2, 6), 4.414213562373095, 0), (4, 9): Node((4, 9), (5, 8), 4.414213562373095, 0), (6, 9): Node((6, 9), (6, 8), 4.414213562373095, 0), (6, 1): Node((6, 1), (5, 2), 4.414213562373095, 0), (1, 4): Node((1, 4), (2, 5), 4.414213562373095, 0), (1, 7): Node((1, 7), (2, 6), 4.82842712474619, 0), (7, 1): Node((7, 1), (7, 2), 4.82842712474619, 0), (7, 9): Node((7, 9), (6, 8), 4.82842712474619, 0), (9, 3): Node((9, 3), (8, 4), 4.82842712474619, 0), (3, 1): Node((3, 1), (3, 2), 4.82842712474619, 0), (9, 7): Node((9, 7), (8, 6), 4.82842712474619, 0), (1, 3): Node((1, 3), (2, 3), 4.82842712474619, 0), (3, 9): Node((3, 9), (3, 8), 4.82842712474619, 0), (5, 10): Node((5, 10), (5, 9), 5.0, 0), (0, 5): Node((0, 5), (1, 5), 5.0, 0), (10, 5): Node((10, 5), (9, 5), 5.0, 0), (5, 0): Node((5, 0), (5, 1), 5.0, 0), (2, 9): Node((2, 9), (3, 8), 5.242640687119285, 0), (8, 1): Node((8, 1), (7, 2), 5.242640687119285, 0), (1, 8): Node((1, 8), (2, 7), 5.242640687119285, 0), (2, 1): Node((2, 1), (3, 2), 5.242640687119285, 0), (8, 9): Node((8, 9), (7, 8), 5.242640687119285, 0), (9, 8): Node((9, 8), (8, 7), 5.242640687119285, 0), (9, 2): Node((9, 2), (8, 3), 5.242640687119285, 0), (1, 2): Node((1, 2), (2, 3), 5.242640687119285, 0), (0, 6): Node((0, 6), (1, 6), 5.414213562373095, 0), (4, 0): Node((4, 0), (4, 1), 5.414213562373095, 0), (10, 6): Node((10, 6), (9, 6), 5.414213562373095, 0), (10, 4): Node((10, 4), (9, 4), 5.414213562373095, 0), (0, 4): Node((0, 4), (1, 5), 5.414213562373095, 0), (4, 10): Node((4, 10), (5, 9), 5.414213562373095, 0), (6, 10): Node((6, 10), (5, 9), 5.414213562373095, 0), (6, 0): Node((6, 0), (5, 1), 5.414213562373095, 0), (1, 1): Node((1, 1), (2, 2), 5.656854249492381, 0), (9, 1): Node((9, 1), (8, 2), 5.656854249492381, 0), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 0), (1, 9): Node((1, 9), (2, 8), 5.656854249492381, 0), (0, 3): Node((0, 3), (1, 4), 5.82842712474619, 0), (3, 0): Node((3, 0), (4, 1), 5.82842712474619, 0), (10, 3): Node((10, 3), (9, 4), 5.82842712474619, 0), (10, 7): Node((10, 7), (9, 6), 5.82842712474619, 0), (7, 0): Node((7, 0), (7, 1), 5.82842712474619, 0), (0, 7): Node((0, 7), (1, 7), 5.82842712474619, 0), (3, 10): Node((3, 10), (3, 9), 5.82842712474619, 0), (7, 10): Node((7, 10), (6, 9), 5.82842712474619, 0), (5, 11): Node((5, 11), (5, 10), 6.0, 0), (11, 5): Node((11, 5), (10, 5), 6.0, 0), (8, 0): Node((8, 0), (8, 1), 6.242640687119285, 0), (10, 8): Node((10, 8), (9, 8), 6.242640687119285, 0), (0, 2): Node((0, 2), (1, 3), 6.242640687119285, 0), (8, 10): Node((8, 10), (7, 9), 6.242640687119285, 0), (0, 8): Node((0, 8), (1, 7), 6.242640687119285, 0), (2, 10): Node((2, 10), (2, 9), 6.242640687119285, 0), (10, 2): Node((10, 2), (9, 2), 6.242640687119285, 0), (2, 0): Node((2, 0), (3, 1), 6.242640687119285, 0), (6, 11): Node((6, 11), (6, 10), 6.414213562373095, 0), (11, 6): Node((11, 6), (10, 6), 6.414213562373095, 0), (11, 4): Node((11, 4), (10, 4), 6.414213562373095, 0), (4, 11): Node((4, 11), (4, 10), 6.414213562373095, 0), (1, 10): Node((1, 10), (2, 9), 6.65685424949238, 0), (0, 1): Node((0, 1), (1, 2), 6.65685424949238, 0), (10, 1): Node((10, 1), (9, 2), 6.65685424949238, 0), (9, 0): Node((9, 0), (8, 1), 6.65685424949238, 0), (0, 9): Node((0, 9), (1, 8), 6.65685424949238, 0), (10, 9): Node((10, 9), (9, 8), 6.65685424949238, 0), (1, 0): Node((1, 0), (2, 1), 6.65685424949238, 0), (9, 10): Node((9, 10), (8, 9), 6.65685424949238, 0), (7, 11): Node((7, 11), (6, 10), 6.82842712474619, 0), (11, 7): Node((11, 7), (10, 6), 6.82842712474619, 0), (11, 3): Node((11, 3), (10, 4), 6.82842712474619, 0), (3, 11): Node((3, 11), (4, 10), 6.82842712474619, 0), (5, 12): Node((5, 12), (5, 11), 7.0, 0), (12, 5): Node((12, 5), (11, 5), 7.0, 0), (0, 10): Node((0, 10), (1, 9), 7.0710678118654755, 0), (10, 0): Node((10, 0), (9, 1), 7.0710678118654755, 0), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0)}})\n\n        &gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n        &gt;&gt;&gt; planner.plan()\n        ([(5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 0), (4, 5): Node((4, 5), (5, 5), 1.0, 0), (6, 5): Node((6, 5), (5, 5), 1.0, 0), (5, 4): Node((5, 4), (5, 5), 1.0, 0), (5, 6): Node((5, 6), (5, 5), 1.0, 0), (4, 6): Node((4, 6), (5, 5), 1.4142135623730951, 0), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 0), (6, 4): Node((6, 4), (5, 5), 1.4142135623730951, 0), (4, 4): Node((4, 4), (5, 5), 1.4142135623730951, 0), (5, 7): Node((5, 7), (5, 6), 2.0, 0), (5, 3): Node((5, 3), (5, 4), 2.0, 0), (3, 5): Node((3, 5), (4, 5), 2.0, 0), (7, 5): Node((7, 5), (6, 5), 2.0, 0), (6, 7): Node((6, 7), (6, 6), 2.414213562373095, 0), (4, 7): Node((4, 7), (4, 6), 2.414213562373095, 0), (4, 3): Node((4, 3), (4, 4), 2.414213562373095, 0), (6, 3): Node((6, 3), (5, 4), 2.414213562373095, 0), (3, 4): Node((3, 4), (4, 4), 2.414213562373095, 0), (3, 6): Node((3, 6), (4, 5), 2.414213562373095, 0), (7, 6): Node((7, 6), (6, 5), 2.414213562373095, 0), (7, 4): Node((7, 4), (6, 4), 2.414213562373095, 0), (3, 7): Node((3, 7), (4, 6), 2.8284271247461903, 0), (7, 7): Node((7, 7), (6, 6), 2.8284271247461903, 0), (3, 3): Node((3, 3), (4, 4), 2.8284271247461903, 0), (7, 3): Node((7, 3), (6, 4), 2.8284271247461903, 0), (8, 5): Node((8, 5), (7, 5), 3.0, 0), (2, 5): Node((2, 5), (3, 5), 3.0, 0), (5, 2): Node((5, 2), (5, 3), 3.0, 0), (5, 8): Node((5, 8), (5, 7), 3.0, 0), (8, 4): Node((8, 4), (7, 5), 3.414213562373095, 0), (2, 4): Node((2, 4), (3, 4), 3.414213562373095, 0), (8, 6): Node((8, 6), (7, 5), 3.414213562373095, 0), (6, 2): Node((6, 2), (6, 3), 3.414213562373095, 0), (4, 8): Node((4, 8), (4, 7), 3.414213562373095, 0), (6, 8): Node((6, 8), (6, 7), 3.414213562373095, 0), (2, 6): Node((2, 6), (3, 5), 3.414213562373095, 0), (4, 2): Node((4, 2), (4, 3), 3.414213562373095, 0), (7, 8): Node((7, 8), (6, 7), 3.82842712474619, 0), (2, 3): Node((2, 3), (3, 4), 3.82842712474619, 0), (8, 7): Node((8, 7), (7, 6), 3.82842712474619, 0), (7, 2): Node((7, 2), (6, 3), 3.82842712474619, 0), (3, 2): Node((3, 2), (4, 3), 3.82842712474619, 0), (3, 8): Node((3, 8), (4, 7), 3.82842712474619, 0), (2, 7): Node((2, 7), (3, 6), 3.82842712474619, 0), (8, 3): Node((8, 3), (7, 4), 3.82842712474619, 0), (5, 1): Node((5, 1), (5, 2), 4.0, 0), (5, 9): Node((5, 9), (5, 8), 4.0, 0), (9, 5): Node((9, 5), (8, 5), 4.0, 0), (1, 5): Node((1, 5), (2, 5), 4.0, 0), (8, 8): Node((8, 8), (7, 7), 4.242640687119286, 0), (8, 2): Node((8, 2), (7, 3), 4.242640687119286, 0), (2, 2): Node((2, 2), (3, 3), 4.242640687119286, 0), (2, 8): Node((2, 8), (3, 7), 4.242640687119286, 0), (9, 4): Node((9, 4), (8, 4), 4.414213562373095, 0), (6, 1): Node((6, 1), (6, 2), 4.414213562373095, 0), (6, 9): Node((6, 9), (5, 8), 4.414213562373095, 0), (4, 9): Node((4, 9), (4, 8), 4.414213562373095, 0), (9, 6): Node((9, 6), (8, 5), 4.414213562373095, 0), (1, 4): Node((1, 4), (2, 4), 4.414213562373095, 0), (4, 1): Node((4, 1), (5, 2), 4.414213562373095, 0), (1, 6): Node((1, 6), (2, 5), 4.414213562373095, 0), (7, 1): Node((7, 1), (6, 2), 4.82842712474619, 0), (3, 9): Node((3, 9), (3, 8), 4.82842712474619, 0), (9, 3): Node((9, 3), (8, 3), 4.82842712474619, 0), (9, 7): Node((9, 7), (8, 6), 4.82842712474619, 0), (1, 3): Node((1, 3), (2, 3), 4.82842712474619, 0), (7, 9): Node((7, 9), (7, 8), 4.82842712474619, 0), (1, 7): Node((1, 7), (2, 6), 4.82842712474619, 0), (3, 1): Node((3, 1), (3, 2), 4.82842712474619, 0), (5, 10): Node((5, 10), (5, 9), 5.0, 0), (5, 0): Node((5, 0), (5, 1), 5.0, 0), (0, 5): Node((0, 5), (1, 5), 5.0, 0), (10, 5): Node((10, 5), (9, 5), 5.0, 0), (9, 2): Node((9, 2), (8, 3), 5.242640687119285, 0), (9, 8): Node((9, 8), (8, 7), 5.242640687119285, 0), (8, 9): Node((8, 9), (7, 8), 5.242640687119285, 0), (1, 2): Node((1, 2), (2, 3), 5.242640687119285, 0), (2, 9): Node((2, 9), (3, 8), 5.242640687119285, 0), (8, 1): Node((8, 1), (7, 2), 5.242640687119285, 0), (2, 1): Node((2, 1), (3, 2), 5.242640687119285, 0), (1, 8): Node((1, 8), (2, 7), 5.242640687119285, 0), (0, 6): Node((0, 6), (1, 5), 5.414213562373095, 0), (4, 0): Node((4, 0), (4, 1), 5.414213562373095, 0), (6, 10): Node((6, 10), (6, 9), 5.414213562373095, 0), (6, 0): Node((6, 0), (6, 1), 5.414213562373095, 0), (10, 4): Node((10, 4), (9, 4), 5.414213562373095, 0), (4, 10): Node((4, 10), (5, 9), 5.414213562373095, 0), (0, 4): Node((0, 4), (1, 5), 5.414213562373095, 0), (10, 6): Node((10, 6), (9, 6), 5.414213562373095, 0), (1, 9): Node((1, 9), (2, 8), 5.656854249492381, 0), (1, 1): Node((1, 1), (2, 2), 5.656854249492381, 0), (9, 1): Node((9, 1), (8, 2), 5.656854249492381, 0), (9, 9): Node((9, 9), (8, 8), 5.656854249492381, 0), (7, 10): Node((7, 10), (6, 9), 5.82842712474619, 0), (7, 0): Node((7, 0), (6, 1), 5.82842712474619, 0), (10, 3): Node((10, 3), (9, 4), 5.82842712474619, 0), (3, 0): Node((3, 0), (4, 1), 5.82842712474619, 0), (3, 10): Node((3, 10), (3, 9), 5.82842712474619, 0), (10, 7): Node((10, 7), (9, 7), 5.82842712474619, 0), (0, 3): Node((0, 3), (1, 4), 5.82842712474619, 0), (0, 7): Node((0, 7), (1, 7), 5.82842712474619, 0), (11, 5): Node((11, 5), (10, 5), 6.0, 0), (5, 11): Node((5, 11), (5, 10), 6.0, 0), (0, 8): Node((0, 8), (1, 8), 6.242640687119285, 0), (8, 10): Node((8, 10), (8, 9), 6.242640687119285, 0), (10, 2): Node((10, 2), (9, 3), 6.242640687119285, 0), (8, 0): Node((8, 0), (8, 1), 6.242640687119285, 0), (2, 10): Node((2, 10), (3, 9), 6.242640687119285, 0), (10, 8): Node((10, 8), (9, 7), 6.242640687119285, 0), (2, 0): Node((2, 0), (3, 1), 6.242640687119285, 0), (0, 2): Node((0, 2), (1, 2), 6.242640687119285, 0), (11, 4): Node((11, 4), (10, 5), 6.414213562373095, 0), (4, 11): Node((4, 11), (5, 10), 6.414213562373095, 0), (11, 6): Node((11, 6), (10, 5), 6.414213562373095, 0), (6, 11): Node((6, 11), (6, 10), 6.414213562373095, 0), (0, 1): Node((0, 1), (1, 2), 6.65685424949238, 0), (9, 0): Node((9, 0), (8, 1), 6.65685424949238, 0), (0, 9): Node((0, 9), (1, 8), 6.65685424949238, 0), (1, 0): Node((1, 0), (2, 1), 6.65685424949238, 0), (9, 10): Node((9, 10), (8, 9), 6.65685424949238, 0), (10, 9): Node((10, 9), (9, 8), 6.65685424949238, 0), (10, 1): Node((10, 1), (9, 2), 6.65685424949238, 0), (1, 10): Node((1, 10), (2, 9), 6.65685424949238, 0), (7, 11): Node((7, 11), (6, 10), 6.82842712474619, 0), (11, 3): Node((11, 3), (10, 3), 6.82842712474619, 0), (3, 11): Node((3, 11), (3, 10), 6.82842712474619, 0), (11, 7): Node((11, 7), (10, 7), 6.82842712474619, 0), (5, 12): Node((5, 12), (5, 11), 7.0, 0), (12, 5): Node((12, 5), (11, 5), 7.0, 0), (0, 10): Node((0, 10), (1, 9), 7.0710678118654755, 0), (10, 10): Node((10, 10), (9, 9), 7.0710678118654755, 0)}})\n    \"\"\"\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n\n    def __str__(self) -&gt; str:\n        return \"Dijkstra\"\n\n    def plan(self) -&gt; Union[list, dict]:\n        \"\"\"\n        Interface for planning.\n\n        Returns:\n            path: A list containing the path waypoints\n            path_info: A dictionary containing the path information (success, length, cost, expand)\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        # For Dijkstra, we only use g-value (no heuristic h-value)\n        start_node = Node(self.start, None, 0, 0)\n        heapq.heappush(OPEN, start_node)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # obstacle found\n            if not self.map_.is_expandable(node.current, node.parent):\n                continue\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node.current == self.goal:\n                CLOSED[node.current] = node\n                path, length, cost = self.extract_path(CLOSED)\n                return path, {\n                    \"success\": True, \n                    \"start\": self.start, \n                    \"goal\": self.goal, \n                    \"length\": length, \n                    \"cost\": cost, \n                    \"expand\": CLOSED\n                }\n\n            for node_n in self.map_.get_neighbors(node): \n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                # For Dijkstra, we only update g-value (no heuristic)\n                node_n.g = node.g + self.get_cost(node.current, node_n.current)\n\n                # goal found\n                if node_n.current == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list with node sorted by g-value\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n\n        self.failed_info[1][\"expand\"] = CLOSED\n        return self.failed_info\n</code></pre>"},{"location":"api/path_planner/graph_search/dijkstra/Dijkstra.html#src.python_motion_planning.path_planner.graph_search.dijkstra.Dijkstra.plan","title":"<code>plan()</code>","text":"<p>Interface for planning.</p> <p>Returns:</p> Name Type Description <code>path</code> <code>Union[list, dict]</code> <p>A list containing the path waypoints</p> <code>path_info</code> <code>Union[list, dict]</code> <p>A dictionary containing the path information (success, length, cost, expand)</p> Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\dijkstra.py</code> Python<pre><code>def plan(self) -&gt; Union[list, dict]:\n    \"\"\"\n    Interface for planning.\n\n    Returns:\n        path: A list containing the path waypoints\n        path_info: A dictionary containing the path information (success, length, cost, expand)\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    # For Dijkstra, we only use g-value (no heuristic h-value)\n    start_node = Node(self.start, None, 0, 0)\n    heapq.heappush(OPEN, start_node)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # obstacle found\n        if not self.map_.is_expandable(node.current, node.parent):\n            continue\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node.current == self.goal:\n            CLOSED[node.current] = node\n            path, length, cost = self.extract_path(CLOSED)\n            return path, {\n                \"success\": True, \n                \"start\": self.start, \n                \"goal\": self.goal, \n                \"length\": length, \n                \"cost\": cost, \n                \"expand\": CLOSED\n            }\n\n        for node_n in self.map_.get_neighbors(node): \n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            # For Dijkstra, we only update g-value (no heuristic)\n            node_n.g = node.g + self.get_cost(node.current, node_n.current)\n\n            # goal found\n            if node_n.current == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list with node sorted by g-value\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n\n    self.failed_info[1][\"expand\"] = CLOSED\n    return self.failed_info\n</code></pre>"},{"location":"api/path_planner/graph_search/theta_star/ThetaStar.html","title":"ThetaStar","text":""},{"location":"api/path_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.path_planner.graph_search.theta_star.ThetaStar","title":"<code>src.python_motion_planning.path_planner.graph_search.theta_star.ThetaStar</code>","text":"<p>               Bases: <code>AStar</code></p> <p>Class for Theta* path planner.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>**kwargs</code> <p>see the parent class.</p> <code>{}</code> References <p>[1] Theta*: Any-Angle Path Planning on Grids [2] Any-angle path planning on non-uniform costmaps</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n&gt;&gt;&gt; planner = ThetaStar(map_=map_, start=(5, 5), goal=(10, 10))\n&gt;&gt;&gt; planner.plan()\n([(5, 5), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (5, 5), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (5, 5), 4.242640687119285, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.65685424949238, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.071067811865475, 0.0)}})\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n&gt;&gt;&gt; planner.plan()\n([(5, 5), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (5, 5), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (5, 5), 4.242640687119285, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.65685424949238, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.071067811865475, 0.0)}})\n</code></pre> Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\theta_star.py</code> Python<pre><code>class ThetaStar(AStar):\n    \"\"\"\n    Class for Theta* path planner.\n\n    Args:\n        *args: see the parent class.\n        **kwargs: see the parent class.\n\n    References:\n        [1] Theta*: Any-Angle Path Planning on Grids\n        [2] Any-angle path planning on non-uniform costmaps\n\n    Examples:\n        &gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n        &gt;&gt;&gt; planner = ThetaStar(map_=map_, start=(5, 5), goal=(10, 10))\n        &gt;&gt;&gt; planner.plan()\n        ([(5, 5), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (5, 5), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (5, 5), 4.242640687119285, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.65685424949238, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.071067811865475, 0.0)}})\n\n        &gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n        &gt;&gt;&gt; planner.plan()\n        ([(5, 5), (8, 8), (9, 9), (10, 10)], {'success': True, 'start': (5, 5), 'goal': (10, 10), 'length': 7.0710678118654755, 'cost': 7.0710678118654755, 'expand': {(5, 5): Node((5, 5), None, 0, 7.0710678118654755), (6, 6): Node((6, 6), (5, 5), 1.4142135623730951, 5.656854249492381), (7, 7): Node((7, 7), (5, 5), 2.8284271247461903, 4.242640687119285), (8, 8): Node((8, 8), (5, 5), 4.242640687119285, 2.8284271247461903), (9, 9): Node((9, 9), (8, 8), 5.65685424949238, 1.4142135623730951), (10, 10): Node((10, 10), (9, 9), 7.071067811865475, 0.0)}})\n    \"\"\"\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n\n    def __str__(self) -&gt; str:\n        return \"Theta*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Interface for planning.\n\n        Returns:\n            path: A list containing the path waypoints\n            path_info: A dictionary containing the path information (success, length, cost, expand)\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        start_node = Node(self.start, None, 0, self.get_heuristic(self.start))\n        heapq.heappush(OPEN, start_node)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # obstacle found\n            if not self.map_.is_expandable(node.current, node.parent):\n                continue\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node.current == self.goal:\n                CLOSED[node.current] = node\n                path, length, cost = self.extract_path(CLOSED)\n                return path, {\n                    \"success\": True, \n                    \"start\": self.start, \n                    \"goal\": self.goal, \n                    \"length\": length, \n                    \"cost\": cost, \n                    \"expand\": CLOSED\n                }\n\n            for node_n in self.map_.get_neighbors(node): \n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                # path1: normal A*\n                node_n.g = node.g + self.get_cost(node.current, node_n.current)\n                node_n.h = self.get_heuristic(node_n.current)\n\n\n                # path 2: Theta* line of sight update\n                node_p = CLOSED.get(node.parent)\n                if node_p:\n                    self.updateVertex(node_p, node_n)\n\n                # goal found\n                if node_n.current == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n\n        self.failed_info[1][\"expand\"] = CLOSED\n        return self.failed_info\n\n    def updateVertex(self, node_p: Node, node_n: Node) -&gt; None:\n        \"\"\"\n        Update extend node information with current node's parent node.\n\n        Args:\n            node_p (Node): parent node\n            node_n (Node): next node\n        \"\"\"\n        if not self.map_.in_collision(node_p.current, node_n.current):\n            if node_p.g + self.get_cost(node_p.current, node_n.current) &lt;= node_n.g:\n                node_n.g = node_p.g + self.get_cost(node_p.current, node_n.current)\n                node_n.parent = node_p.current\n</code></pre>"},{"location":"api/path_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.path_planner.graph_search.theta_star.ThetaStar.plan","title":"<code>plan()</code>","text":"<p>Interface for planning.</p> <p>Returns:</p> Name Type Description <code>path</code> <code>tuple</code> <p>A list containing the path waypoints</p> <code>path_info</code> <code>tuple</code> <p>A dictionary containing the path information (success, length, cost, expand)</p> Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\theta_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Interface for planning.\n\n    Returns:\n        path: A list containing the path waypoints\n        path_info: A dictionary containing the path information (success, length, cost, expand)\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    start_node = Node(self.start, None, 0, self.get_heuristic(self.start))\n    heapq.heappush(OPEN, start_node)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # obstacle found\n        if not self.map_.is_expandable(node.current, node.parent):\n            continue\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node.current == self.goal:\n            CLOSED[node.current] = node\n            path, length, cost = self.extract_path(CLOSED)\n            return path, {\n                \"success\": True, \n                \"start\": self.start, \n                \"goal\": self.goal, \n                \"length\": length, \n                \"cost\": cost, \n                \"expand\": CLOSED\n            }\n\n        for node_n in self.map_.get_neighbors(node): \n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            # path1: normal A*\n            node_n.g = node.g + self.get_cost(node.current, node_n.current)\n            node_n.h = self.get_heuristic(node_n.current)\n\n\n            # path 2: Theta* line of sight update\n            node_p = CLOSED.get(node.parent)\n            if node_p:\n                self.updateVertex(node_p, node_n)\n\n            # goal found\n            if node_n.current == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n\n    self.failed_info[1][\"expand\"] = CLOSED\n    return self.failed_info\n</code></pre>"},{"location":"api/path_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.path_planner.graph_search.theta_star.ThetaStar.updateVertex","title":"<code>updateVertex(node_p, node_n)</code>","text":"<p>Update extend node information with current node's parent node.</p> <p>Parameters:</p> Name Type Description Default <code>node_p</code> <code>Node</code> <p>parent node</p> required <code>node_n</code> <code>Node</code> <p>next node</p> required Source code in <code>src\\python_motion_planning\\path_planner\\graph_search\\theta_star.py</code> Python<pre><code>def updateVertex(self, node_p: Node, node_n: Node) -&gt; None:\n    \"\"\"\n    Update extend node information with current node's parent node.\n\n    Args:\n        node_p (Node): parent node\n        node_n (Node): next node\n    \"\"\"\n    if not self.map_.in_collision(node_p.current, node_n.current):\n        if node_p.g + self.get_cost(node_p.current, node_n.current) &lt;= node_n.g:\n            node_n.g = node_p.g + self.get_cost(node_p.current, node_n.current)\n            node_n.parent = node_p.current\n</code></pre>"},{"location":"api/path_planner/sample_search/rrt/RRT.html","title":"RRT","text":""},{"location":"api/path_planner/sample_search/rrt/RRT.html#src.python_motion_planning.path_planner.sample_search.rrt.RRT","title":"<code>src.python_motion_planning.path_planner.sample_search.rrt.RRT</code>","text":"<p>               Bases: <code>BasePathPlanner</code></p> <p>Class for RRT (Rapidly-exploring Random Tree) path planner.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>max_dist</code> <code>float</code> <p>Maximum expansion distance for each step (default: 1.0).</p> <code>5.0</code> <code>sample_num</code> <code>int</code> <p>Maximum number of samples to generate (default: 10000).</p> <code>100000</code> <code>goal_sample_rate</code> <code>float</code> <p>Probability of sampling the goal directly (default: 0.05).</p> <code>0.05</code> <code>*kwargs</code> <p>see the parent class.</p> <code>{}</code> References <p>[1] Rapidly-Exploring Random Trees: A New Tool for Path Planning</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n&gt;&gt;&gt; planner = RRT(map_=map_, start=(5, 5), goal=(10, 10))\n&gt;&gt;&gt; path, path_info = planner.plan()\n&gt;&gt;&gt; print(path_info['success'])\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n&gt;&gt;&gt; path, path_info = planner.plan()\n&gt;&gt;&gt; print(path_info['success'])\nTrue\n</code></pre> Source code in <code>src\\python_motion_planning\\path_planner\\sample_search\\rrt.py</code> Python<pre><code>class RRT(BasePathPlanner):\n    \"\"\"\n    Class for RRT (Rapidly-exploring Random Tree) path planner.\n\n    Args:\n        *args: see the parent class.\n        max_dist: Maximum expansion distance for each step (default: 1.0).\n        sample_num: Maximum number of samples to generate (default: 10000).\n        goal_sample_rate: Probability of sampling the goal directly (default: 0.05).\n        *kwargs: see the parent class.\n\n    References:\n        [1] Rapidly-Exploring Random Trees: A New Tool for Path Planning\n\n    Examples:\n        &gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n        &gt;&gt;&gt; planner = RRT(map_=map_, start=(5, 5), goal=(10, 10))\n        &gt;&gt;&gt; path, path_info = planner.plan()\n        &gt;&gt;&gt; print(path_info['success'])\n        True\n\n        &gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n        &gt;&gt;&gt; path, path_info = planner.plan()\n        &gt;&gt;&gt; print(path_info['success'])\n        True\n    \"\"\"\n    def __init__(self, *args, \n                 max_dist: float = 5.0, sample_num: int = 100000, \n                 goal_sample_rate: float = 0.05,\n                 **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        # Maximum expansion distance per step\n        self.max_dist = max_dist\n        # Maximum number of samples\n        self.sample_num = sample_num\n        # Goal sampling probability\n        self.goal_sample_rate = goal_sample_rate\n        # Environment bounds from the map\n        self.bounds = self.map_.bounds\n\n    def __str__(self) -&gt; str:\n        return \"Rapidly-exploring Random Tree (RRT)\"\n\n    def plan(self) -&gt; Union[list, dict]:\n        \"\"\"\n        RRT path planning algorithm implementation.\n\n        Returns:\n            path: A list containing the path waypoints\n            path_info: A dictionary containing path information\n        \"\"\"\n        # Initialize tree with start node\n        tree = {}\n        start_node = Node(self.start, None, 0, 0)\n        tree[self.start] = start_node\n\n        # Main sampling loop\n        for _ in range(self.sample_num):\n            # Generate random sample node\n            node_rand = self._generate_random_node()\n\n            # Skip if node already exists\n            if node_rand.current in tree:\n                continue\n\n            # Find nearest node in tree\n            node_near = self._get_nearest_node(tree, node_rand)\n\n            # Create new node towards random sample\n            node_new = self._steer(node_near, node_rand)\n            if node_new is None:\n                continue\n\n            # Check if edge is collision-free\n            if self.map_.in_collision(node_new.current, node_near.current):\n                continue\n\n            # Add new node to tree\n            node_new.parent = node_near.current\n            node_new.g = node_near.g + self.get_cost(node_near.current, node_new.current)\n            tree[node_new.current] = node_new\n\n            # Check if goal is reachable\n            dist_to_goal = self.get_cost(node_new.current, self.goal)\n            if dist_to_goal &lt;= self.max_dist:\n                # Check final edge to goal\n                if not self.map_.in_collision(node_new.current, self.goal):\n                    if node_new.current == self.goal:\n                        goal_node = node_new\n                    else:\n                        goal_node = Node(self.goal, node_new.current, \n                                        node_new.g + dist_to_goal, 0)\n                    tree[self.goal] = goal_node\n                    path, length, cost = self.extract_path(tree)\n                    return path, {\n                        \"success\": True,\n                        \"start\": self.start,\n                        \"goal\": self.goal,\n                        \"length\": length,\n                        \"cost\": cost,\n                        \"expand\": tree,\n                    }\n\n        # Planning failed\n        self.failed_info[1][\"expand\"] = tree\n        return self.failed_info\n\n    def _generate_random_node(self) -&gt; Node:\n        \"\"\"\n        Generate a random node within map bounds as integer grid point.\n\n        Returns:\n            node: Generated random node on grid\n        \"\"\"\n        # Sample goal directly with specified probability\n        if random.random() &lt; self.goal_sample_rate:\n            return Node(self.goal, None, 0, 0)\n\n        point = []\n        # Generate random integer point within grid bounds\n        for d in range(self.map_.dim):\n            d_min, d_max = self.bounds[d]\n            point.append(random.randint(int(d_min), int(d_max)))\n        point = tuple(point)\n\n        return Node(point, None, 0, 0)\n\n    def _get_nearest_node(self, tree: Dict[Tuple[int, ...], Node], \n                         node_rand: Node) -&gt; Node:\n        \"\"\"\n        Find the nearest node in the tree to a random sample.\n\n        Args:\n            tree: Current tree of nodes\n            node_rand: Random sample node\n\n        Returns:\n            node: Nearest node in the tree\n        \"\"\"\n        min_dist = float('inf')\n        nearest_node = None\n\n        for node in tree.values():\n            dist = self.get_cost(node.current, node_rand.current)\n            if dist &lt; min_dist:\n                min_dist = dist\n                nearest_node = node\n\n        return nearest_node\n\n    def _steer(self, node_near: Node, \n              node_rand: Node) -&gt; Union[Node, None]:\n        \"\"\"\n        Steer from nearest node towards random sample.\n\n        Args:\n            node_near: Nearest node in tree\n            node_rand: Random sample node\n\n        Returns:\n            node: New node in direction of random sample\n        \"\"\"\n        # Calculate differences for each dimension\n        diffs = [node_rand.current[i] - node_near.current[i] for i in range(self.map_.dim)]\n\n        # Calculate Euclidean distance in n-dimensional space\n        dist = math.sqrt(sum(diff**2 for diff in diffs))\n\n        # Handle case where nodes are coincident\n        if math.isclose(dist, 0):\n            return None\n\n        # If within max distance, use the random node directly\n        if dist &lt;= self.max_dist:\n            return node_rand\n\n        # Otherwise scale to maximum distance\n        scale = self.max_dist / dist\n        new_coords = [\n            node_near.current[i] + scale * diffs[i] \n            for i in range(self.map_.dim)\n        ]\n\n        # Round coordinates if original points were integers\n        if all(isinstance(coord, int) for coord in node_near.current):\n            new_coords = [round(coord) for coord in new_coords]\n\n        return Node(tuple(new_coords), None, 0, 0)\n</code></pre>"},{"location":"api/path_planner/sample_search/rrt/RRT.html#src.python_motion_planning.path_planner.sample_search.rrt.RRT.plan","title":"<code>plan()</code>","text":"<p>RRT path planning algorithm implementation.</p> <p>Returns:</p> Name Type Description <code>path</code> <code>Union[list, dict]</code> <p>A list containing the path waypoints</p> <code>path_info</code> <code>Union[list, dict]</code> <p>A dictionary containing path information</p> Source code in <code>src\\python_motion_planning\\path_planner\\sample_search\\rrt.py</code> Python<pre><code>def plan(self) -&gt; Union[list, dict]:\n    \"\"\"\n    RRT path planning algorithm implementation.\n\n    Returns:\n        path: A list containing the path waypoints\n        path_info: A dictionary containing path information\n    \"\"\"\n    # Initialize tree with start node\n    tree = {}\n    start_node = Node(self.start, None, 0, 0)\n    tree[self.start] = start_node\n\n    # Main sampling loop\n    for _ in range(self.sample_num):\n        # Generate random sample node\n        node_rand = self._generate_random_node()\n\n        # Skip if node already exists\n        if node_rand.current in tree:\n            continue\n\n        # Find nearest node in tree\n        node_near = self._get_nearest_node(tree, node_rand)\n\n        # Create new node towards random sample\n        node_new = self._steer(node_near, node_rand)\n        if node_new is None:\n            continue\n\n        # Check if edge is collision-free\n        if self.map_.in_collision(node_new.current, node_near.current):\n            continue\n\n        # Add new node to tree\n        node_new.parent = node_near.current\n        node_new.g = node_near.g + self.get_cost(node_near.current, node_new.current)\n        tree[node_new.current] = node_new\n\n        # Check if goal is reachable\n        dist_to_goal = self.get_cost(node_new.current, self.goal)\n        if dist_to_goal &lt;= self.max_dist:\n            # Check final edge to goal\n            if not self.map_.in_collision(node_new.current, self.goal):\n                if node_new.current == self.goal:\n                    goal_node = node_new\n                else:\n                    goal_node = Node(self.goal, node_new.current, \n                                    node_new.g + dist_to_goal, 0)\n                tree[self.goal] = goal_node\n                path, length, cost = self.extract_path(tree)\n                return path, {\n                    \"success\": True,\n                    \"start\": self.start,\n                    \"goal\": self.goal,\n                    \"length\": length,\n                    \"cost\": cost,\n                    \"expand\": tree,\n                }\n\n    # Planning failed\n    self.failed_info[1][\"expand\"] = tree\n    return self.failed_info\n</code></pre>"},{"location":"api/path_planner/sample_search/rrt_star/RRTStar.html","title":"RRTStar","text":""},{"location":"api/path_planner/sample_search/rrt_star/RRTStar.html#src.python_motion_planning.path_planner.sample_search.rrt_star.RRTStar","title":"<code>src.python_motion_planning.path_planner.sample_search.rrt_star.RRTStar</code>","text":"<p>               Bases: <code>RRT</code></p> <p>Class for RRT* (Rapidly-exploring Random Tree Star) path planner.</p> <p>RRT* is an optimized version of RRT that provides asymptotically optimal paths by rewiring the tree to maintain lower-cost connections.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>see the parent class.</p> <code>()</code> <code>radius</code> <code>float</code> <p>Radius for finding nearby nodes during rewiring.</p> <code>10.0</code> <code>*kwargs</code> <p>see the parent class.</p> <code>{}</code> References <p>[1] Sampling-based algorithms for optimal motion planning</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n&gt;&gt;&gt; planner = RRTStar(map_=map_, start=(5, 5), goal=(10, 10))\n&gt;&gt;&gt; path, path_info = planner.plan()\n&gt;&gt;&gt; print(path_info['success'])\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n&gt;&gt;&gt; path, path_info = planner.plan()\n&gt;&gt;&gt; print(path_info['success'])\nTrue\n</code></pre> Source code in <code>src\\python_motion_planning\\path_planner\\sample_search\\rrt_star.py</code> Python<pre><code>class RRTStar(RRT):\n    \"\"\"\n    Class for RRT* (Rapidly-exploring Random Tree Star) path planner.\n\n    RRT* is an optimized version of RRT that provides asymptotically optimal paths\n    by rewiring the tree to maintain lower-cost connections.\n\n    Args:\n        *args: see the parent class.\n        radius: Radius for finding nearby nodes during rewiring.\n        *kwargs: see the parent class.\n\n    References:\n        [1] Sampling-based algorithms for optimal motion planning\n\n    Examples:\n        &gt;&gt;&gt; map_ = Grid(bounds=[[0, 15], [0, 15]])\n        &gt;&gt;&gt; planner = RRTStar(map_=map_, start=(5, 5), goal=(10, 10))\n        &gt;&gt;&gt; path, path_info = planner.plan()\n        &gt;&gt;&gt; print(path_info['success'])\n        True\n\n        &gt;&gt;&gt; planner.map_.type_map[3:10, 6] = TYPES.OBSTACLE\n        &gt;&gt;&gt; path, path_info = planner.plan()\n        &gt;&gt;&gt; print(path_info['success'])\n        True\n    \"\"\"\n    def __init__(self, *args, \n                 radius: float = 10.0,** kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        # Radius for finding nearby nodes during rewiring phase\n        self.radius = radius\n\n    def __str__(self) -&gt; str:\n        return \"Rapidly-exploring Random Tree Star (RRT*)\"\n\n    def plan(self) -&gt; Union[list, dict]:\n        \"\"\"\n        RRT* path planning algorithm implementation with optimality properties.\n\n        Returns:\n            path: A list containing the path waypoints\n            path_info: A dictionary containing path information\n        \"\"\"\n        # Initialize tree with start node\n        tree = {}\n        start_node = Node(self.start, None, 0, 0)\n        tree[self.start] = start_node\n\n        # Main sampling loop\n        for _ in range(self.sample_num):\n            # Generate random sample node\n            node_rand = self._generate_random_node()\n\n            # Skip if node already exists\n            if node_rand.current in tree:\n                continue\n\n            # Find nearest node in tree\n            node_near = self._get_nearest_node(tree, node_rand)\n\n            # Create new node towards random sample\n            node_new = self._steer(node_near, node_rand)\n            if node_new is None:\n                continue\n\n            # Check if edge is collision-free\n            if self.map_.in_collision(node_new.current, node_near.current):\n                continue\n\n            # Find all nearby nodes within radius\n            near_nodes = self._find_near_nodes(tree, node_new)\n\n            # Select optimal parent from nearby nodes\n            node_new, node_near = self._choose_parent(node_new, node_near, near_nodes)\n            if node_new is None:\n                continue\n\n            # Add new node to tree\n            tree[node_new.current] = node_new\n\n            # Rewire tree to potentially improve existing paths\n            self._rewire(tree, node_new, near_nodes)\n\n            # Check if goal is reachable\n            dist_to_goal = self.get_cost(node_new.current, self.goal)\n            if dist_to_goal &lt;= self.max_dist:\n                # Check final edge to goal\n                if not self.map_.in_collision(node_new.current, self.goal):\n                    goal_cost = node_new.g + dist_to_goal\n                    # Update goal node if it already exists with a lower cost path\n                    if self.goal in tree:\n                        if goal_cost &lt; tree[self.goal].g:\n                            tree[self.goal].parent = node_new.current\n                            tree[self.goal].g = goal_cost\n                    else:\n                        goal_node = Node(self.goal, node_new.current, goal_cost, 0)\n                        tree[self.goal] = goal_node\n\n                    # Extract and return the path\n                    path, length, cost = self.extract_path(tree)\n                    return path, {\n                        \"success\": True,\n                        \"start\": self.start,\n                        \"goal\": self.goal,\n                        \"length\": length,\n                        \"cost\": cost,\n                        \"expand\": tree,\n                    }\n\n        # Planning failed\n        self.failed_info[1][\"expand\"] = tree\n        return self.failed_info\n\n    def _find_near_nodes(self, tree: Dict[tuple, Node], node_new: Node) -&gt; List[Node]:\n        \"\"\"\n        Find all nodes in the tree within a specified radius of the new node.\n\n        Args:\n            tree: Current tree of nodes\n            node_new: Newly created node\n\n        Returns:\n            near_nodes: List of nodes within the specified radius\n        \"\"\"\n        near_nodes = []\n        for node in tree.values():\n            if self.get_cost(node.current, node_new.current) &lt;= self.radius:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _choose_parent(self, node_new: Node, node_near: Node, near_nodes: List[Node]) -&gt; Tuple[Union[Node, None], Node]:\n        \"\"\"\n        Select the optimal parent for the new node from nearby nodes to minimize cost.\n\n        Args:\n            node_new: Newly created node\n            node_near: Nearest node in the tree\n            near_nodes: List of nearby nodes\n\n        Returns:\n            node_new: Updated new node with optimal parent\n            node_near: The chosen parent node\n        \"\"\"\n        # Initialize with nearest node as potential parent\n        node_new.g = node_near.g + self.get_cost(node_near.current, node_new.current)\n        best_parent = node_near\n\n        # Check all nearby nodes for potentially lower-cost paths\n        for node_near_candidate in near_nodes:\n            # Skip if candidate is the same as initial nearest node\n            if node_near_candidate.current == best_parent.current:\n                continue\n\n            # Check if path from candidate to new node is collision-free\n            if self.map_.in_collision(node_near_candidate.current, node_new.current):\n                continue\n\n            # Calculate cost through this candidate parent\n            new_cost = node_near_candidate.g + self.get_cost(node_near_candidate.current, node_new.current)\n\n            # Update parent if this path is cheaper\n            if new_cost &lt; node_new.g:\n                node_new.g = new_cost\n                best_parent = node_near_candidate\n\n        # Set the best parent for the new node\n        node_new.parent = best_parent.current\n        return node_new, best_parent\n\n    def _rewire(self, tree: Dict[tuple, Node], node_new: Node, near_nodes: List[Node]) -&gt; None:\n        \"\"\"\n        Rewire the tree to potentially improve paths for existing nodes using the new node.\n\n        Args:\n            tree: Current tree of nodes\n            node_new: Newly added node\n            near_nodes: List of nearby nodes\n        \"\"\"\n        for node_near in near_nodes:\n            # Skip if node is the parent of the new node\n            if node_near.current == node_new.parent:\n                continue\n\n            # Check if path from new node to existing node is collision-free\n            if self.map_.in_collision(node_new.current, node_near.current):\n                continue\n\n            # Calculate potential new cost for existing node through new node\n            new_cost = node_new.g + self.get_cost(node_new.current, node_near.current)\n\n            # Update parent if new path is cheaper\n            if new_cost &lt; node_near.g:\n                node_near.parent = node_new.current\n                node_near.g = new_cost\n                # Update the node in the tree\n                tree[node_near.current] = node_near\n</code></pre>"},{"location":"api/path_planner/sample_search/rrt_star/RRTStar.html#src.python_motion_planning.path_planner.sample_search.rrt_star.RRTStar.plan","title":"<code>plan()</code>","text":"<p>RRT* path planning algorithm implementation with optimality properties.</p> <p>Returns:</p> Name Type Description <code>path</code> <code>Union[list, dict]</code> <p>A list containing the path waypoints</p> <code>path_info</code> <code>Union[list, dict]</code> <p>A dictionary containing path information</p> Source code in <code>src\\python_motion_planning\\path_planner\\sample_search\\rrt_star.py</code> Python<pre><code>def plan(self) -&gt; Union[list, dict]:\n    \"\"\"\n    RRT* path planning algorithm implementation with optimality properties.\n\n    Returns:\n        path: A list containing the path waypoints\n        path_info: A dictionary containing path information\n    \"\"\"\n    # Initialize tree with start node\n    tree = {}\n    start_node = Node(self.start, None, 0, 0)\n    tree[self.start] = start_node\n\n    # Main sampling loop\n    for _ in range(self.sample_num):\n        # Generate random sample node\n        node_rand = self._generate_random_node()\n\n        # Skip if node already exists\n        if node_rand.current in tree:\n            continue\n\n        # Find nearest node in tree\n        node_near = self._get_nearest_node(tree, node_rand)\n\n        # Create new node towards random sample\n        node_new = self._steer(node_near, node_rand)\n        if node_new is None:\n            continue\n\n        # Check if edge is collision-free\n        if self.map_.in_collision(node_new.current, node_near.current):\n            continue\n\n        # Find all nearby nodes within radius\n        near_nodes = self._find_near_nodes(tree, node_new)\n\n        # Select optimal parent from nearby nodes\n        node_new, node_near = self._choose_parent(node_new, node_near, near_nodes)\n        if node_new is None:\n            continue\n\n        # Add new node to tree\n        tree[node_new.current] = node_new\n\n        # Rewire tree to potentially improve existing paths\n        self._rewire(tree, node_new, near_nodes)\n\n        # Check if goal is reachable\n        dist_to_goal = self.get_cost(node_new.current, self.goal)\n        if dist_to_goal &lt;= self.max_dist:\n            # Check final edge to goal\n            if not self.map_.in_collision(node_new.current, self.goal):\n                goal_cost = node_new.g + dist_to_goal\n                # Update goal node if it already exists with a lower cost path\n                if self.goal in tree:\n                    if goal_cost &lt; tree[self.goal].g:\n                        tree[self.goal].parent = node_new.current\n                        tree[self.goal].g = goal_cost\n                else:\n                    goal_node = Node(self.goal, node_new.current, goal_cost, 0)\n                    tree[self.goal] = goal_node\n\n                # Extract and return the path\n                path, length, cost = self.extract_path(tree)\n                return path, {\n                    \"success\": True,\n                    \"start\": self.start,\n                    \"goal\": self.goal,\n                    \"length\": length,\n                    \"cost\": cost,\n                    \"expand\": tree,\n                }\n\n    # Planning failed\n    self.failed_info[1][\"expand\"] = tree\n    return self.failed_info\n</code></pre>"},{"location":"tutorials/2d/controller/path_tracker.html","title":"1.3.1 - Path Tracker","text":"<p>Transform the planned path from map frame to world frame.</p> Python<pre><code>path_world = map_.path_map_to_world(path)\nprint(path_world)\n</code></pre> <p>Print results:</p> Text Only<pre><code>[(5.5, 5.5), (5.5, 6.5), (5.5, 7.5), (5.5, 8.5), (5.5, 9.5), (5.5, 10.5), (5.5, 11.5), (5.5, 12.5), (6.5, 13.5), (6.5, 14.5), (6.5, 15.5), (7.5, 16.5), (7.5, 17.5), (8.5, 18.5), (9.5, 18.5), (10.5, 19.5), (11.5, 19.5), (12.5, 19.5), (13.5, 19.5), (14.5, 19.5), (15.5, 19.5), (16.5, 19.5), (17.5, 19.5), (18.5, 19.5), (19.5, 19.5), (20.5, 19.5), (21.5, 19.5), (22.5, 18.5), (23.5, 17.5), (24.5, 16.5), (25.5, 15.5), (26.5, 14.5), (27.5, 13.5), (28.5, 12.5), (29.5, 11.5), (30.5, 11.5), (31.5, 12.5), (32.5, 12.5), (33.5, 13.5), (34.5, 14.5), (35.5, 15.5), (36.5, 16.5), (37.5, 17.5), (38.5, 18.5), (39.5, 19.5), (40.5, 20.5), (41.5, 21.5), (42.5, 22.5), (43.5, 23.5), (44.5, 24.5), (45.5, 25.5)]\n</code></pre> <p>Create the toy simulator.</p> Python<pre><code>dim = 2\nenv = ToySimulator(dim=dim, obstacle_grid=map_, robot_collisions=False)\n</code></pre> <p>Add robots.</p> Python<pre><code>robots = {\n    \"1\": CircularRobot(dim=dim, radius=1, pose=np.array([5.5, 5.5, 0]), vel=np.zeros(3),\n                action_min=np.array([-2, -2, -3.14]), action_max=np.array([2, 2, 3.14]), color=\"C0\", text=\"1\"),\n    \"2\": DiffDriveRobot(dim=dim, radius=1, pose=np.array([5.5, 5.5, 0]), vel=np.zeros(3),\n                action_min=np.array([-2.82, 0, -6.28]), action_max=np.array([2.82, 0, 6.28]), color=\"C1\", text=\"2\")\n}\n</code></pre> <p>Add controllers.</p> Python<pre><code>controllers = {}\nfor rid, robot in robots.items():\n    obs_space, act_space = env.build_robot_spaces(robot)\n    controllers[rid] = PurePursuit(obs_space, act_space, env.dt, path_world, max_lin_speed=3, max_ang_speed=3.14)\n    env.add_robot(rid, robot)\n</code></pre> <p>Simulate and render.</p> <p>The visualizer has many customizable parameters. You can set them as you want. For example, if you want to show esdf map, set <code>show_esdf</code> to <code>True</code>. Here we set it to <code>False</code>.</p> Python<pre><code>obs, _ = env.reset()\n\nvis = Visualizer(\"Path Visualizer\")\nvis.render_toy_simulator(env, controllers, steps=300, show_traj=True, show_env_info=True, grid_kwargs={\"show_esdf\": False})\nvis.plot_path(path, style=\"--\", color=\"C4\")\nvis.show()\n</code></pre> <p></p> <p>Print trajectory summary information.</p> Python<pre><code>for rid in robots:\n    ctrl = controllers[rid]\n    print(rid, \":\", vis.get_traj_info(rid, ctrl.goal, ctrl.goal_dist_tol, ctrl.goal_orient_tol))\nvis.close()\n</code></pre> <p>Print results:</p> Text Only<pre><code>1 : {'traj_length': 64.05713763788278, 'success': True, 'dist_success': True, 'oracle_success': True, 'oracle_dist_success': True, 'success_time': 23.3, 'dist_success_time': 23.3, 'oracle_success_time': 20.8, 'oracle_dist_success_time': 20.8}\n2 : {'traj_length': 61.7926006243001, 'success': True, 'dist_success': True, 'oracle_success': True, 'oracle_dist_success': True, 'success_time': 22.0, 'dist_success_time': 22.0, 'oracle_success_time': 20.400000000000002, 'oracle_dist_success_time': 20.400000000000002}\n</code></pre> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 51], [0, 31]])\n\nmap_.fill_boundary_with_obstacles()\nmap_.type_map[10:21, 15] = TYPES.OBSTACLE\nmap_.type_map[20, :15] = TYPES.OBSTACLE\nmap_.type_map[30, 15:] = TYPES.OBSTACLE\nmap_.type_map[40, :16] = TYPES.OBSTACLE\n\nmap_.inflate_obstacles(radius=3)\n\nstart = (5, 5)\ngoal = (45, 25)\n\nmap_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n\nplanner = AStar(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\nmap_.fill_expands(path_info[\"expand\"])  # for visualizing the expanded nodes\n\npath_world = map_.path_map_to_world(path)\nprint(path_world)\n\ndim = 2\nenv = ToySimulator(dim=dim, obstacle_grid=map_, robot_collisions=False)\n\nrobots = {\n    \"1\": CircularRobot(dim=dim, radius=1, pose=np.array([5.5, 5.5, 0]), vel=np.zeros(3),\n                action_min=np.array([-2, -2, -3.14]), action_max=np.array([2, 2, 3.14]), color=\"C0\", text=\"1\"),\n    \"2\": DiffDriveRobot(dim=dim, radius=1, pose=np.array([5.5, 5.5, 0]), vel=np.zeros(3),\n                action_min=np.array([-2.82, 0, -6.28]), action_max=np.array([2.82, 0, 6.28]), color=\"C1\", text=\"2\")\n}\n\ncontrollers = {}\nfor rid, robot in robots.items():\n    obs_space, act_space = env.build_robot_spaces(robot)\n    controllers[rid] = PurePursuit(obs_space, act_space, env.dt, path_world, max_lin_speed=3, max_ang_speed=3.14)\n    env.add_robot(rid, robot)\n\nobs, _ = env.reset()\n\nvis = Visualizer(\"Path Visualizer\")\nvis.render_toy_simulator(env, controllers, steps=300, show_traj=True, show_env_info=True, grid_kwargs={\"show_esdf\": False})\nvis.plot_path(path, style=\"--\", color=\"C4\")\nvis.show()\n\nfor rid in robots:\n    ctrl = controllers[rid]\n    print(rid, \":\", vis.get_traj_info(rid, ctrl.goal, ctrl.goal_dist_tol, ctrl.goal_orient_tol))\nvis.close()\n</code></pre>"},{"location":"tutorials/2d/map/grid.html","title":"1.1.1 - Grid","text":"<p>Fix the random seed to ensure reproducible results.</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n</code></pre> <p>Import necessary modules.</p> Python<pre><code>from python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n</code></pre> <p>Define the grid map and add obstacles.</p> Python<pre><code>map_ = Grid(bounds=[[0, 51], [0, 31]])\nmap_.fill_boundary_with_obstacles()\nmap_.type_map[10:21, 15] = TYPES.OBSTACLE\nmap_.type_map[20, :15] = TYPES.OBSTACLE\nmap_.type_map[30, 15:] = TYPES.OBSTACLE\nmap_.type_map[40, :16] = TYPES.OBSTACLE\n</code></pre> <p>Visualize to check the map.</p> Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.show()\n</code></pre> <p></p> <p>Inflate the obstacles to prevent path planners from planning paths too close to the obstacles.</p> Python<pre><code>map_.inflate_obstacles(radius=3)\n</code></pre> <p>Visualize to check the map.</p> Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.show()\nvis.close()\n</code></pre> <p></p> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 51], [0, 31]])\n\nmap_.fill_boundary_with_obstacles()\nmap_.type_map[10:21, 15] = TYPES.OBSTACLE\nmap_.type_map[20, :15] = TYPES.OBSTACLE\nmap_.type_map[30, 15:] = TYPES.OBSTACLE\nmap_.type_map[40, :16] = TYPES.OBSTACLE\n\nmap_.inflate_obstacles(radius=3)\n\nvis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.show()\nvis.close()\n</code></pre>"},{"location":"tutorials/2d/path_planner/graph_search.html","title":"1.2.1 - Graph Search","text":"<p>Define start and goal points.</p> Python<pre><code>start = (5, 5)\ngoal = (45, 25)\n</code></pre> <p>Add the start and goal points to the map. Python<pre><code>map_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n</code></pre></p> <p>Create the path-planner and plan the path. Python<pre><code>planner = AStar(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\nmap_.fill_expands(path_info[\"expand\"])  # for visualizing the expanded nodes\n</code></pre></p> <p>Print results: Text Only<pre><code>[(5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (5, 11), (5, 12), (6, 13), (6, 14), (6, 15), (7, 16), (7, 17), (8, 18), (9, 18), (10, 19), (11, 19), (12, 19), (13, 19), (14, 19), (15, 19), (16, 19), (17, 19), (18, 19), (19, 19), (20, 19), (21, 19), (22, 18), (23, 17), (24, 16), (25, 15), (26, 14), (27, 13), (28, 12), (29, 11), (30, 11), (31, 12), (32, 12), (33, 13), (34, 14), (35, 15), (36, 16), (37, 17), (38, 18), (39, 19), (40, 20), (41, 21), (42, 22), (43, 23), (44, 24), (45, 25)]\n{'success': True, 'start': (5, 5), 'goal': (45, 25), 'length': 60.76955262170047, 'cost': 60.76955262170047, 'expand': {(5, 5): Node((5, 5), None, 0, 44.721359549995796), ...}}\n</code></pre></p> <p>Visualize. Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"--\", color=\"C4\")\nvis.show()\nvis.close()\n</code></pre></p> <p></p> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 51], [0, 31]])\n\nmap_.fill_boundary_with_obstacles()\nmap_.type_map[10:21, 15] = TYPES.OBSTACLE\nmap_.type_map[20, :15] = TYPES.OBSTACLE\nmap_.type_map[30, 15:] = TYPES.OBSTACLE\nmap_.type_map[40, :16] = TYPES.OBSTACLE\n\nmap_.inflate_obstacles(radius=3)\n\nstart = (5, 5)\ngoal = (45, 25)\n\nmap_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n\nplanner = AStar(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\nmap_.fill_expands(path_info[\"expand\"])  # for visualizing the expanded nodes\n\nvis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"--\", color=\"C4\")\nvis.show()\nvis.close()\n</code></pre>"},{"location":"tutorials/2d/path_planner/sample_search.html","title":"1.2.2 - Sample Search","text":"<p>Create the path-planner and plan the path. Python<pre><code>planner = RRT(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\n</code></pre></p> <p>Print results: Text Only<pre><code>[(5, 5), (5, 8), (7, 13), (5, 18), (5, 21), (10, 21), (15, 23), (20, 23), (21, 21), (21, 19), (25, 16), (28, 12), (30, 8), (35, 7), (35, 9), (36, 13), (35, 18), (39, 22), (43, 24), (45, 25)]\n{'success': True, 'start': (5, 5), 'goal': (45, 25), 'length': 79.54990118869786, 'cost': 79.54990118869786, 'expand': {(5, 5): Node((5, 5), None, 0, 0), ...}}\n</code></pre></p> <p>Visualize. Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"--\", color=\"C4\")\nvis.plot_expand_tree(path_info[\"expand\"])   # sample-search-featured expand tree\nvis.show()\nvis.close()\n</code></pre></p> <p></p> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 51], [0, 31]])\n\nmap_.fill_boundary_with_obstacles()\nmap_.type_map[10:21, 15] = TYPES.OBSTACLE\nmap_.type_map[20, :15] = TYPES.OBSTACLE\nmap_.type_map[30, 15:] = TYPES.OBSTACLE\nmap_.type_map[40, :16] = TYPES.OBSTACLE\n\nmap_.inflate_obstacles(radius=3)\n\nstart = (5, 5)\ngoal = (45, 25)\n\nmap_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n\nplanner = RRT(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\n\nvis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"--\", color=\"C4\")\nvis.plot_expand_tree(path_info[\"expand\"])\nvis.show()\nvis.close()\n</code></pre>"},{"location":"tutorials/3d/map/grid.html","title":"2.1.1 - Grid","text":"<p>Fix the random seed to ensure reproducible results.</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n</code></pre> <p>Import necessary modules.</p> Python<pre><code>from python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n</code></pre> <p>Define the grid map and add and inflate obstacles.</p> Python<pre><code>map_ = Grid(bounds=[[0, 21], [0, 21], [0, 21]], resolution=1.0)\nmap_.type_map[:, 7, 0:11] = TYPES.OBSTACLE\nmap_.type_map[6:11, 8:13, :] = TYPES.OBSTACLE\nmap_.type_map[14, 13:, 11:] = TYPES.OBSTACLE\nmap_.type_map[6:11, 0:8, 11] = TYPES.OBSTACLE\nmap_.inflate_obstacles(radius=3)\n</code></pre> <p>Visualize to check the map.</p> Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.show()\nvis.close()\n</code></pre> <p></p> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 21], [0, 21], [0, 21]], resolution=1.0)\nmap_.type_map[:, 7, 0:11] = TYPES.OBSTACLE\nmap_.type_map[6:11, 8:13, :] = TYPES.OBSTACLE\nmap_.type_map[14, 13:, 11:] = TYPES.OBSTACLE\nmap_.type_map[6:11, 0:8, 11] = TYPES.OBSTACLE\nmap_.inflate_obstacles(radius=3)\n\nvis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.show()\nvis.close()\n</code></pre>"},{"location":"tutorials/3d/path_planner/graph_search.html","title":"2.2.1 - Graph Search","text":"<p>Define start and goal points.</p> Python<pre><code>start = (2, 2, 2)\ngoal = (18, 18, 18)\n</code></pre> <p>Add the start and goal points to the map. Python<pre><code>map_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n</code></pre></p> <p>Create the path-planner and plan the path. Python<pre><code>planner = AStar(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\n</code></pre></p> <p>Print results: Text Only<pre><code>[(2, 2, 2), (3, 2, 2), (4, 2, 3), (5, 2, 3), (6, 2, 4), (7, 2, 5), (8, 2, 5), (9, 2, 5), (10, 2, 6), (11, 3, 7), (12, 3, 8), (13, 3, 9), (13, 3, 10), (14, 4, 11), (14, 4, 12), (15, 5, 13), (16, 6, 14), (17, 7, 15), (18, 8, 16), (18, 9, 16), (18, 10, 16), (18, 11, 16), (18, 12, 16), (18, 13, 16), (18, 14, 16), (18, 15, 16), (18, 16, 17), (18, 17, 18), (18, 18, 18)]\n{'success': True, 'start': (2, 2, 2), 'goal': (18, 18, 18), 'length': 35.70601334439802, 'cost': 35.70601334439802, 'expand': {(2, 2, 2): Node((2, 2, 2), None, 0, 27.712812921102035), ...}}\n</code></pre></p> <p>Visualize. Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_, equal=False)\nvis.plot_path(path, style=\"-\", color=\"C2\")\nvis.show()\nvis.close()\n</code></pre></p> <p></p> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 21], [0, 21], [0, 21]], resolution=1.0)\nmap_.type_map[:, 7, 0:11] = TYPES.OBSTACLE\nmap_.type_map[6:11, 8:13, :] = TYPES.OBSTACLE\nmap_.type_map[14, 13:, 11:] = TYPES.OBSTACLE\nmap_.type_map[6:11, 0:8, 11] = TYPES.OBSTACLE\nmap_.inflate_obstacles(radius=3)\n\nstart = (2, 2, 2)\ngoal = (18, 18, 18)\n\nmap_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n\nplanner = AStar(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\n\nvis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"-\", color=\"C2\")\nvis.show()\nvis.close()\n</code></pre>"},{"location":"tutorials/3d/path_planner/sample_search.html","title":"2.2.2 - Sample Search","text":"<p>Create the path-planner and plan the path. Python<pre><code>planner = RRT(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\n</code></pre></p> <p>Print results: Text Only<pre><code>[(2, 2, 2), (6, 2, 4), (9, 3, 2), (14, 1, 2), (15, 2, 7), (17, 3, 11), (13, 2, 14), (14, 7, 16), (16, 10, 19), (19, 14, 19), (18, 18, 18)]\n{'success': True, 'start': (2, 2, 2), 'goal': (18, 18, 18), 'length': 47.88698780215766, 'cost': 47.88698780215766, 'expand': {(2, 2, 2): Node((2, 2, 2), None, 0, 0), ...}}\n</code></pre></p> <p>Visualize. Python<pre><code>vis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"-\", color=\"C2\")\nvis.plot_expand_tree(path_info[\"expand\"])   # sample-search-featured expand tree\nvis.show()\nvis.close()\n</code></pre></p> <p></p> <p>Runnable complete code:</p> Python<pre><code>import random\nrandom.seed(0)\n\nimport numpy as np\nnp.random.seed(0)\n\nfrom python_motion_planning.common import *\nfrom python_motion_planning.path_planner import *\nfrom python_motion_planning.controller import *\n\nmap_ = Grid(bounds=[[0, 21], [0, 21], [0, 21]], resolution=1.0)\nmap_.type_map[:, 7, 0:11] = TYPES.OBSTACLE\nmap_.type_map[6:11, 8:13, :] = TYPES.OBSTACLE\nmap_.type_map[14, 13:, 11:] = TYPES.OBSTACLE\nmap_.type_map[6:11, 0:8, 11] = TYPES.OBSTACLE\nmap_.inflate_obstacles(radius=3)\n\nstart = (2, 2, 2)\ngoal = (18, 18, 18)\n\nmap_.type_map[start] = TYPES.START\nmap_.type_map[goal] = TYPES.GOAL\n\nplanner = RRT(map_=map_, start=start, goal=goal)\npath, path_info = planner.plan()\nprint(path)\nprint(path_info)\n\nvis = Visualizer(\"Path Visualizer\")\nvis.plot_grid_map(map_)\nvis.plot_path(path, style=\"-\", color=\"C2\")\nvis.plot_expand_tree(path_info[\"expand\"])   # sample-search-featured expand tree\nvis.show()\nvis.close()\n</code></pre>"}]}